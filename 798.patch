diff --git a/clutter/clutter/clutter-actor.c b/clutter/clutter/clutter-actor.c
index f600a838c8e1a0689f22a79a336d37e0a0b5e3fd..fd1169c4359ce56752c8589e66cd9da59343d886 100644
--- a/clutter/clutter/clutter-actor.c
+++ b/clutter/clutter/clutter-actor.c
@@ -20179,6 +20179,23 @@ clutter_actor_get_transition (ClutterActor *self,
   return clos->transition;
 }
 
+/**
+ * clutter_actor_has_transitions: (skip)
+ */
+gboolean
+clutter_actor_has_transitions (ClutterActor *self)
+{
+  const ClutterAnimationInfo *info;
+
+  g_return_val_if_fail (CLUTTER_IS_ACTOR (self), FALSE);
+
+  info = _clutter_actor_get_animation_info_or_defaults (self);
+  if (info->transitions == NULL)
+    return FALSE;
+
+  return g_hash_table_size (info->transitions) > 0;
+}
+
 /**
  * clutter_actor_save_easing_state:
  * @self: a #ClutterActor
diff --git a/clutter/clutter/clutter-mutter.h b/clutter/clutter/clutter-mutter.h
index ca600da945a81ff9486dd549806bf5cd35af5942..f8aa9d2fa106c3a65505701d30917d06b5c775ee 100644
--- a/clutter/clutter/clutter-mutter.h
+++ b/clutter/clutter/clutter-mutter.h
@@ -57,9 +57,16 @@ void clutter_stage_thaw_updates (ClutterStage *stage);
 CLUTTER_EXPORT
 void clutter_stage_update_resource_scales (ClutterStage *stage);
 
+CLUTTER_EXPORT
+void clutter_stage_view_assign_next_scanout (ClutterStageView *stage_view,
+                                             CoglScanout      *scanout);
+
 CLUTTER_EXPORT
 gboolean clutter_actor_has_damage (ClutterActor *actor);
 
+CLUTTER_EXPORT
+gboolean clutter_actor_has_transitions (ClutterActor *actor);
+
 #undef __CLUTTER_H_INSIDE__
 
 #endif /* __CLUTTER_MUTTER_H__ */
diff --git a/clutter/clutter/clutter-stage-private.h b/clutter/clutter/clutter-stage-private.h
index 12b55ad76930097bf524b2c4f0c43c9655e96a1c..44c3b5093084ef27bf1f0b6366587803532eb11a 100644
--- a/clutter/clutter/clutter-stage-private.h
+++ b/clutter/clutter/clutter-stage-private.h
@@ -141,11 +141,9 @@ void            _clutter_stage_presented                (ClutterStage      *stag
                                                          CoglFrameEvent     frame_event,
                                                          ClutterFrameInfo  *frame_info);
 
-GList *         _clutter_stage_peek_stage_views         (ClutterStage *stage);
-
 void            clutter_stage_queue_actor_relayout      (ClutterStage *stage,
                                                          ClutterActor *actor);
 
 G_END_DECLS
 
 #endif /* __CLUTTER_STAGE_PRIVATE_H__ */
diff --git a/clutter/clutter/clutter-stage-view-private.h b/clutter/clutter/clutter-stage-view-private.h
index 89c42599fc9ae4b1778c768e26e70ebfdabcec96..9e3eb4bef9e7f0919c8ae300bfb42af88da51e09 100644
--- a/clutter/clutter/clutter-stage-view-private.h
+++ b/clutter/clutter/clutter-stage-view-private.h
@@ -33,5 +33,6 @@ gboolean clutter_stage_view_is_dirty_projection (ClutterStageView *view);
 void clutter_stage_view_set_dirty_projection (ClutterStageView *view,
                                               gboolean          dirty);
 
+CoglScanout * clutter_stage_view_take_scanout (ClutterStageView *view);
 
 #endif /* __CLUTTER_STAGE_VIEW_PRIVATE_H__ */
diff --git a/clutter/clutter/clutter-stage-view.c b/clutter/clutter/clutter-stage-view.c
index a12261f449df4ff111e5bb436213a1d2c7681e4f..fca0fe42d015616e443192d5af7880f9bd1e0ac9 100644
--- a/clutter/clutter/clutter-stage-view.c
+++ b/clutter/clutter/clutter-stage-view.c
@@ -23,6 +23,9 @@
 #include <cairo-gobject.h>
 #include <math.h>
 
+#include "clutter/clutter-mutter.h"
+#include "cogl/cogl-scanout.h"
+
 enum
 {
   PROP_0,
@@ -49,3 +49,5 @@ typedef struct _ClutterStageViewPrivate
+  CoglScanout *next_scanout;
+
   guint dirty_viewport   : 1;
   guint dirty_projection : 1;
 } ClutterStageViewPrivate;
@@ -237,6 +242,26 @@ clutter_stage_default_get_offscreen_transformation_matrix (ClutterStageView *vie
   cogl_matrix_init_identity (matrix);
 }
 
+void
+clutter_stage_view_assign_next_scanout (ClutterStageView *view,
+                                        CoglScanout      *scanout)
+{
+  ClutterStageViewPrivate *priv =
+    clutter_stage_view_get_instance_private (view);
+
+  g_clear_object (&priv->next_scanout);
+  priv->next_scanout = scanout;
+}
+
+CoglScanout *
+clutter_stage_view_take_scanout (ClutterStageView *view)
+{
+  ClutterStageViewPrivate *priv =
+    clutter_stage_view_get_instance_private (view);
+
+  return g_steal_pointer (&priv->next_scanout);
+}
+
 static void
 clutter_stage_view_get_property (GObject    *object,
                                  guint       prop_id,
diff --git a/clutter/clutter/clutter-stage.c b/clutter/clutter/clutter-stage.c
index 85dc406a81a753d87dc2984c26f9a97b0af89f80..6ee7e9050f2f4108dd2ee3f1f37c2309c568a64e 100644
--- a/clutter/clutter/clutter-stage.c
+++ b/clutter/clutter/clutter-stage.c
@@ -4887,14 +4887,6 @@ clutter_stage_thaw_updates (ClutterStage *stage)
     }
 }
 
-GList *
-_clutter_stage_peek_stage_views (ClutterStage *stage)
-{
-  ClutterStagePrivate *priv = stage->priv;
-
-  return _clutter_stage_window_get_views (priv->impl);
-}
-
 void
 clutter_stage_update_resource_scales (ClutterStage *stage)
 {
diff --git a/clutter/clutter/cogl/clutter-stage-cogl.c b/clutter/clutter/cogl/clutter-stage-cogl.c
index 7dfd9b8390b7a8d76d7c3e76d9b19dcafd2a43b0..3e3fda5f266417f51cc655d6d60d56b4de42f107 100644
--- a/clutter/clutter/cogl/clutter-stage-cogl.c
+++ b/clutter/clutter/cogl/clutter-stage-cogl.c
@@ -47,6 +47,7 @@
 #include "clutter-stage-private.h"
 #include "clutter-stage-view-private.h"
 
+#include "cogl/cogl-scanout.h"
 #include "cogl/cogl-trace.h"
 
 typedef struct _ClutterStageViewCoglPrivate
@@ -966,6 +967,20 @@ clutter_stage_cogl_redraw_view (ClutterStageWindow *stage_window,
     }
 }
 
+static void
+clutter_stage_cogl_scanout_view (ClutterStageCogl *stage_cogl,
+                                 ClutterStageView *view,
+                                 CoglScanout      *scanout)
+{
+  CoglFramebuffer *framebuffer = clutter_stage_view_get_framebuffer (view);
+  CoglOnscreen *onscreen;
+
+  g_return_if_fail (cogl_is_onscreen (framebuffer));
+
+  onscreen = COGL_ONSCREEN (framebuffer);
+  cogl_onscreen_direct_scanout (onscreen, scanout);
+}
+
 static void
 clutter_stage_cogl_redraw (ClutterStageWindow *stage_window)
 {
@@ -978,9 +993,20 @@ clutter_stage_cogl_redraw (ClutterStageWindow *stage_window)
   for (l = _clutter_stage_window_get_views (stage_window); l; l = l->next)
     {
       ClutterStageView *view = l->data;
+      g_autoptr (CoglScanout) scanout = NULL;
 
-      swap_event =
-        clutter_stage_cogl_redraw_view (stage_window, view) || swap_event;
+      scanout = clutter_stage_view_take_scanout (view);
+      if (scanout)
+        {
+          clutter_stage_cogl_scanout_view (stage_cogl,
+                                           view,
+                                           scanout);
+          swap_event = TRUE;
+        }
+      else
+        {
+          swap_event |= clutter_stage_cogl_redraw_view (stage_window, view);
+        }
     }
 
   _clutter_stage_emit_after_paint (stage_cogl->wrapper);
diff --git a/cogl/cogl/cogl-attribute.c b/cogl/cogl/cogl-attribute.c
index e9254628548e9e66232ab3085172ca3d250b4837..731da154378777e5fcfc6e697e4a7358100cf190 100644
--- a/cogl/cogl/cogl-attribute.c
+++ b/cogl/cogl/cogl-attribute.c
@@ -652,7 +652,6 @@ _cogl_flush_attributes_state (CoglFramebuffer *framebuffer,
    * pixel and the scene is just comprised of simple rectangles still
    * in the journal. For this optimization to work we need to track
    * when the framebuffer really does get drawn to. */
-  _cogl_framebuffer_mark_mid_scene (framebuffer);
   _cogl_framebuffer_mark_clear_clip_dirty (framebuffer);
 
   if (G_UNLIKELY (!(flags & COGL_DRAW_SKIP_LEGACY_STATE)) &&
diff --git a/cogl/cogl/cogl-framebuffer-private.h b/cogl/cogl/cogl-framebuffer-private.h
index eada73577c96c0771a5dd927d70fb43641b1feef..bafd346873e8bcd9f0b06201cfc7e7c76cc17f47 100644
--- a/cogl/cogl/cogl-framebuffer-private.h
+++ b/cogl/cogl/cogl-framebuffer-private.h
@@ -181,10 +181,6 @@ struct _CoglFramebuffer
   int                 clear_clip_y1;
   gboolean            clear_clip_dirty;
 
-  /* Whether something has been drawn to the buffer since the last
-   * swap buffers or swap region. */
-  gboolean            mid_scene;
-
   /* driver specific */
   gboolean            dirty_bitmasks;
   CoglFramebufferBits bits;
@@ -269,9 +265,6 @@ _cogl_framebuffer_clear_without_flush4f (CoglFramebuffer *framebuffer,
 void
 _cogl_framebuffer_mark_clear_clip_dirty (CoglFramebuffer *framebuffer);
 
-void
-_cogl_framebuffer_mark_mid_scene (CoglFramebuffer *framebuffer);
-
 /*
  * _cogl_framebuffer_get_clip_stack:
  * @framebuffer: A #CoglFramebuffer
diff --git a/cogl/cogl/cogl-framebuffer.c b/cogl/cogl/cogl-framebuffer.c
index 527fd81eac99805b8afdd9de6df4e7b5376d90c1..9ae29e295978d407db3051f9e04b442fc799ecbc 100644
--- a/cogl/cogl/cogl-framebuffer.c
+++ b/cogl/cogl/cogl-framebuffer.c
@@ -241,12 +241,6 @@ _cogl_framebuffer_mark_clear_clip_dirty (CoglFramebuffer *framebuffer)
   framebuffer->clear_clip_dirty = TRUE;
 }
 
-void
-_cogl_framebuffer_mark_mid_scene (CoglFramebuffer *framebuffer)
-{
-  framebuffer->mid_scene = TRUE;
-}
-
 void
 cogl_framebuffer_clear4f (CoglFramebuffer *framebuffer,
                           unsigned long buffers,
@@ -377,7 +371,6 @@ cogl_framebuffer_clear4f (CoglFramebuffer *framebuffer,
 
 cleared:
 
-  _cogl_framebuffer_mark_mid_scene (framebuffer);
   _cogl_framebuffer_mark_clear_clip_dirty (framebuffer);
 
   if (buffers & COGL_BUFFER_BIT_DEPTH)
diff --git a/cogl/cogl/cogl-journal.c b/cogl/cogl/cogl-journal.c
index 083f4a3d40bef2d03a39f0c7af6f501f2433a7e1..76cb382efacedb8913c8f9a86342854287f5d3f4 100644
--- a/cogl/cogl/cogl-journal.c
+++ b/cogl/cogl/cogl-journal.c
@@ -1461,12 +1461,6 @@ _cogl_journal_log_quad (CoglJournal  *journal,
 
   COGL_TIMER_START (_cogl_uprof_context, log_timer);
 
-  /* Adding something to the journal should mean that we are in the
-   * middle of the scene. Although this will also end up being set
-   * when the journal is actually flushed, we set it here explicitly
-   * so that we will know sooner */
-  _cogl_framebuffer_mark_mid_scene (framebuffer);
-
   /* If the framebuffer was previously empty then we'll take a
      reference to the current framebuffer. This reference will be
      removed when the journal is flushed */
diff --git a/cogl/cogl/cogl-onscreen.c b/cogl/cogl/cogl-onscreen.c
index b06eea2a42a7f7f1b646b3a8044ab354fd670b75..66e722cc0dc0e41f2eeba70b7f69e1eb7a13eec6 100644
--- a/cogl/cogl/cogl-onscreen.c
+++ b/cogl/cogl/cogl-onscreen.c
@@ -336,7 +336,6 @@ cogl_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
     }
 
   onscreen->frame_counter++;
-  framebuffer->mid_scene = FALSE;
 }
 
 void
@@ -393,7 +392,6 @@ cogl_onscreen_swap_region (CoglOnscreen *onscreen,
     }
 
   onscreen->frame_counter++;
-  framebuffer->mid_scene = FALSE;
 }
 
 int
@@ -412,6 +410,27 @@ cogl_onscreen_get_buffer_age (CoglOnscreen *onscreen)
   return winsys->onscreen_get_buffer_age (onscreen);
 }
 
+void
+cogl_onscreen_direct_scanout (CoglOnscreen *onscreen,
+                              CoglScanout  *scanout)
+{
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  const CoglWinsysVtable *winsys;
+  CoglFrameInfo *info;
+
+  g_return_if_fail (framebuffer->type == COGL_FRAMEBUFFER_TYPE_ONSCREEN);
+  g_return_if_fail (_cogl_winsys_has_feature (COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT));
+
+  info = _cogl_frame_info_new ();
+  info->frame_counter = onscreen->frame_counter;
+  g_queue_push_tail (&onscreen->pending_frame_infos, info);
+
+  winsys = _cogl_framebuffer_get_winsys (framebuffer);
+  winsys->onscreen_direct_scanout (onscreen, scanout);
+
+  onscreen->frame_counter++;
+}
+
 #ifdef COGL_HAS_X11_SUPPORT
 void
 cogl_x11_onscreen_set_foreign_window_xid (CoglOnscreen *onscreen,
diff --git a/cogl/cogl/cogl-onscreen.h b/cogl/cogl/cogl-onscreen.h
index 6504b56e59e2af5e053df6e87846cc9474e007ac..6b455886edf656a5348cd5786a9e032fdd372bde 100644
--- a/cogl/cogl/cogl-onscreen.h
+++ b/cogl/cogl/cogl-onscreen.h
@@ -50,6 +50,8 @@ G_BEGIN_DECLS
 typedef struct _CoglOnscreen CoglOnscreen;
 #define COGL_ONSCREEN(X) ((CoglOnscreen *)(X))
 
+typedef struct _CoglScanout CoglScanout;
+
 /**
  * cogl_onscreen_get_gtype:
  *
@@ -348,6 +350,13 @@ cogl_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
                                         const int *rectangles,
                                         int n_rectangles);
 
+/**
+ * cogl_onscreen_direct_scanout: (skip)
+ */
+void
+cogl_onscreen_direct_scanout (CoglOnscreen *onscreen,
+                              CoglScanout  *scanout);
+
 /**
  * cogl_onscreen_swap_region:
  * @onscreen: A #CoglOnscreen framebuffer
diff --git a/cogl/cogl/cogl-scanout.c b/cogl/cogl/cogl-scanout.c
new file mode 100644
index 0000000000000000000000000000000000000000..759cd62a4c1527247020bbbe00c8600cbdd8aec6
--- /dev/null
+++ b/cogl/cogl/cogl-scanout.c
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2019 Red Hat Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "cogl-config.h"
+
+#include "cogl-scanout.h"
+
+G_DEFINE_INTERFACE (CoglScanout, cogl_scanout, G_TYPE_OBJECT)
+
+static void
+cogl_scanout_default_init (CoglScanoutInterface *iface)
+{
+}
diff --git a/cogl/cogl/cogl-scanout.h b/cogl/cogl/cogl-scanout.h
new file mode 100644
index 0000000000000000000000000000000000000000..ea4852ee6fb53e4fc7b56629bc7d8d53c7186074
--- /dev/null
+++ b/cogl/cogl/cogl-scanout.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2019 Red Hat Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef COGL_SCANOUT_H
+#define COGL_SCANOUT_H
+
+#include <glib-object.h>
+
+#define COGL_TYPE_SCANOUT (cogl_scanout_get_type ())
+G_DECLARE_INTERFACE (CoglScanout, cogl_scanout,
+                     COGL, SCANOUT, GObject)
+
+struct _CoglScanoutInterface
+{
+  GTypeInterface parent_iface;
+};
+
+#endif /* COGL_SCANOUT_H */
diff --git a/cogl/cogl/meson.build b/cogl/cogl/meson.build
index 1057ef955aa69b8526417ec4410882d208817cec..284e122b8964b4812deda81f34ce139c0bd51832 100644
--- a/cogl/cogl/meson.build
+++ b/cogl/cogl/meson.build
@@ -131,6 +131,7 @@ cogl_nonintrospected_headers = [
   'cogl-version.h',
   'cogl-gtype-private.h',
   'cogl-glib-source.h',
+  'cogl-scanout.h',
 ]
 
 cogl_nodist_headers = [
@@ -364,6 +365,7 @@ cogl_sources = [
   'cogl-closure-list.c',
   'cogl-fence.c',
   'cogl-fence-private.h',
+  'cogl-scanout.c',
   'deprecated/cogl-vertex-buffer-private.h',
   'deprecated/cogl-vertex-buffer.c',
   'deprecated/cogl-material-compat.c',
diff --git a/cogl/cogl/winsys/cogl-winsys-private.h b/cogl/cogl/winsys/cogl-winsys-private.h
index 1ed7bf4fb8c2e2bac2d561389ffc4b8af49c27e1..096bef8ac12c519972b232dbd74702f8d947e06d 100644
--- a/cogl/cogl/winsys/cogl-winsys-private.h
+++ b/cogl/cogl/winsys/cogl-winsys-private.h
@@ -33,6 +33,7 @@
 
 #include "cogl-renderer.h"
 #include "cogl-onscreen.h"
+#include "cogl-scanout.h"
 
 #ifdef COGL_HAS_XLIB_SUPPORT
 #include "cogl-texture-pixmap-x11-private.h"
@@ -111,6 +112,10 @@ typedef struct _CoglWinsysVtable
                                         const int *rectangles,
                                         int n_rectangles);
 
+  void
+  (*onscreen_direct_scanout) (CoglOnscreen *onscreen,
+                              CoglScanout  *scanout);
+
   void
   (*onscreen_set_visibility) (CoglOnscreen *onscreen,
                               gboolean visibility);
diff --git a/src/backends/native/meta-drm-buffer-gbm.c b/src/backends/native/meta-drm-buffer-gbm.c
index d427efdf53d86a350b848ef2b7eee15004290231..266162dbb17ff396bae5348cb7c9a4774c17a237 100644
--- a/src/backends/native/meta-drm-buffer-gbm.c
+++ b/src/backends/native/meta-drm-buffer-gbm.c
@@ -44,7 +44,12 @@ struct _MetaDrmBufferGbm
   uint32_t fb_id;
 };
 
-G_DEFINE_TYPE (MetaDrmBufferGbm, meta_drm_buffer_gbm, META_TYPE_DRM_BUFFER)
+static void
+cogl_scanout_iface_init (CoglScanoutInterface *iface);
+
+G_DEFINE_TYPE_WITH_CODE (MetaDrmBufferGbm, meta_drm_buffer_gbm, META_TYPE_DRM_BUFFER,
+                         G_IMPLEMENT_INTERFACE (COGL_TYPE_SCANOUT,
+                                                cogl_scanout_iface_init))
 
 struct gbm_bo *
 meta_drm_buffer_gbm_get_bo (MetaDrmBufferGbm *buffer_gbm)
@@ -53,9 +58,10 @@ meta_drm_buffer_gbm_get_bo (MetaDrmBufferGbm *buffer_gbm)
 }
 
 static gboolean
-acquire_swapped_buffer (MetaDrmBufferGbm  *buffer_gbm,
-                        gboolean           use_modifiers,
-                        GError           **error)
+init_fb_id (MetaDrmBufferGbm  *buffer_gbm,
+            struct gbm_bo     *bo,
+            gboolean           use_modifiers,
+            GError           **error)
 {
   uint32_t handles[4] = {0, 0, 0, 0};
   uint32_t strides[4] = {0, 0, 0, 0};
@@ -63,21 +69,10 @@ acquire_swapped_buffer (MetaDrmBufferGbm  *buffer_gbm,
   uint64_t modifiers[4] = {0, 0, 0, 0};
   uint32_t width, height;
   uint32_t format;
-  struct gbm_bo *bo;
   int kms_fd;
 
   kms_fd = meta_gpu_kms_get_fd (buffer_gbm->gpu_kms);
 
-  bo = gbm_surface_lock_front_buffer (buffer_gbm->surface);
-  if (!bo)
-    {
-      g_set_error (error,
-                   G_IO_ERROR,
-                   G_IO_ERROR_FAILED,
-                   "gbm_surface_lock_front_buffer failed");
-      return FALSE;
-    }
-
   if (gbm_bo_get_handle_for_plane (bo, 0).s32 == -1)
     {
       /* Failed to fetch handle to plane, falling back to old method */
@@ -120,7 +115,6 @@ acquire_swapped_buffer (MetaDrmBufferGbm  *buffer_gbm,
                        g_io_error_from_errno (errno),
                        "drmModeAddFB2WithModifiers failed: %s",
                        g_strerror (errno));
-          gbm_surface_release_buffer (buffer_gbm->surface, bo);
           return FALSE;
         }
     }
@@ -141,7 +135,6 @@ acquire_swapped_buffer (MetaDrmBufferGbm  *buffer_gbm,
                        G_IO_ERROR_FAILED,
                        "drmModeAddFB does not support format 0x%x",
                        format);
-          gbm_surface_release_buffer (buffer_gbm->surface, bo);
           return FALSE;
         }
 
@@ -159,21 +152,36 @@ acquire_swapped_buffer (MetaDrmBufferGbm  *buffer_gbm,
                        g_io_error_from_errno (errno),
                        "drmModeAddFB failed: %s",
                        g_strerror (errno));
-          gbm_surface_release_buffer (buffer_gbm->surface, bo);
           return FALSE;
         }
     }
 
-  buffer_gbm->bo = bo;
-
   return TRUE;
 }
 
+static gboolean
+acquire_swapped_buffer (MetaDrmBufferGbm  *buffer_gbm,
+                        gboolean           use_modifiers,
+                        GError           **error)
+{
+  buffer_gbm->bo = gbm_surface_lock_front_buffer (buffer_gbm->surface);
+  if (!buffer_gbm->bo)
+    {
+      g_set_error (error,
+                   G_IO_ERROR,
+                   G_IO_ERROR_FAILED,
+                   "gbm_surface_lock_front_buffer failed");
+      return FALSE;
+    }
+
+  return init_fb_id (buffer_gbm, buffer_gbm->bo, use_modifiers, error);
+}
+
 MetaDrmBufferGbm *
-meta_drm_buffer_gbm_new (MetaGpuKms          *gpu_kms,
-                         struct gbm_surface  *gbm_surface,
-                         gboolean             use_modifiers,
-                         GError             **error)
+meta_drm_buffer_gbm_new_acquire (MetaGpuKms          *gpu_kms,
+                                 struct gbm_surface  *gbm_surface,
+                                 gboolean             use_modifiers,
+                                 GError             **error)
 {
   MetaDrmBufferGbm *buffer_gbm;
 
@@ -190,12 +198,39 @@ meta_drm_buffer_gbm_new (MetaGpuKms          *gpu_kms,
   return buffer_gbm;
 }
 
+MetaDrmBufferGbm *
+meta_drm_buffer_gbm_new_take (MetaGpuKms     *gpu_kms,
+                              struct gbm_bo  *bo,
+                              gboolean        use_modifiers,
+                              GError        **error)
+{
+  MetaDrmBufferGbm *buffer_gbm;
+
+  buffer_gbm = g_object_new (META_TYPE_DRM_BUFFER_GBM, NULL);
+  buffer_gbm->gpu_kms = gpu_kms;
+
+  if (!init_fb_id (buffer_gbm, bo, use_modifiers, error))
+    {
+      g_object_unref (buffer_gbm);
+      return NULL;
+    }
+
+  buffer_gbm->bo = bo;
+
+  return buffer_gbm;
+}
+
 static uint32_t
 meta_drm_buffer_gbm_get_fb_id (MetaDrmBuffer *buffer)
 {
   return META_DRM_BUFFER_GBM (buffer)->fb_id;
 }
 
+static void
+cogl_scanout_iface_init (CoglScanoutInterface *iface)
+{
+}
+
 static void
 meta_drm_buffer_gbm_finalize (GObject *object)
 {
@@ -210,7 +245,12 @@ meta_drm_buffer_gbm_finalize (GObject *object)
     }
 
   if (buffer_gbm->bo)
-    gbm_surface_release_buffer (buffer_gbm->surface, buffer_gbm->bo);
+    {
+      if (buffer_gbm->surface)
+        gbm_surface_release_buffer (buffer_gbm->surface, buffer_gbm->bo);
+      else
+        gbm_bo_destroy (buffer_gbm->bo);
+    }
 
   G_OBJECT_CLASS (meta_drm_buffer_gbm_parent_class)->finalize (object);
 }
diff --git a/src/backends/native/meta-drm-buffer-gbm.h b/src/backends/native/meta-drm-buffer-gbm.h
index b48cef06a12b4767cbe8e77ea0fb0205737906ad..b224662252ca0361010f820d55b01ab9d198d6c9 100644
--- a/src/backends/native/meta-drm-buffer-gbm.h
+++ b/src/backends/native/meta-drm-buffer-gbm.h
@@ -33,10 +33,16 @@ G_DECLARE_FINAL_TYPE (MetaDrmBufferGbm,
                       META, DRM_BUFFER_GBM,
                       MetaDrmBuffer)
 
-MetaDrmBufferGbm * meta_drm_buffer_gbm_new (MetaGpuKms          *gpu_kms,
-                                            struct gbm_surface  *gbm_surface,
-                                            gboolean             use_modifiers,
-                                            GError             **error);
+MetaDrmBufferGbm * meta_drm_buffer_gbm_new_acquire (MetaGpuKms          *gpu_kms,
+                                                    struct gbm_surface  *gbm_surface,
+                                                    gboolean             use_modifiers,
+                                                    GError             **error);
+
+
+MetaDrmBufferGbm * meta_drm_buffer_gbm_new_take (MetaGpuKms     *gpu_kms,
+                                                 struct gbm_bo  *gbm_bo,
+                                                 gboolean        use_modifiers,
+                                                 GError        **error);
 
 struct gbm_bo * meta_drm_buffer_gbm_get_bo (MetaDrmBufferGbm *buffer_gbm);
 
diff --git a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
index 5c01375c8209c7d4ce27a551b25695fa879e764e..e884ba7bfc4ab97c3de3c9c36bea511535457811 100644
--- a/src/backends/native/meta-renderer-native.c
+++ b/src/backends/native/meta-renderer-native.c
@@ -316,6 +316,12 @@ meta_gbm_device_from_gpu (MetaGpuKms *gpu_kms)
   return renderer_gpu_data->gbm.device;
 }
 
+MetaGpuKms *
+meta_renderer_native_get_primary_gpu (MetaRendererNative *renderer_native)
+{
+  return renderer_native->primary_gpu_kms;
+}
+
 static MetaRendererNativeGpuData *
 meta_create_renderer_native_gpu_data (MetaGpuKms *gpu_kms)
 {
@@ -1826,14 +1832,15 @@ copy_shared_framebuffer_gpu (CoglOnscreen                        *onscreen,
     }
 
   g_clear_object (&secondary_gpu_state->gbm.next_fb);
-  buffer_gbm = meta_drm_buffer_gbm_new (secondary_gpu_state->gpu_kms,
-                                        secondary_gpu_state->gbm.surface,
-                                        renderer_native->use_modifiers,
-                                        &error);
+  buffer_gbm =
+    meta_drm_buffer_gbm_new_acquire (secondary_gpu_state->gpu_kms,
+                                     secondary_gpu_state->gbm.surface,
+                                     renderer_native->use_modifiers,
+                                     &error);
   secondary_gpu_state->gbm.next_fb = META_DRM_BUFFER (buffer_gbm);
   if (!secondary_gpu_state->gbm.next_fb)
     {
-      g_warning ("meta_drm_buffer_gbm_new failed: %s",
+      g_warning ("meta_drm_buffer_gbm_new_acquire failed: %s",
                  error->message);
       g_error_free (error);
       return;
@@ -2172,6 +2179,33 @@ update_secondary_gpu_state_post_swap_buffers (CoglOnscreen *onscreen,
     }
 }
 
+static void
+ensure_crtc_modes (CoglOnscreen  *onscreen,
+                   MetaKmsUpdate *kms_update)
+{
+  CoglOnscreenEGL *onscreen_egl = onscreen->winsys;
+  MetaOnscreenNative *onscreen_native = onscreen_egl->platform;
+  CoglContext *cogl_context = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglRenderer *cogl_renderer = cogl_context->display->renderer;
+  CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
+  MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
+  MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
+  MetaBackend *backend = renderer_native->backend;
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+  MetaPowerSave power_save_mode;
+
+  power_save_mode = meta_monitor_manager_get_power_save_mode (monitor_manager);
+  if (onscreen_native->pending_set_crtc &&
+      power_save_mode == META_POWER_SAVE_ON)
+    {
+      meta_onscreen_native_set_crtc_modes (onscreen,
+                                           renderer_gpu_data,
+                                           kms_update);
+      onscreen_native->pending_set_crtc = FALSE;
+    }
+}
+
 static void
 meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen *onscreen,
                                                const int    *rectangles,
@@ -2184,8 +2218,6 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen *onscreen,
   MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
   MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
   MetaBackend *backend = renderer_native->backend;
-  MetaMonitorManager *monitor_manager =
-    meta_backend_get_monitor_manager (backend);
   MetaBackendNative *backend_native = META_BACKEND_NATIVE (backend);
   MetaKms *kms = meta_backend_native_get_kms (backend_native);
   CoglOnscreenEGL *onscreen_egl = onscreen->winsys;
@@ -2194,7 +2226,6 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen *onscreen,
   CoglFrameInfo *frame_info;
   gboolean egl_context_changed = FALSE;
   MetaKmsUpdate *kms_update;
-  MetaPowerSave power_save_mode;
   g_autoptr (GError) error = NULL;
   MetaDrmBufferGbm *buffer_gbm;
 
@@ -2229,10 +2260,11 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen *onscreen,
       g_warn_if_fail (onscreen_native->gbm.next_fb == NULL);
       g_clear_object (&onscreen_native->gbm.next_fb);
 
-      buffer_gbm = meta_drm_buffer_gbm_new (render_gpu,
-                                            onscreen_native->gbm.surface,
-                                            renderer_native->use_modifiers,
-                                            &error);
+      buffer_gbm =
+        meta_drm_buffer_gbm_new_acquire (render_gpu,
+                                         onscreen_native->gbm.surface,
+                                         renderer_native->use_modifiers,
+                                         &error);
       onscreen_native->gbm.next_fb = META_DRM_BUFFER (buffer_gbm);
       if (!onscreen_native->gbm.next_fb)
         {
@@ -2250,18 +2282,7 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen *onscreen,
 
   update_secondary_gpu_state_post_swap_buffers (onscreen, &egl_context_changed);
 
-  /* If this is the first framebuffer to be presented then we now setup the
-   * crtc modes, else we flip from the previous buffer */
-
-  power_save_mode = meta_monitor_manager_get_power_save_mode (monitor_manager);
-  if (onscreen_native->pending_set_crtc &&
-      power_save_mode == META_POWER_SAVE_ON)
-    {
-      meta_onscreen_native_set_crtc_modes (onscreen,
-                                           renderer_gpu_data,
-                                           kms_update);
-      onscreen_native->pending_set_crtc = FALSE;
-    }
+  ensure_crtc_modes (onscreen, kms_update);
 
   onscreen_native->pending_queue_swap_notify_frame_count = renderer_native->frame_counter;
   meta_onscreen_native_flip_crtcs (onscreen, kms_update);
@@ -2285,6 +2306,88 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen *onscreen,
   COGL_TRACE_END (MetaRendererNativePostKmsUpdate);
 }
 
+gboolean
+meta_onscreen_native_is_format_scanout_compatible (CoglOnscreen *onscreen,
+                                                   uint32_t      drm_format,
+                                                   uint64_t      drm_modifier)
+{
+  CoglOnscreenEGL *onscreen_egl = onscreen->winsys;
+  MetaOnscreenNative *onscreen_native = onscreen_egl->platform;
+  MetaDrmBuffer *fb;
+  struct gbm_bo *gbm_bo;
+
+  if (g_hash_table_size (onscreen_native->secondary_gpu_states) > 0)
+    return FALSE;
+
+  if (!onscreen_native->gbm.surface)
+    return FALSE;
+
+  fb = onscreen_native->gbm.current_fb ? onscreen_native->gbm.current_fb
+                                       : onscreen_native->gbm.next_fb;
+  if (!fb)
+    return FALSE;
+
+  if (!META_IS_DRM_BUFFER_GBM (fb))
+    return FALSE;
+
+  gbm_bo = meta_drm_buffer_gbm_get_bo (META_DRM_BUFFER_GBM (fb));
+
+  if (gbm_bo_get_format (gbm_bo) != drm_format)
+    return FALSE;
+
+  if (gbm_bo_get_modifier (gbm_bo) != drm_modifier)
+    return FALSE;
+
+  return TRUE;
+}
+
+static void
+meta_onscreen_native_direct_scanout (CoglOnscreen *onscreen,
+                                     CoglScanout  *scanout)
+{
+  CoglOnscreenEGL *onscreen_egl = onscreen->winsys;
+  MetaOnscreenNative *onscreen_native = onscreen_egl->platform;
+  MetaGpuKms *render_gpu = onscreen_native->render_gpu;
+  CoglContext *cogl_context = COGL_FRAMEBUFFER (onscreen)->context;
+  CoglRenderer *cogl_renderer = cogl_context->display->renderer;
+  CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
+  MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
+  MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
+  MetaBackend *backend = renderer_native->backend;
+  MetaBackendNative *backend_native = META_BACKEND_NATIVE (backend);
+  MetaKms *kms = meta_backend_native_get_kms (backend_native);
+  CoglFrameInfo *frame_info;
+  MetaKmsUpdate *kms_update;
+  g_autoptr (GError) error = NULL;
+
+  kms_update = meta_kms_ensure_pending_update (kms);
+
+  wait_for_pending_flips (onscreen);
+
+  frame_info = g_queue_peek_tail (&onscreen->pending_frame_infos);
+  frame_info->global_frame_counter = renderer_native->frame_counter;
+
+  renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
+                                                         render_gpu);
+
+  g_return_if_fail (renderer_gpu_data->mode == META_RENDERER_NATIVE_MODE_GBM);
+
+  g_warn_if_fail (!onscreen_native->gbm.next_fb);
+  g_set_object (&onscreen_native->gbm.next_fb, META_DRM_BUFFER (scanout));
+
+  ensure_crtc_modes (onscreen, kms_update);
+
+  onscreen_native->pending_queue_swap_notify_frame_count =
+    renderer_native->frame_counter;
+  meta_onscreen_native_flip_crtcs (onscreen, kms_update);
+
+  if (!meta_kms_post_pending_update_sync (kms, &error))
+    {
+      if (!g_error_matches (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED))
+        g_warning ("Failed to post KMS update: %s", error->message);
+    }
+}
+
 static gboolean
 meta_renderer_native_init_egl_context (CoglContext *cogl_context,
                                        GError     **error)
@@ -3117,6 +3220,7 @@ get_native_cogl_winsys_vtable (CoglRenderer *cogl_renderer)
       vtable.onscreen_swap_region = NULL;
       vtable.onscreen_swap_buffers_with_damage =
         meta_onscreen_native_swap_buffers_with_damage;
+      vtable.onscreen_direct_scanout = meta_onscreen_native_direct_scanout;
 
       vtable.context_get_clock_time = meta_renderer_native_get_clock_time;
 
diff --git a/src/backends/native/meta-renderer-native.h b/src/backends/native/meta-renderer-native.h
index 650968c57b00835545e96b98e7051836a5dba7bb..f84fd377c1759370a6a05f213ac737486ae00422 100644
--- a/src/backends/native/meta-renderer-native.h
+++ b/src/backends/native/meta-renderer-native.h
@@ -51,10 +51,16 @@ MetaRendererNative * meta_renderer_native_new (MetaBackendNative  *backend_nativ
 
 struct gbm_device * meta_gbm_device_from_gpu (MetaGpuKms *gpu_kms);
 
+MetaGpuKms * meta_renderer_native_get_primary_gpu (MetaRendererNative *renderer_native);
+
 gboolean meta_renderer_native_supports_mirroring (MetaRendererNative *renderer_native);
 
 void meta_renderer_native_finish_frame (MetaRendererNative *renderer_native);
 
 int64_t meta_renderer_native_get_frame_counter (MetaRendererNative *renderer_native);
 
+gboolean meta_onscreen_native_is_format_scanout_compatible (CoglOnscreen *onscreen,
+                                                            uint32_t      drm_format,
+                                                            uint64_t      drm_modifier);
+
 #endif /* META_RENDERER_NATIVE_H */
diff --git a/src/compositor/compositor.c b/src/compositor/compositor.c
index 1ab65ed5a577d3d32bf7684c572b8dc0a670ebe0..1121be28348db8aae5f41bc20a9eb83401170859 100644
--- a/src/compositor/compositor.c
+++ b/src/compositor/compositor.c
@@ -673,7 +673,7 @@ meta_compositor_window_shape_changed (MetaCompositor *compositor,
   if (!window_actor)
     return;
 
-  meta_window_actor_update_shape (window_actor);
+  meta_window_actor_x11_update_shape (META_WINDOW_ACTOR_X11 (window_actor));
 }
 
 void
@@ -1145,18 +1145,6 @@ meta_post_paint_func (gpointer data)
   return TRUE;
 }
 
-static void
-on_shadow_factory_changed (MetaShadowFactory *factory,
-                           MetaCompositor    *compositor)
-{
-  MetaCompositorPrivate *priv =
-    meta_compositor_get_instance_private (compositor);
-  GList *l;
-
-  for (l = priv->windows; l; l = l->next)
-    meta_window_actor_invalidate_shadow (l->data);
-}
-
 static void
 meta_compositor_set_property (GObject      *object,
                               guint         prop_id,
@@ -1207,11 +1195,6 @@ meta_compositor_init (MetaCompositor *compositor)
 
   priv->context = clutter_backend->cogl_context;
 
-  g_signal_connect (meta_shadow_factory_get_default (),
-                    "changed",
-                    G_CALLBACK (on_shadow_factory_changed),
-                    compositor);
-
   priv->pre_paint_func_id =
     clutter_threads_add_repaint_func_full (CLUTTER_REPAINT_FLAGS_PRE_PAINT,
                                            meta_pre_paint_func,
diff --git a/src/compositor/meta-compositor-native.c b/src/compositor/meta-compositor-native.c
new file mode 100644
index 0000000000000000000000000000000000000000..54c33411f8791ce9ac08a2c688457caf2fdb681f
--- /dev/null
+++ b/src/compositor/meta-compositor-native.c
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2019 Red Hat Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include "compositor/meta-compositor-native.h"
+
+#include "backends/meta-logical-monitor.h"
+#include "compositor/meta-surface-actor-wayland.h"
+
+struct _MetaCompositorNative
+{
+  MetaCompositorServer parent;
+};
+
+G_DEFINE_TYPE (MetaCompositorNative, meta_compositor_native,
+               META_TYPE_COMPOSITOR_SERVER)
+
+typedef struct
+{
+  gboolean out_is_transformed;
+} CrtcNonTransformedData;
+
+static void
+check_transformed (MetaLogicalMonitor *logical_monitor,
+                   MetaOutput         *output,
+                   MetaCrtc           *crtc,
+                   gpointer            user_data)
+{
+  CrtcNonTransformedData *data = user_data;
+
+  if (crtc->transform != META_MONITOR_TRANSFORM_NORMAL)
+    data->out_is_transformed = TRUE;
+}
+
+static gboolean
+is_any_crtc_transformed (MetaLogicalMonitor *logical_monitor)
+{
+  CrtcNonTransformedData data = {
+    .out_is_transformed = FALSE
+  };
+
+  meta_logical_monitor_foreach_crtc (logical_monitor, check_transformed, &data);
+
+  return data.out_is_transformed;
+}
+
+static void
+maybe_assign_primary_plane (MetaCompositor *compositor)
+{
+  MetaBackend *backend = meta_get_backend ();
+  MetaRenderer *renderer = meta_backend_get_renderer (backend);
+  MetaWindowActor *window_actor;
+  MetaWindow *window;
+  MetaRendererView *view;
+  CoglFramebuffer *framebuffer;
+  CoglOnscreen *onscreen;
+  MetaSurfaceActor *surface_actor;
+  MetaSurfaceActorWayland *surface_actor_wayland;
+  CoglScanout *scanout;
+
+  if (meta_compositor_is_unredirect_inhibited (compositor))
+    return;
+
+  window_actor = meta_compositor_get_top_window_actor (compositor);
+  if (!window_actor)
+    return;
+
+  if (meta_window_actor_effect_in_progress (window_actor))
+    return;
+
+  if (clutter_actor_has_transitions (CLUTTER_ACTOR (window_actor)))
+    return;
+
+  if (clutter_actor_get_n_children (CLUTTER_ACTOR (window_actor)) != 1)
+    return;
+
+  window = meta_window_actor_get_meta_window (window_actor);
+  if (!window)
+    return;
+
+  if (!meta_window_is_logical_monitor_sized (window))
+    return;
+
+  if (is_any_crtc_transformed (window->monitor))
+    return;
+
+  view = meta_renderer_get_view_from_logical_monitor (renderer,
+                                                      window->monitor);
+
+  framebuffer = clutter_stage_view_get_framebuffer (CLUTTER_STAGE_VIEW (view));
+  if (!cogl_is_onscreen (framebuffer))
+    return;
+
+  surface_actor = meta_window_actor_get_surface (window_actor);
+  if (!META_IS_SURFACE_ACTOR_WAYLAND (surface_actor))
+    return;
+
+  surface_actor_wayland = META_SURFACE_ACTOR_WAYLAND (surface_actor);
+  onscreen = COGL_ONSCREEN (framebuffer);
+  scanout = meta_surface_actor_wayland_try_acquire_scanout (surface_actor_wayland,
+                                                            onscreen);
+  if (!scanout)
+    return;
+
+  clutter_stage_view_assign_next_scanout (CLUTTER_STAGE_VIEW (view), scanout);
+}
+
+static void
+meta_compositor_native_pre_paint (MetaCompositor *compositor)
+{
+  MetaCompositorClass *parent_class;
+
+  maybe_assign_primary_plane (compositor);
+
+  parent_class = META_COMPOSITOR_CLASS (meta_compositor_native_parent_class);
+  parent_class->pre_paint (compositor);
+}
+
+MetaCompositorNative *
+meta_compositor_native_new (MetaDisplay *display)
+{
+  return g_object_new (META_TYPE_COMPOSITOR_NATIVE,
+                       "display", display,
+                       NULL);
+}
+
+static void
+meta_compositor_native_init (MetaCompositorNative *compositor_native)
+{
+}
+
+static void
+meta_compositor_native_class_init (MetaCompositorNativeClass *klass)
+{
+  MetaCompositorClass *compositor_class = META_COMPOSITOR_CLASS (klass);
+
+  compositor_class->pre_paint = meta_compositor_native_pre_paint;
+}
diff --git a/src/compositor/meta-compositor-native.h b/src/compositor/meta-compositor-native.h
new file mode 100644
index 0000000000000000000000000000000000000000..d276a5905fd2ce7e59523d2089a1f422abfa97ad
--- /dev/null
+++ b/src/compositor/meta-compositor-native.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2019 Red Hat Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ */
+
+#ifndef META_COMPOSITOR_NATIVE_H
+#define META_COMPOSITOR_NATIVE_H
+
+#include "compositor/meta-compositor-server.h"
+
+#define META_TYPE_COMPOSITOR_NATIVE (meta_compositor_native_get_type ())
+G_DECLARE_FINAL_TYPE (MetaCompositorNative, meta_compositor_native,
+                      META, COMPOSITOR_NATIVE, MetaCompositor)
+
+MetaCompositorNative * meta_compositor_native_new (MetaDisplay *display);
+
+#endif /* META_COMPOSITOR_NATIVE_H */
diff --git a/src/compositor/meta-compositor-server.c b/src/compositor/meta-compositor-server.c
index 928501f8a798beb399e0f0dce21fdd5535824683..0efee8b42e42631c6fcae6cbe5d3eaad642c9521 100644
--- a/src/compositor/meta-compositor-server.c
+++ b/src/compositor/meta-compositor-server.c
@@ -22,11 +22,6 @@
 
 #include "compositor/meta-compositor-server.h"
 
-struct _MetaCompositorServer
-{
-  MetaCompositor parent;
-};
-
 G_DEFINE_TYPE (MetaCompositorServer, meta_compositor_server, META_TYPE_COMPOSITOR)
 
 static void
diff --git a/src/compositor/meta-compositor-server.h b/src/compositor/meta-compositor-server.h
index 8bff05e7b297574c06457d5b917660abc5a7b25b..8b4a92748ad11696ced010382d1565d2b97bf4f4 100644
--- a/src/compositor/meta-compositor-server.h
+++ b/src/compositor/meta-compositor-server.h
@@ -24,8 +24,13 @@
 #include "compositor/compositor-private.h"
 
 #define META_TYPE_COMPOSITOR_SERVER (meta_compositor_server_get_type ())
-G_DECLARE_FINAL_TYPE (MetaCompositorServer, meta_compositor_server,
-                      META, COMPOSITOR_SERVER, MetaCompositor)
+G_DECLARE_DERIVABLE_TYPE (MetaCompositorServer, meta_compositor_server,
+                          META, COMPOSITOR_SERVER, MetaCompositor)
+
+struct _MetaCompositorServerClass
+{
+  MetaCompositorClass parent_class;
+};
 
 MetaCompositorServer * meta_compositor_server_new (MetaDisplay *display);
 
diff --git a/src/compositor/meta-compositor-x11.c b/src/compositor/meta-compositor-x11.c
index 4f99c35f5d67bf633f68ddd5aa3bec7ae8d3fd97..fce3f830c3f44e58a104e7b7a08cf1ea989f6462 100644
--- a/src/compositor/meta-compositor-x11.c
+++ b/src/compositor/meta-compositor-x11.c
@@ -29,6 +29,7 @@
 #include "backends/x11/meta-event-x11.h"
 #include "clutter/x11/clutter-x11.h"
 #include "compositor/meta-sync-ring.h"
+#include "compositor/meta-window-actor-x11.h"
 #include "core/display-private.h"
 #include "x11/meta-x11-display-private.h"
 
@@ -52,8 +53,9 @@ process_damage (MetaCompositorX11  *compositor_x11,
                 MetaWindow         *window)
 {
   MetaWindowActor *window_actor = meta_window_actor_from_window (window);
+  MetaWindowActorX11 *window_actor_x11 = META_WINDOW_ACTOR_X11 (window_actor);
 
-  meta_window_actor_process_x11_damage (window_actor, damage_xevent);
+  meta_window_actor_x11_process_damage (window_actor_x11, damage_xevent);
 
   compositor_x11->frame_has_updated_xsurfaces = TRUE;
 }
@@ -212,9 +214,11 @@ set_unredirected_window (MetaCompositorX11 *compositor_x11,
   if (prev_unredirected_window)
     {
       MetaWindowActor *window_actor;
+      MetaWindowActorX11 *window_actor_x11;
 
       window_actor = meta_window_actor_from_window (prev_unredirected_window);
-      meta_window_actor_set_unredirected (window_actor, FALSE);
+      window_actor_x11 = META_WINDOW_ACTOR_X11 (window_actor);
+      meta_window_actor_x11_set_unredirected (window_actor_x11, FALSE);
     }
 
   shape_cow_for_window (compositor_x11, window);
@@ -223,33 +227,46 @@ set_unredirected_window (MetaCompositorX11 *compositor_x11,
   if (window)
     {
       MetaWindowActor *window_actor;
+      MetaWindowActorX11 *window_actor_x11;
 
       window_actor = meta_window_actor_from_window (window);
-      meta_window_actor_set_unredirected (window_actor, TRUE);
+      window_actor_x11 = META_WINDOW_ACTOR_X11 (window_actor);
+      meta_window_actor_x11_set_unredirected (window_actor_x11, TRUE);
     }
 }
 
+static void
+maybe_unredirect_top_window (MetaCompositorX11 *compositor_x11)
+{
+  MetaCompositor *compositor = META_COMPOSITOR (compositor_x11);
+  MetaWindow *window_to_unredirect = NULL;
+  MetaWindowActor *window_actor;
+  MetaWindowActorX11 *window_actor_x11;
+
+  if (meta_compositor_is_unredirect_inhibited (compositor))
+    goto out;
+
+  window_actor = meta_compositor_get_top_window_actor (compositor);
+  if (!window_actor)
+    goto out;
+
+  window_actor_x11 = META_WINDOW_ACTOR_X11 (window_actor);
+  if (!meta_window_actor_x11_should_unredirect (window_actor_x11))
+    goto out;
+
+  window_to_unredirect = meta_window_actor_get_meta_window (window_actor);
+
+out:
+  set_unredirected_window (compositor_x11, window_to_unredirect);
+}
+
 static void
 meta_compositor_x11_pre_paint (MetaCompositor *compositor)
 {
   MetaCompositorX11 *compositor_x11 = META_COMPOSITOR_X11 (compositor);
-  MetaWindowActor *top_window_actor;
   MetaCompositorClass *parent_class;
 
-  top_window_actor = meta_compositor_get_top_window_actor (compositor);
-  if (!meta_compositor_is_unredirect_inhibited (compositor) &&
-      top_window_actor &&
-      meta_window_actor_should_unredirect (top_window_actor))
-    {
-      MetaWindow *top_window;
-
-      top_window = meta_window_actor_get_meta_window (top_window_actor);
-      set_unredirected_window (compositor_x11, top_window);
-    }
-  else
-    {
-      set_unredirected_window (compositor_x11, NULL);
-    }
+  maybe_unredirect_top_window (compositor_x11);
 
   parent_class = META_COMPOSITOR_CLASS (meta_compositor_x11_parent_class);
   parent_class->pre_paint (compositor);
diff --git a/src/compositor/meta-shaped-texture-private.h b/src/compositor/meta-shaped-texture-private.h
index 8b078229ce5142392a3b5c2410ef7b8578e0f033..9b340777d3bf7302dc91d6381c5bfa9f958f8308 100644
--- a/src/compositor/meta-shaped-texture-private.h
+++ b/src/compositor/meta-shaped-texture-private.h
@@ -41,6 +41,8 @@ void meta_shaped_texture_set_fallback_size (MetaShapedTexture *stex,
                                             int                fallback_width,
                                             int                fallback_height);
 cairo_region_t * meta_shaped_texture_get_opaque_region (MetaShapedTexture *stex);
+gboolean meta_shaped_texture_is_opaque (MetaShapedTexture *stex);
+gboolean meta_shaped_texture_has_alpha (MetaShapedTexture *stex);
 void meta_shaped_texture_set_transform (MetaShapedTexture    *stex,
                                         MetaMonitorTransform  transform);
 void meta_shaped_texture_set_viewport_src_rect (MetaShapedTexture *stex,
diff --git a/src/compositor/meta-shaped-texture.c b/src/compositor/meta-shaped-texture.c
index f85b55e23b56bc42e6f9eb12260db786b042c550..1a0e202ee2c93e3da2f3a245dbc718c128343682 100644
--- a/src/compositor/meta-shaped-texture.c
+++ b/src/compositor/meta-shaped-texture.c
@@ -1019,6 +1019,60 @@ meta_shaped_texture_get_opaque_region (MetaShapedTexture *stex)
   return stex->opaque_region;
 }
 
+gboolean
+meta_shaped_texture_has_alpha (MetaShapedTexture *stex)
+{
+  CoglTexture *texture;
+
+  texture = stex->texture;
+  if (!texture)
+    return TRUE;
+
+  switch (cogl_texture_get_components (texture))
+    {
+    case COGL_TEXTURE_COMPONENTS_A:
+    case COGL_TEXTURE_COMPONENTS_RGBA:
+      return TRUE;
+    case COGL_TEXTURE_COMPONENTS_RG:
+    case COGL_TEXTURE_COMPONENTS_RGB:
+    case COGL_TEXTURE_COMPONENTS_DEPTH:
+      return FALSE;
+    }
+
+  g_warn_if_reached ();
+  return FALSE;
+}
+
+gboolean
+meta_shaped_texture_is_opaque (MetaShapedTexture *stex)
+{
+  CoglTexture *texture;
+  cairo_rectangle_int_t opaque_rect;
+
+  texture = stex->texture;
+  if (!texture)
+    return FALSE;
+
+  if (!meta_shaped_texture_has_alpha (stex))
+    return TRUE;
+
+  if (!stex->opaque_region)
+    return FALSE;
+
+  if (cairo_region_num_rectangles (stex->opaque_region) != 1)
+    return FALSE;
+
+  cairo_region_get_extents (stex->opaque_region, &opaque_rect);
+
+  ensure_size_valid (stex);
+
+  return meta_rectangle_equal (&opaque_rect,
+                               &(MetaRectangle) {
+                                .width = stex->dst_width,
+                                .height = stex->dst_height
+                               });
+}
+
 void
 meta_shaped_texture_set_transform (MetaShapedTexture    *stex,
                                    MetaMonitorTransform  transform)
diff --git a/src/compositor/meta-surface-actor-wayland.c b/src/compositor/meta-surface-actor-wayland.c
index 1c933d554b8cb072a8dbca6b0d1ae2455c497dec..151d18b305dea92de54b5d905c250f493e80a723 100644
--- a/src/compositor/meta-surface-actor-wayland.c
+++ b/src/compositor/meta-surface-actor-wayland.c
@@ -30,6 +30,7 @@
 
 #include "backends/meta-backend-private.h"
 #include "backends/meta-logical-monitor.h"
+#include "cogl/cogl-scanout.h"
 #include "cogl/cogl-wayland-server.h"
 #include "compositor/meta-shaped-texture-private.h"
 #include "compositor/region-utils.h"
@@ -72,23 +73,42 @@ meta_surface_actor_wayland_is_visible (MetaSurfaceActor *actor)
 }
 
 static gboolean
-meta_surface_actor_wayland_should_unredirect (MetaSurfaceActor *actor)
+meta_surface_actor_wayland_is_opaque (MetaSurfaceActor *actor)
 {
-  return FALSE;
+  MetaShapedTexture *stex = meta_surface_actor_get_texture (actor);
+
+  return meta_shaped_texture_is_opaque (stex);
 }
 
 static void
-meta_surface_actor_wayland_set_unredirected (MetaSurfaceActor *actor,
-                                             gboolean          unredirected)
+queue_frame_callbacks (MetaSurfaceActorWayland *self)
 {
-  /* Do nothing. In the future, we'll use KMS to set this
-   * up as a hardware overlay or something. */
+  MetaWaylandCompositor *wayland_compositor;
+
+  if (!self->surface)
+    return;
+
+  wayland_compositor = self->surface->compositor;
+  wl_list_insert_list (&wayland_compositor->frame_callbacks,
+                       &self->frame_callback_list);
+  wl_list_init (&self->frame_callback_list);
 }
 
-static gboolean
-meta_surface_actor_wayland_is_unredirected (MetaSurfaceActor *actor)
+CoglScanout *
+meta_surface_actor_wayland_try_acquire_scanout (MetaSurfaceActorWayland *self,
+                                                CoglOnscreen            *onscreen)
 {
-  return FALSE;
+  MetaWaylandSurface *surface;
+  CoglScanout *scanout;
+
+  surface = meta_surface_actor_wayland_get_surface (self);
+  scanout = meta_wayland_surface_try_acquire_scanout (surface, onscreen);
+  if (!scanout)
+    return NULL;
+
+  queue_frame_callbacks (self);
+
+  return scanout;
 }
 
 void
@@ -115,13 +135,7 @@ meta_surface_actor_wayland_paint (ClutterActor *actor)
 {
   MetaSurfaceActorWayland *self = META_SURFACE_ACTOR_WAYLAND (actor);
 
-  if (self->surface)
-    {
-      MetaWaylandCompositor *compositor = self->surface->compositor;
-
-      wl_list_insert_list (&compositor->frame_callbacks, &self->frame_callback_list);
-      wl_list_init (&self->frame_callback_list);
-    }
+  queue_frame_callbacks (self);
 
   CLUTTER_ACTOR_CLASS (meta_surface_actor_wayland_parent_class)->paint (actor);
 }
@@ -162,10 +176,7 @@ meta_surface_actor_wayland_class_init (MetaSurfaceActorWaylandClass *klass)
   surface_actor_class->process_damage = meta_surface_actor_wayland_process_damage;
   surface_actor_class->pre_paint = meta_surface_actor_wayland_pre_paint;
   surface_actor_class->is_visible = meta_surface_actor_wayland_is_visible;
-
-  surface_actor_class->should_unredirect = meta_surface_actor_wayland_should_unredirect;
-  surface_actor_class->set_unredirected = meta_surface_actor_wayland_set_unredirected;
-  surface_actor_class->is_unredirected = meta_surface_actor_wayland_is_unredirected;
+  surface_actor_class->is_opaque = meta_surface_actor_wayland_is_opaque;
 
   surface_actor_class->get_window = meta_surface_actor_wayland_get_window;
 
diff --git a/src/compositor/meta-surface-actor-wayland.h b/src/compositor/meta-surface-actor-wayland.h
index e1ad843f7a945cfc55ce805067dd14a2b51c6538..d61a4df5720037e0b07c1c54e25df19957b76ad9 100644
--- a/src/compositor/meta-surface-actor-wayland.h
+++ b/src/compositor/meta-surface-actor-wayland.h
@@ -52,6 +52,9 @@ void meta_surface_actor_wayland_get_subsurface_rect (MetaSurfaceActorWayland *se
 void meta_surface_actor_wayland_add_frame_callbacks (MetaSurfaceActorWayland *self,
                                                      struct wl_list *frame_callbacks);
 
+CoglScanout * meta_surface_actor_wayland_try_acquire_scanout (MetaSurfaceActorWayland *self,
+                                                              CoglOnscreen            *onscreen);
+
 G_END_DECLS
 
 #endif /* __META_SURFACE_ACTOR_WAYLAND_H__ */
diff --git a/src/compositor/meta-surface-actor-x11.c b/src/compositor/meta-surface-actor-x11.c
index a0275c6c31651907a972734c0b1383b0c3ca65b4..195a03b57aed6c40cae20c371c9f6eda8531bac6 100644
--- a/src/compositor/meta-surface-actor-x11.c
+++ b/src/compositor/meta-surface-actor-x11.c
@@ -249,60 +249,25 @@ static gboolean
 meta_surface_actor_x11_is_opaque (MetaSurfaceActor *actor)
 {
   MetaSurfaceActorX11 *self = META_SURFACE_ACTOR_X11 (actor);
+  MetaShapedTexture *stex = meta_surface_actor_get_texture (actor);
 
-  /* If we're not ARGB32, then we're opaque. */
-  if (!meta_surface_actor_is_argb32 (actor))
+  if (meta_surface_actor_x11_is_unredirected (self))
     return TRUE;
 
-  cairo_region_t *opaque_region = meta_surface_actor_get_opaque_region (actor);
-
-  /* If we have no opaque region, then no pixels are opaque. */
-  if (!opaque_region)
-    return FALSE;
-
-  MetaWindow *window = self->window;
-  cairo_rectangle_int_t client_area;
-  meta_window_get_client_area_rect (window, &client_area);
-
-  /* Otherwise, check if our opaque region covers our entire surface. */
-  if (cairo_region_contains_rectangle (opaque_region, &client_area) == CAIRO_REGION_OVERLAP_IN)
-    return TRUE;
-
-  return FALSE;
+  return meta_shaped_texture_is_opaque (stex);
 }
 
-static gboolean
-meta_surface_actor_x11_should_unredirect (MetaSurfaceActor *actor)
+gboolean
+meta_surface_actor_x11_should_unredirect (MetaSurfaceActorX11 *self)
 {
-  MetaSurfaceActorX11 *self = META_SURFACE_ACTOR_X11 (actor);
-
-  MetaWindow *window = self->window;
-
-  if (meta_window_requested_dont_bypass_compositor (window))
-    return FALSE;
-
-  if (window->opacity != 0xFF)
-    return FALSE;
-
-  if (window->shape_region != NULL)
-    return FALSE;
-
-  if (!meta_window_is_monitor_sized (window))
+  if (!meta_surface_actor_x11_is_opaque (META_SURFACE_ACTOR (self)))
     return FALSE;
 
-  if (meta_window_requested_bypass_compositor (window))
-    return TRUE;
-
-  if (!meta_surface_actor_x11_is_opaque (actor))
+  if (!self->does_full_damage &&
+      !meta_window_is_override_redirect (self->window))
     return FALSE;
 
-  if (meta_window_is_override_redirect (window))
-    return TRUE;
-
-  if (self->does_full_damage)
-    return TRUE;
-
-  return FALSE;
+  return TRUE;
 }
 
 static void
@@ -327,12 +292,10 @@ sync_unredirected (MetaSurfaceActorX11 *self)
   meta_x11_error_trap_pop (display->x11_display);
 }
 
-static void
-meta_surface_actor_x11_set_unredirected (MetaSurfaceActor *actor,
-                                         gboolean          unredirected)
+void
+meta_surface_actor_x11_set_unredirected (MetaSurfaceActorX11 *self,
+                                         gboolean             unredirected)
 {
-  MetaSurfaceActorX11 *self = META_SURFACE_ACTOR_X11 (actor);
-
   if (self->unredirected == unredirected)
     return;
 
@@ -340,11 +303,9 @@ meta_surface_actor_x11_set_unredirected (MetaSurfaceActor *actor,
   sync_unredirected (self);
 }
 
-static gboolean
-meta_surface_actor_x11_is_unredirected (MetaSurfaceActor *actor)
+gboolean
+meta_surface_actor_x11_is_unredirected (MetaSurfaceActorX11 *self)
 {
-  MetaSurfaceActorX11 *self = META_SURFACE_ACTOR_X11 (actor);
-
   return self->unredirected;
 }
 
@@ -383,10 +344,7 @@ meta_surface_actor_x11_class_init (MetaSurfaceActorX11Class *klass)
   surface_actor_class->process_damage = meta_surface_actor_x11_process_damage;
   surface_actor_class->pre_paint = meta_surface_actor_x11_pre_paint;
   surface_actor_class->is_visible = meta_surface_actor_x11_is_visible;
-
-  surface_actor_class->should_unredirect = meta_surface_actor_x11_should_unredirect;
-  surface_actor_class->set_unredirected = meta_surface_actor_x11_set_unredirected;
-  surface_actor_class->is_unredirected = meta_surface_actor_x11_is_unredirected;
+  surface_actor_class->is_opaque = meta_surface_actor_x11_is_opaque;
 
   surface_actor_class->get_window = meta_surface_actor_x11_get_window;
 }
diff --git a/src/compositor/meta-surface-actor-x11.h b/src/compositor/meta-surface-actor-x11.h
index 2c4ed4dd6cec7bd6cd519993c4bcd6886a0d1520..4360065cffb01e23864e4d526edf2c9d1c2ef90c 100644
--- a/src/compositor/meta-surface-actor-x11.h
+++ b/src/compositor/meta-surface-actor-x11.h
@@ -46,6 +46,12 @@ MetaSurfaceActor * meta_surface_actor_x11_new (MetaWindow *window);
 
 void meta_surface_actor_x11_set_size (MetaSurfaceActorX11 *self,
                                       int width, int height);
+gboolean meta_surface_actor_x11_should_unredirect (MetaSurfaceActorX11 *self);
+
+void meta_surface_actor_x11_set_unredirected (MetaSurfaceActorX11 *self,
+                                              gboolean             unredirected);
+
+gboolean meta_surface_actor_x11_is_unredirected (MetaSurfaceActorX11 *self);
 
 G_END_DECLS
 
diff --git a/src/compositor/meta-surface-actor.c b/src/compositor/meta-surface-actor.c
index 26915115fffdcf8dc4ee67139b890f393321fc4e..aecf58d26318b7efe5107a7c3758770f5600fe2a 100644
--- a/src/compositor/meta-surface-actor.c
+++ b/src/compositor/meta-surface-actor.c
@@ -221,6 +221,12 @@ meta_surface_actor_class_init (MetaSurfaceActorClass *klass)
                                         G_TYPE_NONE, 0);
 }
 
+gboolean
+meta_surface_actor_is_opaque (MetaSurfaceActor *self)
+{
+  return META_SURFACE_ACTOR_GET_CLASS (self)->is_opaque (self);
+}
+
 static void
 meta_surface_actor_cull_out (MetaCullable   *cullable,
                              cairo_region_t *unobscured_region,
@@ -466,38 +472,6 @@ meta_surface_actor_pre_paint (MetaSurfaceActor *self)
   META_SURFACE_ACTOR_GET_CLASS (self)->pre_paint (self);
 }
 
-gboolean
-meta_surface_actor_is_argb32 (MetaSurfaceActor *self)
-{
-  MetaShapedTexture *stex = meta_surface_actor_get_texture (self);
-  CoglTexture *texture = meta_shaped_texture_get_texture (stex);
-
-  /* If we don't have a texture, like during initialization, assume
-   * that we're ARGB32.
-   *
-   * If we are unredirected and we have no texture assume that we are
-   * not ARGB32 otherwise we wouldn't be unredirected in the first
-   * place. This prevents us from continually redirecting and
-   * unredirecting on every paint.
-   */
-  if (!texture)
-    return !meta_surface_actor_is_unredirected (self);
-
-  switch (cogl_texture_get_components (texture))
-    {
-    case COGL_TEXTURE_COMPONENTS_A:
-    case COGL_TEXTURE_COMPONENTS_RGBA:
-      return TRUE;
-    case COGL_TEXTURE_COMPONENTS_RG:
-    case COGL_TEXTURE_COMPONENTS_RGB:
-    case COGL_TEXTURE_COMPONENTS_DEPTH:
-      return FALSE;
-    default:
-      g_assert_not_reached ();
-      return FALSE;
-    }
-}
-
 gboolean
 meta_surface_actor_is_visible (MetaSurfaceActor *self)
 {
@@ -531,25 +505,6 @@ meta_surface_actor_set_frozen (MetaSurfaceActor *self,
     }
 }
 
-gboolean
-meta_surface_actor_should_unredirect (MetaSurfaceActor *self)
-{
-  return META_SURFACE_ACTOR_GET_CLASS (self)->should_unredirect (self);
-}
-
-void
-meta_surface_actor_set_unredirected (MetaSurfaceActor *self,
-                                     gboolean          unredirected)
-{
-  META_SURFACE_ACTOR_GET_CLASS (self)->set_unredirected (self, unredirected);
-}
-
-gboolean
-meta_surface_actor_is_unredirected (MetaSurfaceActor *self)
-{
-  return META_SURFACE_ACTOR_GET_CLASS (self)->is_unredirected (self);
-}
-
 MetaWindow *
 meta_surface_actor_get_window (MetaSurfaceActor *self)
 {
diff --git a/src/compositor/meta-surface-actor.h b/src/compositor/meta-surface-actor.h
index 1cffcf99cc296bf27c3747a12da7828cecc075ce..ddf394155de9ba234afcf4e317a18ba05e1df982 100644
--- a/src/compositor/meta-surface-actor.h
+++ b/src/compositor/meta-surface-actor.h
@@ -26,11 +26,7 @@ struct _MetaSurfaceActorClass
                                   int x, int y, int width, int height);
   void     (* pre_paint)         (MetaSurfaceActor *actor);
   gboolean (* is_visible)        (MetaSurfaceActor *actor);
-
-  gboolean (* should_unredirect) (MetaSurfaceActor *actor);
-  void     (* set_unredirected)  (MetaSurfaceActor *actor,
-                                  gboolean          unredirected);
-  gboolean (* is_unredirected)   (MetaSurfaceActor *actor);
+  gboolean (* is_opaque)         (MetaSurfaceActor *actor);
 
   MetaWindow *(* get_window)      (MetaSurfaceActor *actor);
 };
@@ -52,17 +48,12 @@ cairo_region_t * meta_surface_actor_get_opaque_region (MetaSurfaceActor *self);
 void meta_surface_actor_process_damage (MetaSurfaceActor *actor,
                                         int x, int y, int width, int height);
 void meta_surface_actor_pre_paint (MetaSurfaceActor *actor);
-gboolean meta_surface_actor_is_argb32 (MetaSurfaceActor *actor);
 gboolean meta_surface_actor_is_visible (MetaSurfaceActor *actor);
+gboolean meta_surface_actor_is_opaque (MetaSurfaceActor *actor);
 
 void meta_surface_actor_set_frozen (MetaSurfaceActor *actor,
                                     gboolean          frozen);
 
-gboolean meta_surface_actor_should_unredirect (MetaSurfaceActor *actor);
-void meta_surface_actor_set_unredirected (MetaSurfaceActor *actor,
-                                          gboolean          unredirected);
-gboolean meta_surface_actor_is_unredirected (MetaSurfaceActor *actor);
-
 void meta_surface_actor_set_transform (MetaSurfaceActor     *self,
                                        MetaMonitorTransform  transform);
 void meta_surface_actor_set_viewport_src_rect (MetaSurfaceActor  *self,
diff --git a/src/compositor/meta-window-actor-private.h b/src/compositor/meta-window-actor-private.h
index a36217f98bf5f3958057e609e05a37eab06d056e..1b60db0257882275688af64fdd9f84c9184fb23e 100644
--- a/src/compositor/meta-window-actor-private.h
+++ b/src/compositor/meta-window-actor-private.h
@@ -46,30 +46,17 @@ void meta_window_actor_size_change   (MetaWindowActor *self,
                                       MetaRectangle   *old_frame_rect,
                                       MetaRectangle   *old_buffer_rect);
 
-void meta_window_actor_process_x11_damage (MetaWindowActor    *self,
-                                           XDamageNotifyEvent *event);
-
 void meta_window_actor_pre_paint      (MetaWindowActor    *self);
 void meta_window_actor_post_paint     (MetaWindowActor    *self);
 void meta_window_actor_frame_complete (MetaWindowActor    *self,
                                        ClutterFrameInfo   *frame_info,
                                        gint64              presentation_time);
 
-void meta_window_actor_invalidate_shadow (MetaWindowActor *self);
-
-void meta_window_actor_get_shape_bounds (MetaWindowActor       *self,
-                                          cairo_rectangle_int_t *bounds);
-
-gboolean meta_window_actor_should_unredirect   (MetaWindowActor *self);
-void     meta_window_actor_set_unredirected    (MetaWindowActor *self,
-                                                gboolean         unredirected);
-
 gboolean meta_window_actor_effect_in_progress  (MetaWindowActor *self);
 
 MetaWindowActorChanges meta_window_actor_sync_actor_geometry (MetaWindowActor *self,
                                                               gboolean         did_placement);
 
-void     meta_window_actor_update_shape        (MetaWindowActor *self);
 void     meta_window_actor_update_opacity      (MetaWindowActor *self);
 void     meta_window_actor_mapped              (MetaWindowActor *self);
 void     meta_window_actor_unmapped            (MetaWindowActor *self);
@@ -95,4 +82,8 @@ int meta_window_actor_get_geometry_scale (MetaWindowActor *window_actor);
 
 void meta_window_actor_notify_damaged (MetaWindowActor *window_actor);
 
+gboolean meta_window_actor_is_frozen (MetaWindowActor *self);
+
+gboolean meta_window_actor_is_opaque (MetaWindowActor *self);
+
 #endif /* META_WINDOW_ACTOR_PRIVATE_H */
diff --git a/src/compositor/meta-window-actor-wayland.c b/src/compositor/meta-window-actor-wayland.c
index e251e3a2711ded7cb148fc93a15d3a6001fcfb50..544d505642893b0c8b180b37bac58b7c7437f71e 100644
--- a/src/compositor/meta-window-actor-wayland.c
+++ b/src/compositor/meta-window-actor-wayland.c
@@ -109,6 +109,8 @@ meta_window_actor_wayland_assign_surface_actor (MetaWindowActor  *actor,
   MetaWindowActorClass *parent_class =
     META_WINDOW_ACTOR_CLASS (meta_window_actor_wayland_parent_class);
 
+  g_warn_if_fail (!meta_window_actor_get_surface (actor));
+
   parent_class->assign_surface_actor (actor, surface_actor);
 
   meta_window_actor_wayland_rebuild_surface_tree (actor);
@@ -142,10 +144,36 @@ meta_window_actor_wayland_queue_destroy (MetaWindowActor *actor)
 {
 }
 
+static gboolean
+meta_window_actor_wayland_get_paint_volume (ClutterActor       *actor,
+                                            ClutterPaintVolume *volume)
+{
+  MetaSurfaceActor *surface;
+
+  surface = meta_window_actor_get_surface (META_WINDOW_ACTOR (actor));
+  if (surface)
+    {
+      ClutterActor *surface_actor = CLUTTER_ACTOR (surface);
+      const ClutterPaintVolume *child_volume;
+
+      child_volume = clutter_actor_get_transformed_paint_volume (surface_actor,
+                                                                 actor);
+      if (!child_volume)
+        return FALSE;
+
+      clutter_paint_volume_union (volume, child_volume);
+    }
+
+  return TRUE;
+}
+
 static void
 meta_window_actor_wayland_class_init (MetaWindowActorWaylandClass *klass)
 {
   MetaWindowActorClass *window_actor_class = META_WINDOW_ACTOR_CLASS (klass);
+  ClutterActorClass *actor_class = CLUTTER_ACTOR_CLASS (klass);
+
+  actor_class->get_paint_volume = meta_window_actor_wayland_get_paint_volume;
 
   window_actor_class->assign_surface_actor = meta_window_actor_wayland_assign_surface_actor;
   window_actor_class->frame_complete = meta_window_actor_wayland_frame_complete;
diff --git a/src/compositor/meta-window-actor-x11.c b/src/compositor/meta-window-actor-x11.c
index a82b923f3154331d74180cf1fc953b65e6e8ddb6..3fd61ec42b3e2673459823da466a447295fd5305 100644
--- a/src/compositor/meta-window-actor-x11.c
+++ b/src/compositor/meta-window-actor-x11.c
@@ -26,14 +26,28 @@
 
 #include "backends/meta-logical-monitor.h"
 #include "compositor/compositor-private.h"
+#include "compositor/meta-cullable.h"
+#include "compositor/meta-shaped-texture-private.h"
 #include "compositor/meta-surface-actor.h"
+#include "compositor/meta-surface-actor-x11.h"
+#include "compositor/region-utils.h"
+#include "core/frame.h"
 #include "core/window-private.h"
 #include "meta/compositor.h"
+#include "meta/meta-enum-types.h"
+#include "meta/meta-shadow-factory.h"
 #include "meta/meta-window-actor.h"
 #include "meta/meta-x11-errors.h"
 #include "meta/window.h"
+#include "x11/window-x11.h"
 #include "x11/meta-x11-display-private.h"
 
+enum
+{
+  PROP_SHADOW_MODE = 1,
+  PROP_SHADOW_CLASS
+};
+
 struct _MetaWindowActorX11
 {
   MetaWindowActor parent;
@@ -44,15 +58,54 @@ struct _MetaWindowActorX11
   guint send_frame_messages_timer;
   int64_t frame_drawn_time;
 
-  guint repaint_scheduled_id;
+  gulong repaint_scheduled_id;
+  gulong size_changed_id;
 
   /* If set, the client needs to be sent a _NET_WM_FRAME_DRAWN
    * client message for one or more messages in ->frames */
   gboolean needs_frame_drawn;
   gboolean repaint_scheduled;
+
+  /*
+   * MetaShadowFactory only caches shadows that are actually in use;
+   * to avoid unnecessary recomputation we do two things: 1) we store
+   * both a focused and unfocused shadow for the window. If the window
+   * doesn't have different focused and unfocused shadow parameters,
+   * these will be the same. 2) when the shadow potentially changes we
+   * don't immediately unreference the old shadow, we just flag it as
+   * dirty and recompute it when we next need it (recompute_focused_shadow,
+   * recompute_unfocused_shadow.) Because of our extraction of
+   * size-invariant window shape, we'll often find that the new shadow
+   * is the same as the old shadow.
+   */
+  MetaShadow *focused_shadow;
+  MetaShadow *unfocused_shadow;
+
+  /* A region that matches the shape of the window, including frame bounds */
+  cairo_region_t *shape_region;
+  /* The region we should clip to when painting the shadow */
+  cairo_region_t *shadow_clip;
+
+  /* Extracted size-invariant shape used for shadows */
+  MetaWindowShape *shadow_shape;
+  char *shadow_class;
+
+  MetaShadowFactory *shadow_factory;
+  gulong shadow_factory_changed_handler_id;
+
+  MetaShadowMode shadow_mode;
+
+  gboolean needs_reshape;
+  gboolean recompute_focused_shadow;
+  gboolean recompute_unfocused_shadow;
 };
 
-G_DEFINE_TYPE (MetaWindowActorX11, meta_window_actor_x11, META_TYPE_WINDOW_ACTOR)
+static MetaCullableInterface *cullable_parent_iface;
+
+static void cullable_iface_init (MetaCullableInterface *iface);
+
+G_DEFINE_TYPE_WITH_CODE (MetaWindowActorX11, meta_window_actor_x11, META_TYPE_WINDOW_ACTOR,
+                         G_IMPLEMENT_INTERFACE (META_TYPE_CULLABLE, cullable_iface_init))
 
 /* Each time the application updates the sync request counter to a new even value
  * value, we queue a frame into the windows list of frames. Once we're painting
@@ -328,6 +381,15 @@ meta_window_actor_x11_frame_complete (MetaWindowActor  *actor,
     }
 }
 
+static void
+surface_size_changed (MetaSurfaceActor *actor,
+                      gpointer          user_data)
+{
+  MetaWindowActorX11 *actor_x11 = META_WINDOW_ACTOR_X11 (user_data);
+
+  meta_window_actor_x11_update_shape (actor_x11);
+}
+
 static void
 meta_window_actor_x11_assign_surface_actor (MetaWindowActor  *actor,
                                             MetaSurfaceActor *surface_actor)
@@ -335,12 +397,29 @@ meta_window_actor_x11_assign_surface_actor (MetaWindowActor  *actor,
   MetaWindowActorClass *parent_class =
     META_WINDOW_ACTOR_CLASS (meta_window_actor_x11_parent_class);
   MetaWindowActorX11 *actor_x11 = META_WINDOW_ACTOR_X11 (actor);
+  MetaSurfaceActor *prev_surface_actor;
+
+  prev_surface_actor = meta_window_actor_get_surface (actor);
+  if (prev_surface_actor)
+    {
+      g_warn_if_fail (meta_is_wayland_compositor ());
+
+      g_clear_signal_handler (&actor_x11->size_changed_id, prev_surface_actor);
+      clutter_actor_remove_child (CLUTTER_ACTOR (actor),
+                                  CLUTTER_ACTOR (prev_surface_actor));
+    }
 
   parent_class->assign_surface_actor (actor, surface_actor);
 
   clutter_actor_add_child (CLUTTER_ACTOR (actor),
                            CLUTTER_ACTOR (surface_actor));
 
+  meta_window_actor_x11_update_shape (actor_x11);
+
+  actor_x11->size_changed_id =
+    g_signal_connect (surface_actor, "size-changed",
+                      G_CALLBACK (surface_size_changed),
+                      actor_x11);
   actor_x11->repaint_scheduled_id =
     g_signal_connect (surface_actor, "repaint-scheduled",
                       G_CALLBACK (surface_repaint_scheduled),
@@ -406,14 +485,734 @@ meta_window_actor_x11_queue_frame_drawn (MetaWindowActor *actor,
     }
 }
 
+static gboolean
+has_shadow (MetaWindowActorX11 *actor_x11)
+{
+  MetaWindow *window =
+    meta_window_actor_get_meta_window (META_WINDOW_ACTOR (actor_x11));
+
+  if (actor_x11->shadow_mode == META_SHADOW_MODE_FORCED_OFF)
+    return FALSE;
+  if (actor_x11->shadow_mode == META_SHADOW_MODE_FORCED_ON)
+    return TRUE;
+
+  /* Leaving out shadows for maximized and fullscreen windows is an effeciency
+   * win and also prevents the unsightly effect of the shadow of maximized
+   * window appearing on an adjacent window */
+  if ((meta_window_get_maximized (window) == META_MAXIMIZE_BOTH) ||
+      meta_window_is_fullscreen (window))
+    return FALSE;
+
+  /*
+   * If we have two snap-tiled windows, we don't want the shadow to obstruct
+   * the other window.
+   */
+  if (meta_window_get_tile_match (window))
+    return FALSE;
+
+  /*
+   * Always put a shadow around windows with a frame - This should override
+   * the restriction about not putting a shadow around ARGB windows.
+   */
+  if (meta_window_get_frame (window))
+    return TRUE;
+
+  /*
+   * Do not add shadows to non-opaque (ARGB32) windows, as we can't easily
+   * generate shadows for them.
+   */
+  if (!meta_window_actor_is_opaque (META_WINDOW_ACTOR (actor_x11)))
+    return FALSE;
+
+  /*
+   * If a window specifies that it has custom frame extents, that likely
+   * means that it is drawing a shadow itself. Don't draw our own.
+   */
+  if (window->has_custom_frame_extents)
+    return FALSE;
+
+  /*
+   * Generate shadows for all other windows.
+   */
+  return TRUE;
+}
+
+gboolean
+meta_window_actor_x11_should_unredirect (MetaWindowActorX11 *actor_x11)
+{
+  MetaWindow *window =
+    meta_window_actor_get_meta_window (META_WINDOW_ACTOR (actor_x11));
+  MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
+  MetaSurfaceActor *surface;
+  MetaSurfaceActorX11 *surface_x11;
+
+  if (meta_window_actor_is_destroyed (META_WINDOW_ACTOR (actor_x11)))
+    return FALSE;
+
+  if (!meta_window_x11_is_unredirectable (window_x11))
+    return FALSE;
+
+  surface = meta_window_actor_get_surface (META_WINDOW_ACTOR (actor_x11));
+  if (!surface)
+    return FALSE;
+
+  if (!META_IS_SURFACE_ACTOR_X11 (surface))
+    return FALSE;
+
+  surface_x11 = META_SURFACE_ACTOR_X11 (surface);
+  return meta_surface_actor_x11_should_unredirect (surface_x11);
+}
+
+void
+meta_window_actor_x11_set_unredirected (MetaWindowActorX11 *actor_x11,
+                                        gboolean            unredirected)
+{
+  MetaSurfaceActor *surface;
+  MetaSurfaceActorX11 *surface_x11;
+
+  surface = meta_window_actor_get_surface (META_WINDOW_ACTOR (actor_x11));
+  g_assert (surface);
+
+  g_return_if_fail (META_IS_SURFACE_ACTOR_X11 (surface));
+
+  surface_x11 = META_SURFACE_ACTOR_X11 (surface);
+  meta_surface_actor_x11_set_unredirected (surface_x11, unredirected);
+}
+
+static const char *
+get_shadow_class (MetaWindowActorX11 *actor_x11)
+{
+  if (actor_x11->shadow_class)
+    {
+      return actor_x11->shadow_class;
+    }
+  else
+    {
+      MetaWindow *window =
+        meta_window_actor_get_meta_window (META_WINDOW_ACTOR (actor_x11));
+      MetaWindowType window_type;
+
+      window_type = meta_window_get_window_type (window);
+      switch (window_type)
+        {
+        case META_WINDOW_DROPDOWN_MENU:
+        case META_WINDOW_COMBO:
+          return "dropdown-menu";
+        case META_WINDOW_POPUP_MENU:
+          return "popup-menu";
+        default:
+          {
+            MetaFrameType frame_type;
+
+            frame_type = meta_window_get_frame_type (window);
+            return meta_frame_type_to_string (frame_type);
+          }
+        }
+    }
+}
+
+static void
+get_shadow_params (MetaWindowActorX11 *actor_x11,
+                   gboolean            appears_focused,
+                   MetaShadowParams   *params)
+{
+  const char *shadow_class = get_shadow_class (actor_x11);
+
+  meta_shadow_factory_get_params (actor_x11->shadow_factory,
+                                  shadow_class, appears_focused,
+                                  params);
+}
+
+static void
+get_shape_bounds (MetaWindowActorX11    *actor_x11,
+                  cairo_rectangle_int_t *bounds)
+{
+  cairo_region_get_extents (actor_x11->shape_region, bounds);
+}
+
+static void
+get_shadow_bounds (MetaWindowActorX11    *actor_x11,
+                   gboolean               appears_focused,
+                   cairo_rectangle_int_t *bounds)
+{
+  MetaShadow *shadow;
+  cairo_rectangle_int_t shape_bounds;
+  MetaShadowParams params;
+
+  shadow = appears_focused ? actor_x11->focused_shadow
+                           : actor_x11->unfocused_shadow;
+
+  get_shape_bounds (actor_x11, &shape_bounds);
+  get_shadow_params (actor_x11, appears_focused, &params);
+
+  meta_shadow_get_bounds (shadow,
+                          params.x_offset + shape_bounds.x,
+                          params.y_offset + shape_bounds.y,
+                          shape_bounds.width,
+                          shape_bounds.height,
+                          bounds);
+}
+
+/* If we have an ARGB32 window that we decorate with a frame, it's
+ * probably something like a translucent terminal - something where
+ * the alpha channel represents transparency rather than a shape.  We
+ * don't want to show the shadow through the translucent areas since
+ * the shadow is wrong for translucent windows (it should be
+ * translucent itself and colored), and not only that, will /look/
+ * horribly wrong - a misplaced big black blob. As a hack, what we
+ * want to do is just draw the shadow as normal outside the frame, and
+ * inside the frame draw no shadow.  This is also not even close to
+ * the right result, but looks OK. We also apply this approach to
+ * windows set to be partially translucent with _NET_WM_WINDOW_OPACITY.
+ */
+static gboolean
+clip_shadow_under_window (MetaWindowActorX11 *actor_x11)
+{
+  MetaWindow *window =
+    meta_window_actor_get_meta_window (META_WINDOW_ACTOR (actor_x11));
+
+  if (window->frame)
+    return TRUE;
+
+  return meta_window_actor_is_opaque (META_WINDOW_ACTOR (actor_x11));
+}
+
+/**
+ * set_clip_region_beneath:
+ * @actor_x11: a #MetaWindowActorX11
+ * @clip_region: the region of the screen that isn't completely
+ *  obscured beneath the main window texture.
+ *
+ * Provides a hint as to what areas need to be drawn *beneath*
+ * the main window texture.  This is the relevant clip region
+ * when drawing the shadow, properly accounting for areas of the
+ * shadow hid by the window itself. This will be set before painting
+ * then unset afterwards.
+ */
+static void
+set_clip_region_beneath (MetaWindowActorX11 *actor_x11,
+                         cairo_region_t     *beneath_region)
+{
+  MetaWindow *window;
+  gboolean appears_focused;
+
+  window = meta_window_actor_get_meta_window (META_WINDOW_ACTOR (actor_x11));
+  appears_focused = meta_window_appears_focused (window);
+  if (appears_focused ? actor_x11->focused_shadow : actor_x11->unfocused_shadow)
+    {
+      g_clear_pointer (&actor_x11->shadow_clip, cairo_region_destroy);
+
+      if (beneath_region)
+        {
+          actor_x11->shadow_clip = cairo_region_copy (beneath_region);
+
+          if (clip_shadow_under_window (actor_x11))
+            {
+              cairo_region_t *frame_bounds;
+
+              frame_bounds = meta_window_get_frame_bounds (window);
+              if (frame_bounds)
+                cairo_region_subtract (actor_x11->shadow_clip, frame_bounds);
+            }
+        }
+      else
+        {
+          actor_x11->shadow_clip = NULL;
+        }
+    }
+}
+
+static void
+check_needs_shadow (MetaWindowActorX11 *actor_x11)
+{
+  MetaWindow *window =
+    meta_window_actor_get_meta_window (META_WINDOW_ACTOR (actor_x11));
+  MetaShadow *old_shadow = NULL;
+  MetaShadow **shadow_location;
+  gboolean recompute_shadow;
+  gboolean should_have_shadow;
+  gboolean appears_focused;
+
+  /* Calling has_shadow() here at every pre-paint is cheap
+   * and avoids the need to explicitly handle window type changes, which
+   * we would do if tried to keep track of when we might be adding or removing
+   * a shadow more explicitly. We only keep track of changes to the *shape* of
+   * the shadow with actor_x11->recompute_shadow.
+   */
+
+  should_have_shadow = has_shadow (actor_x11);
+  appears_focused = meta_window_appears_focused (window);
+
+  if (appears_focused)
+    {
+      recompute_shadow = actor_x11->recompute_focused_shadow;
+      actor_x11->recompute_focused_shadow = FALSE;
+      shadow_location = &actor_x11->focused_shadow;
+    }
+  else
+    {
+      recompute_shadow = actor_x11->recompute_unfocused_shadow;
+      actor_x11->recompute_unfocused_shadow = FALSE;
+      shadow_location = &actor_x11->unfocused_shadow;
+    }
+
+  if (!should_have_shadow || recompute_shadow)
+    {
+      if (*shadow_location != NULL)
+        {
+          old_shadow = *shadow_location;
+          *shadow_location = NULL;
+        }
+    }
+
+  if (!*shadow_location && should_have_shadow)
+    {
+      MetaShadowFactory *factory = actor_x11->shadow_factory;
+      const char *shadow_class = get_shadow_class (actor_x11);
+      cairo_rectangle_int_t shape_bounds;
+
+      if (!actor_x11->shadow_shape)
+        {
+          actor_x11->shadow_shape =
+            meta_window_shape_new (actor_x11->shape_region);
+        }
+
+      get_shape_bounds (actor_x11, &shape_bounds);
+      *shadow_location =
+        meta_shadow_factory_get_shadow (factory,
+                                        actor_x11->shadow_shape,
+                                        shape_bounds.width, shape_bounds.height,
+                                        shadow_class, appears_focused);
+    }
+
+  if (old_shadow)
+    meta_shadow_unref (old_shadow);
+}
+
+void
+meta_window_actor_x11_process_damage (MetaWindowActorX11 *actor_x11,
+                                      XDamageNotifyEvent *event)
+{
+  MetaSurfaceActor *surface;
+
+  surface = meta_window_actor_get_surface (META_WINDOW_ACTOR (actor_x11));
+  if (surface)
+    meta_surface_actor_process_damage (surface,
+                                       event->area.x,
+                                       event->area.y,
+                                       event->area.width,
+                                       event->area.height);
+
+  meta_window_actor_notify_damaged (META_WINDOW_ACTOR (actor_x11));
+}
+
+static cairo_region_t *
+scan_visible_region (guchar         *mask_data,
+                     int             stride,
+                     cairo_region_t *scan_area)
+{
+  int i, n_rects = cairo_region_num_rectangles (scan_area);
+  MetaRegionBuilder builder;
+
+  meta_region_builder_init (&builder);
+
+  for (i = 0; i < n_rects; i++)
+    {
+      int x, y;
+      cairo_rectangle_int_t rect;
+
+      cairo_region_get_rectangle (scan_area, i, &rect);
+
+      for (y = rect.y; y < (rect.y + rect.height); y++)
+        {
+          for (x = rect.x; x < (rect.x + rect.width); x++)
+            {
+              int x2 = x;
+              while (mask_data[y * stride + x2] == 255 && x2 < (rect.x + rect.width))
+                x2++;
+
+              if (x2 > x)
+                {
+                  meta_region_builder_add_rectangle (&builder, x, y, x2 - x, 1);
+                  x = x2;
+                }
+            }
+        }
+    }
+
+  return meta_region_builder_finish (&builder);
+}
+
+static void
+build_and_scan_frame_mask (MetaWindowActorX11    *actor_x11,
+                           cairo_rectangle_int_t *client_area,
+                           cairo_region_t        *shape_region)
+{
+  ClutterBackend *backend = clutter_get_default_backend ();
+  MetaWindow *window =
+    meta_window_actor_get_meta_window (META_WINDOW_ACTOR (actor_x11));
+  CoglContext *ctx = clutter_backend_get_cogl_context (backend);
+  MetaSurfaceActor *surface =
+    meta_window_actor_get_surface (META_WINDOW_ACTOR (actor_x11));
+  uint8_t *mask_data;
+  unsigned int tex_width, tex_height;
+  MetaShapedTexture *stex;
+  CoglTexture *paint_tex;
+  CoglTexture2D *mask_texture;
+  int stride;
+  cairo_t *cr;
+  cairo_surface_t *image;
+  GError *error = NULL;
+
+  stex = meta_surface_actor_get_texture (surface);
+  g_return_if_fail (stex);
+
+  meta_shaped_texture_set_mask_texture (stex, NULL);
+
+  paint_tex = meta_shaped_texture_get_texture (stex);
+  if (paint_tex == NULL)
+    return;
+
+  tex_width = cogl_texture_get_width (paint_tex);
+  tex_height = cogl_texture_get_height (paint_tex);
+
+  stride = cairo_format_stride_for_width (CAIRO_FORMAT_A8, tex_width);
+
+  /* Create data for an empty image */
+  mask_data = g_malloc0 (stride * tex_height);
+
+  image = cairo_image_surface_create_for_data (mask_data,
+                                               CAIRO_FORMAT_A8,
+                                               tex_width,
+                                               tex_height,
+                                               stride);
+  cr = cairo_create (image);
+
+  gdk_cairo_region (cr, shape_region);
+  cairo_fill (cr);
+
+  if (window->frame)
+    {
+      cairo_region_t *frame_paint_region, *scanned_region;
+      cairo_rectangle_int_t rect = { 0, 0, tex_width, tex_height };
+
+      /* Make sure we don't paint the frame over the client window. */
+      frame_paint_region = cairo_region_create_rectangle (&rect);
+      cairo_region_subtract_rectangle (frame_paint_region, client_area);
+
+      gdk_cairo_region (cr, frame_paint_region);
+      cairo_clip (cr);
+
+      meta_frame_get_mask (window->frame, cr);
+
+      cairo_surface_flush (image);
+      scanned_region = scan_visible_region (mask_data, stride, frame_paint_region);
+      cairo_region_union (shape_region, scanned_region);
+      cairo_region_destroy (scanned_region);
+      cairo_region_destroy (frame_paint_region);
+    }
+
+  cairo_destroy (cr);
+  cairo_surface_destroy (image);
+
+  mask_texture = cogl_texture_2d_new_from_data (ctx, tex_width, tex_height,
+                                                COGL_PIXEL_FORMAT_A_8,
+                                                stride, mask_data, &error);
+
+  if (error)
+    {
+      g_warning ("Failed to allocate mask texture: %s", error->message);
+      g_error_free (error);
+    }
+
+  if (mask_texture)
+    {
+      meta_shaped_texture_set_mask_texture (stex, COGL_TEXTURE (mask_texture));
+      cogl_object_unref (mask_texture);
+    }
+  else
+    {
+      meta_shaped_texture_set_mask_texture (stex, NULL);
+    }
+
+  g_free (mask_data);
+}
+
+static void
+invalidate_shadow (MetaWindowActorX11 *actor_x11)
+{
+  actor_x11->recompute_focused_shadow = TRUE;
+  actor_x11->recompute_unfocused_shadow = TRUE;
+
+  if (meta_window_actor_is_frozen (META_WINDOW_ACTOR (actor_x11)))
+    return;
+
+  clutter_actor_queue_redraw (CLUTTER_ACTOR (actor_x11));
+}
+
+static void
+update_shape_region (MetaWindowActorX11 *actor_x11)
+{
+  MetaWindow *window =
+    meta_window_actor_get_meta_window (META_WINDOW_ACTOR (actor_x11));
+  cairo_region_t *region = NULL;
+  cairo_rectangle_int_t client_area;
+
+  meta_window_get_client_area_rect (window, &client_area);
+
+  if (window->frame && window->shape_region)
+    {
+      region = cairo_region_copy (window->shape_region);
+      cairo_region_translate (region, client_area.x, client_area.y);
+    }
+  else if (window->shape_region != NULL)
+    {
+      region = cairo_region_reference (window->shape_region);
+    }
+  else
+    {
+      /* If we don't have a shape on the server, that means that
+       * we have an implicit shape of one rectangle covering the
+       * entire window. */
+      region = cairo_region_create_rectangle (&client_area);
+    }
+
+  if (window->shape_region || window->frame)
+    build_and_scan_frame_mask (actor_x11, &client_area, region);
+
+  g_clear_pointer (&actor_x11->shape_region, cairo_region_destroy);
+  actor_x11->shape_region = region;
+
+  g_clear_pointer (&actor_x11->shadow_shape, meta_window_shape_unref);
+
+  invalidate_shadow (actor_x11);
+}
+
+static void
+update_input_region (MetaWindowActorX11 *actor_x11)
+{
+  MetaWindow *window =
+    meta_window_actor_get_meta_window (META_WINDOW_ACTOR (actor_x11));
+  MetaSurfaceActor *surface =
+    meta_window_actor_get_surface (META_WINDOW_ACTOR (actor_x11));
+  cairo_region_t *region;
+
+  if (window->shape_region && window->input_region)
+    {
+      region = cairo_region_copy (window->shape_region);
+      cairo_region_intersect (region, window->input_region);
+    }
+  else if (window->shape_region)
+    {
+      region = cairo_region_reference (window->shape_region);
+    }
+  else if (window->input_region)
+    {
+      region = cairo_region_reference (window->input_region);
+    }
+  else
+    {
+      region = NULL;
+    }
+
+  meta_surface_actor_set_input_region (surface, region);
+  cairo_region_destroy (region);
+}
+
+static gboolean
+is_actor_maybe_transparent (MetaWindowActorX11 *actor_x11)
+{
+  MetaSurfaceActor *surface;
+  MetaShapedTexture *stex;
+
+  surface = meta_window_actor_get_surface (META_WINDOW_ACTOR (actor_x11));
+  if (!surface)
+    return TRUE;
+
+  if (META_IS_SURFACE_ACTOR_X11 (surface) &&
+      meta_surface_actor_x11_is_unredirected (META_SURFACE_ACTOR_X11 (surface)))
+    return FALSE;
+
+  stex = meta_surface_actor_get_texture (surface);
+  if (!meta_shaped_texture_has_alpha (stex))
+    return FALSE;
+
+  return TRUE;
+}
+
+static void
+update_opaque_region (MetaWindowActorX11 *actor_x11)
+{
+  MetaWindow *window =
+    meta_window_actor_get_meta_window (META_WINDOW_ACTOR (actor_x11));
+  gboolean is_maybe_transparent;
+  cairo_region_t *opaque_region;
+  MetaSurfaceActor *surface;
+
+  is_maybe_transparent = is_actor_maybe_transparent (actor_x11);
+  if (is_maybe_transparent && window->opaque_region)
+    {
+      cairo_rectangle_int_t client_area;
+
+      meta_window_get_client_area_rect (window, &client_area);
+
+      /* The opaque region is defined to be a part of the
+       * window which ARGB32 will always paint with opaque
+       * pixels. For these regions, we want to avoid painting
+       * windows and shadows beneath them.
+       *
+       * If the client gives bad coordinates where it does not
+       * fully paint, the behavior is defined by the specification
+       * to be undefined, and considered a client bug. In mutter's
+       * case, graphical glitches will occur.
+       */
+      opaque_region = cairo_region_copy (window->opaque_region);
+      cairo_region_translate (opaque_region, client_area.x, client_area.y);
+      cairo_region_intersect (opaque_region, actor_x11->shape_region);
+    }
+  else if (is_maybe_transparent)
+    {
+      opaque_region = NULL;
+    }
+  else
+    {
+      opaque_region = cairo_region_reference (actor_x11->shape_region);
+    }
+
+  surface = meta_window_actor_get_surface (META_WINDOW_ACTOR (actor_x11));
+  meta_surface_actor_set_opaque_region (surface, opaque_region);
+  cairo_region_destroy (opaque_region);
+}
+
+static void
+check_needs_reshape (MetaWindowActorX11 *actor_x11)
+{
+  if (!actor_x11->needs_reshape)
+    return;
+
+  update_shape_region (actor_x11);
+  update_input_region (actor_x11);
+  update_opaque_region (actor_x11);
+
+  actor_x11->needs_reshape = FALSE;
+}
+
+void
+meta_window_actor_x11_update_shape (MetaWindowActorX11 *actor_x11)
+{
+  MetaSurfaceActor *surface =
+    meta_window_actor_get_surface (META_WINDOW_ACTOR (actor_x11));
+
+  actor_x11->needs_reshape = TRUE;
+
+  if (meta_window_actor_is_frozen (META_WINDOW_ACTOR (actor_x11)))
+    return;
+
+  clutter_actor_queue_redraw (CLUTTER_ACTOR (surface));
+}
+
+static void
+handle_updates (MetaWindowActorX11 *actor_x11)
+{
+  MetaSurfaceActor *surface =
+    meta_window_actor_get_surface (META_WINDOW_ACTOR (actor_x11));
+
+  if (meta_window_actor_is_frozen (META_WINDOW_ACTOR (actor_x11)))
+    {
+      /* The window is frozen due to a pending animation: we'll wait until
+       * the animation finishes to reshape and repair the window */
+      return;
+    }
+
+  if (META_IS_SURFACE_ACTOR_X11 (surface) &&
+      meta_surface_actor_x11_is_unredirected (META_SURFACE_ACTOR_X11 (surface)))
+    return;
+
+  meta_surface_actor_pre_paint (surface);
+
+  if (!meta_surface_actor_is_visible (surface))
+    return;
+
+  check_needs_reshape (actor_x11);
+  check_needs_shadow (actor_x11);
+}
+
 static void
 meta_window_actor_x11_pre_paint (MetaWindowActor *actor)
 {
   MetaWindowActorX11 *actor_x11 = META_WINDOW_ACTOR_X11 (actor);
 
+  handle_updates (actor_x11);
+
   assign_frame_counter_to_frames (actor_x11);
 }
 
+static void
+meta_window_actor_x11_paint (ClutterActor *actor)
+{
+  MetaWindowActorX11 *actor_x11 = META_WINDOW_ACTOR_X11 (actor);
+  MetaWindow *window;
+  gboolean appears_focused;
+  MetaShadow *shadow;
+
+ /* This window got damage when obscured; we set up a timer
+  * to send frame completion events, but since we're drawing
+  * the window now (for some other reason) cancel the timer
+  * and send the completion events normally */
+  if (actor_x11->send_frame_messages_timer != 0)
+    {
+      remove_frame_messages_timer (actor_x11);
+      assign_frame_counter_to_frames (actor_x11);
+    }
+
+  window = meta_window_actor_get_meta_window (META_WINDOW_ACTOR (actor_x11));
+  appears_focused = meta_window_appears_focused (window);
+  shadow = appears_focused ? actor_x11->focused_shadow
+                           : actor_x11->unfocused_shadow;
+
+  if (shadow)
+    {
+      MetaShadowParams params;
+      cairo_rectangle_int_t shape_bounds;
+      cairo_region_t *clip = actor_x11->shadow_clip;
+
+      get_shape_bounds (actor_x11, &shape_bounds);
+      get_shadow_params (actor_x11, appears_focused, &params);
+
+      /* The frame bounds are already subtracted from actor_x11->shadow_clip
+       * if that exists.
+       */
+      if (!clip && clip_shadow_under_window (actor_x11))
+        {
+          cairo_region_t *frame_bounds;
+          cairo_rectangle_int_t bounds;
+
+          get_shadow_bounds (actor_x11, appears_focused, &bounds);
+          clip = cairo_region_create_rectangle (&bounds);
+
+          frame_bounds = meta_window_get_frame_bounds (window);
+          if (frame_bounds)
+            cairo_region_subtract (clip, frame_bounds);
+        }
+
+      meta_shadow_paint (shadow,
+                         cogl_get_draw_framebuffer (),
+                         params.x_offset + shape_bounds.x,
+                         params.y_offset + shape_bounds.y,
+                         shape_bounds.width,
+                         shape_bounds.height,
+                         (clutter_actor_get_paint_opacity (actor) *
+                          params.opacity * window->opacity) / (255 * 255),
+                         clip,
+                         clip_shadow_under_window (actor_x11));
+
+      if (clip && clip != actor_x11->shadow_clip)
+        cairo_region_destroy (clip);
+    }
+
+  CLUTTER_ACTOR_CLASS (meta_window_actor_x11_parent_class)->paint (actor);
+}
+
 static void
 meta_window_actor_x11_post_paint (MetaWindowActor *actor)
 {
@@ -445,6 +1244,59 @@ meta_window_actor_x11_post_paint (MetaWindowActor *actor)
     }
 }
 
+static gboolean
+meta_window_actor_x11_get_paint_volume (ClutterActor       *actor,
+                                        ClutterPaintVolume *volume)
+{
+  MetaWindowActorX11 *actor_x11 = META_WINDOW_ACTOR_X11 (actor);
+  MetaWindow *window;
+  gboolean appears_focused;
+  MetaSurfaceActor *surface;
+
+  /* The paint volume is computed before paint functions are called
+   * so our bounds might not be updated yet. Force an update. */
+  handle_updates (actor_x11);
+
+  window = meta_window_actor_get_meta_window (META_WINDOW_ACTOR (actor_x11));
+  appears_focused = meta_window_appears_focused (window);
+  if (appears_focused ? actor_x11->focused_shadow : actor_x11->unfocused_shadow)
+    {
+      cairo_rectangle_int_t shadow_bounds;
+      ClutterActorBox shadow_box;
+
+      /* We could compute an full clip region as we do for the window
+       * texture, but the shadow is relatively cheap to draw, and
+       * a little more complex to clip, so we just catch the case where
+       * the shadow is completely obscured and doesn't need to be drawn
+       * at all.
+       */
+
+      get_shadow_bounds (actor_x11, appears_focused, &shadow_bounds);
+      shadow_box.x1 = shadow_bounds.x;
+      shadow_box.x2 = shadow_bounds.x + shadow_bounds.width;
+      shadow_box.y1 = shadow_bounds.y;
+      shadow_box.y2 = shadow_bounds.y + shadow_bounds.height;
+
+      clutter_paint_volume_union_box (volume, &shadow_box);
+    }
+
+  surface = meta_window_actor_get_surface (META_WINDOW_ACTOR (actor_x11));
+  if (surface)
+    {
+      ClutterActor *surface_actor = CLUTTER_ACTOR (surface);
+      const ClutterPaintVolume *child_volume;
+
+      child_volume = clutter_actor_get_transformed_paint_volume (surface_actor,
+                                                                 actor);
+      if (!child_volume)
+        return FALSE;
+
+      clutter_paint_volume_union (volume, child_volume);
+    }
+
+  return TRUE;
+}
+
 static void
 meta_window_actor_x11_queue_destroy (MetaWindowActor *actor)
 {
@@ -455,29 +1307,80 @@ meta_window_actor_x11_queue_destroy (MetaWindowActor *actor)
 }
 
 static void
-meta_window_actor_x11_paint (ClutterActor *actor)
+meta_window_actor_x11_set_property (GObject      *object,
+                                    guint         prop_id,
+                                    const GValue *value,
+                                    GParamSpec   *pspec)
 {
-  MetaWindowActorX11 *actor_x11 = META_WINDOW_ACTOR_X11 (actor);
+  MetaWindowActorX11 *actor_x11 = META_WINDOW_ACTOR_X11 (object);
 
- /* This window got damage when obscured; we set up a timer
-  * to send frame completion events, but since we're drawing
-  * the window now (for some other reason) cancel the timer
-  * and send the completion events normally */
-  if (actor_x11->send_frame_messages_timer != 0)
+  switch (prop_id)
     {
-      remove_frame_messages_timer (actor_x11);
-      assign_frame_counter_to_frames (actor_x11);
+    case PROP_SHADOW_MODE:
+      {
+        MetaShadowMode newv = g_value_get_enum (value);
+
+        if (newv == actor_x11->shadow_mode)
+          return;
+
+        actor_x11->shadow_mode = newv;
+
+        invalidate_shadow (actor_x11);
+      }
+      break;
+    case PROP_SHADOW_CLASS:
+      {
+        const char *newv = g_value_get_string (value);
+
+        if (g_strcmp0 (newv, actor_x11->shadow_class) == 0)
+          return;
+
+        g_free (actor_x11->shadow_class);
+        actor_x11->shadow_class = g_strdup (newv);
+
+        invalidate_shadow (actor_x11);
+      }
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
     }
+}
 
-  CLUTTER_ACTOR_CLASS (meta_window_actor_x11_parent_class)->paint (actor);
+static void
+meta_window_actor_x11_get_property (GObject      *object,
+                                    guint         prop_id,
+                                    GValue       *value,
+                                    GParamSpec   *pspec)
+{
+  MetaWindowActorX11 *actor_x11 = META_WINDOW_ACTOR_X11 (object);
+
+  switch (prop_id)
+    {
+    case PROP_SHADOW_MODE:
+      g_value_set_enum (value, actor_x11->shadow_mode);
+      break;
+    case PROP_SHADOW_CLASS:
+      g_value_set_string (value, actor_x11->shadow_class);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
 }
 
 static void
 meta_window_actor_x11_constructed (GObject *object)
 {
-  MetaWindowActor *window_actor = META_WINDOW_ACTOR (object);
-  MetaWindow *window =
-    meta_window_actor_get_meta_window (window_actor);
+  MetaWindowActorX11 *actor_x11 = META_WINDOW_ACTOR_X11 (object);
+  MetaWindowActor *actor = META_WINDOW_ACTOR (actor_x11);
+  MetaWindow *window = meta_window_actor_get_meta_window (actor);
+
+  /*
+   * Start off with an empty shape region to maintain the invariant that it's
+   * always set.
+   */
+  actor_x11->shape_region = cairo_region_create ();
 
   G_OBJECT_CLASS (meta_window_actor_x11_parent_class)->constructed (object);
 
@@ -486,7 +1389,36 @@ meta_window_actor_x11_constructed (GObject *object)
    */
   if (window->extended_sync_request_counter &&
       !meta_window_updates_are_frozen (window))
-    meta_window_actor_queue_frame_drawn (window_actor, FALSE);
+    meta_window_actor_queue_frame_drawn (actor, FALSE);
+}
+
+static void
+meta_window_actor_x11_cull_out (MetaCullable   *cullable,
+                                cairo_region_t *unobscured_region,
+                                cairo_region_t *clip_region)
+{
+  cullable_parent_iface->cull_out (cullable, unobscured_region, clip_region);
+
+  set_clip_region_beneath (META_WINDOW_ACTOR_X11 (cullable), clip_region);
+}
+
+static void
+meta_window_actor_x11_reset_culling (MetaCullable *cullable)
+{
+  MetaWindowActorX11 *actor_x11 = META_WINDOW_ACTOR_X11 (cullable);
+
+  g_clear_pointer (&actor_x11->shadow_clip, cairo_region_destroy);
+
+  cullable_parent_iface->reset_culling (cullable);
+}
+
+static void
+cullable_iface_init (MetaCullableInterface *iface)
+{
+  cullable_parent_iface = g_type_interface_peek_parent (iface);
+
+  iface->cull_out = meta_window_actor_x11_cull_out;
+  iface->reset_culling = meta_window_actor_x11_reset_culling;
 }
 
 static void
@@ -495,17 +1427,27 @@ meta_window_actor_x11_dispose (GObject *object)
   MetaWindowActorX11 *actor_x11 = META_WINDOW_ACTOR_X11 (object);
   MetaSurfaceActor *surface_actor;
 
+  g_clear_signal_handler (&actor_x11->shadow_factory_changed_handler_id,
+                          actor_x11->shadow_factory);
+
   if (actor_x11->send_frame_messages_timer != 0)
     remove_frame_messages_timer (actor_x11);
 
   surface_actor = meta_window_actor_get_surface (META_WINDOW_ACTOR (actor_x11));
   if (surface_actor)
     {
-      g_signal_handler_disconnect (surface_actor,
-                                   actor_x11->repaint_scheduled_id);
-      actor_x11->repaint_scheduled_id = 0;
+      g_clear_signal_handler (&actor_x11->repaint_scheduled_id, surface_actor);
+      g_clear_signal_handler (&actor_x11->size_changed_id, surface_actor);
     }
 
+  g_clear_pointer (&actor_x11->shape_region, cairo_region_destroy);
+  g_clear_pointer (&actor_x11->shadow_clip, cairo_region_destroy);
+
+  g_clear_pointer (&actor_x11->shadow_class, g_free);
+  g_clear_pointer (&actor_x11->focused_shadow, meta_shadow_unref);
+  g_clear_pointer (&actor_x11->unfocused_shadow, meta_shadow_unref);
+  g_clear_pointer (&actor_x11->shadow_shape, meta_window_shape_unref);
+
   G_OBJECT_CLASS (meta_window_actor_x11_parent_class)->dispose (object);
 }
 
@@ -525,6 +1467,7 @@ meta_window_actor_x11_class_init (MetaWindowActorX11Class *klass)
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
   ClutterActorClass *actor_class = CLUTTER_ACTOR_CLASS (klass);
   MetaWindowActorClass *window_actor_class = META_WINDOW_ACTOR_CLASS (klass);
+  GParamSpec *pspec;
 
   window_actor_class->frame_complete = meta_window_actor_x11_frame_complete;
   window_actor_class->assign_surface_actor = meta_window_actor_x11_assign_surface_actor;
@@ -534,13 +1477,46 @@ meta_window_actor_x11_class_init (MetaWindowActorX11Class *klass)
   window_actor_class->queue_destroy = meta_window_actor_x11_queue_destroy;
 
   actor_class->paint = meta_window_actor_x11_paint;
+  actor_class->get_paint_volume = meta_window_actor_x11_get_paint_volume;
 
   object_class->constructed = meta_window_actor_x11_constructed;
+  object_class->set_property = meta_window_actor_x11_set_property;
+  object_class->get_property = meta_window_actor_x11_get_property;
   object_class->dispose = meta_window_actor_x11_dispose;
   object_class->finalize = meta_window_actor_x11_finalize;
+
+  pspec = g_param_spec_enum ("shadow-mode",
+                             "Shadow mode",
+                             "Decides when to paint shadows",
+                             META_TYPE_SHADOW_MODE,
+                             META_SHADOW_MODE_AUTO,
+                             G_PARAM_READWRITE);
+
+  g_object_class_install_property (object_class,
+                                   PROP_SHADOW_MODE,
+                                   pspec);
+
+  pspec = g_param_spec_string ("shadow-class",
+                               "Name of the shadow class for this window.",
+                               "NULL means to use the default shadow class for this window type",
+                               NULL,
+                               G_PARAM_READWRITE);
+
+  g_object_class_install_property (object_class,
+                                   PROP_SHADOW_CLASS,
+                                   pspec);
 }
 
 static void
 meta_window_actor_x11_init (MetaWindowActorX11 *self)
 {
+  /* We do this now since we might be going right back into the frozen state. */
+  g_signal_connect (self, "thawed", G_CALLBACK (handle_updates), NULL);
+
+  self->shadow_factory = meta_shadow_factory_get_default ();
+  self->shadow_factory_changed_handler_id =
+    g_signal_connect (self->shadow_factory,
+                      "changed",
+                      G_CALLBACK (invalidate_shadow),
+                      self);
 }
diff --git a/src/compositor/meta-window-actor-x11.h b/src/compositor/meta-window-actor-x11.h
index 5f20fc0280cf3c6789838d293be9e5636bb3a5af..86b80034d0a0445380df0701856cdd3056405121 100644
--- a/src/compositor/meta-window-actor-x11.h
+++ b/src/compositor/meta-window-actor-x11.h
@@ -31,4 +31,17 @@ G_DECLARE_FINAL_TYPE (MetaWindowActorX11,
                       META, WINDOW_ACTOR_X11,
                       MetaWindowActor)
 
+void meta_window_actor_x11_process_x11_damage (MetaWindowActorX11 *actor_x11,
+                                               XDamageNotifyEvent *event);
+
+gboolean meta_window_actor_x11_should_unredirect (MetaWindowActorX11 *actor_x11);
+
+void meta_window_actor_x11_set_unredirected (MetaWindowActorX11 *actor_x11,
+                                             gboolean            unredirected);
+
+void meta_window_actor_x11_update_shape (MetaWindowActorX11 *actor_x11);
+
+void meta_window_actor_x11_process_damage (MetaWindowActorX11 *actor_x11,
+                                           XDamageNotifyEvent *event);
+
 #endif /* META_WINDOW_ACTOR_X11_H */
diff --git a/src/compositor/meta-window-actor.c b/src/compositor/meta-window-actor.c
index 53f46db7b2cb5d3b12eb93f5b5ed94969de57c0e..3cf8ac7bf2770f515a03ddb2b31b802319314516 100644
--- a/src/compositor/meta-window-actor.c
+++ b/src/compositor/meta-window-actor.c
@@ -26,16 +26,13 @@
 #include <string.h>
 
 #include "backends/meta-screen-cast-window.h"
-#include "core/frame.h"
 #include "compositor/compositor-private.h"
 #include "compositor/meta-cullable.h"
 #include "compositor/meta-shaped-texture-private.h"
 #include "compositor/meta-surface-actor-x11.h"
 #include "compositor/meta-surface-actor.h"
 #include "compositor/meta-window-actor-private.h"
-#include "compositor/region-utils.h"
-#include "meta/meta-enum-types.h"
-#include "meta/meta-shadow-factory.h"
+#include "core/boxes-private.h"
 #include "meta/window.h"
 
 #ifdef HAVE_WAYLAND
@@ -56,35 +53,8 @@ typedef struct _MetaWindowActorPrivate
 
   MetaSurfaceActor *surface;
 
-  /* MetaShadowFactory only caches shadows that are actually in use;
-   * to avoid unnecessary recomputation we do two things: 1) we store
-   * both a focused and unfocused shadow for the window. If the window
-   * doesn't have different focused and unfocused shadow parameters,
-   * these will be the same. 2) when the shadow potentially changes we
-   * don't immediately unreference the old shadow, we just flag it as
-   * dirty and recompute it when we next need it (recompute_focused_shadow,
-   * recompute_unfocused_shadow.) Because of our extraction of
-   * size-invariant window shape, we'll often find that the new shadow
-   * is the same as the old shadow.
-   */
-  MetaShadow       *focused_shadow;
-  MetaShadow       *unfocused_shadow;
-
-  /* A region that matches the shape of the window, including frame bounds */
-  cairo_region_t   *shape_region;
-  /* The region we should clip to when painting the shadow */
-  cairo_region_t   *shadow_clip;
-
-  /* Extracted size-invariant shape used for shadows */
-  MetaWindowShape  *shadow_shape;
-  char *            shadow_class;
-
-  MetaShadowMode    shadow_mode;
-
   int geometry_scale;
 
-  gulong            size_changed_id;
-
   /*
    * These need to be counters rather than flags, since more plugins
    * can implement same effect; the practicality of stacking effects
@@ -101,10 +71,6 @@ typedef struct _MetaWindowActorPrivate
   guint		    visible                : 1;
   guint		    disposed               : 1;
 
-  guint             needs_reshape          : 1;
-  guint             recompute_focused_shadow   : 1;
-  guint             recompute_unfocused_shadow : 1;
-
   guint		    needs_destroy	   : 1;
 
   guint             updates_frozen         : 1;
@@ -116,6 +82,7 @@ enum
   FIRST_FRAME,
   EFFECTS_COMPLETED,
   DAMAGED,
+  THAWED,
 
   LAST_SIGNAL
 };
@@ -125,8 +92,6 @@ static guint signals[LAST_SIGNAL] = { 0 };
 enum
 {
   PROP_META_WINDOW = 1,
-  PROP_SHADOW_MODE,
-  PROP_SHADOW_CLASS
 };
 
 static void meta_window_actor_dispose    (GObject *object);
@@ -143,17 +108,6 @@ static void meta_window_actor_get_property (GObject      *object,
 static void meta_window_actor_real_assign_surface_actor (MetaWindowActor  *self,
                                                          MetaSurfaceActor *surface_actor);
 
-static void meta_window_actor_paint (ClutterActor *actor);
-
-static gboolean meta_window_actor_get_paint_volume (ClutterActor       *actor,
-                                                    ClutterPaintVolume *volume);
-
-static gboolean meta_window_actor_has_shadow (MetaWindowActor *self);
-
-static void meta_window_actor_handle_updates (MetaWindowActor *self);
-
-static void check_needs_reshape (MetaWindowActor *self);
-
 static void cullable_iface_init (MetaCullableInterface *iface);
 
 static void screen_cast_window_iface_init (MetaScreenCastWindowInterface *iface);
@@ -167,7 +121,6 @@ static void
 meta_window_actor_class_init (MetaWindowActorClass *klass)
 {
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
-  ClutterActorClass *actor_class = CLUTTER_ACTOR_CLASS (klass);
   GParamSpec   *pspec;
 
   object_class->dispose      = meta_window_actor_dispose;
@@ -175,9 +128,6 @@ meta_window_actor_class_init (MetaWindowActorClass *klass)
   object_class->get_property = meta_window_actor_get_property;
   object_class->constructed  = meta_window_actor_constructed;
 
-  actor_class->paint = meta_window_actor_paint;
-  actor_class->get_paint_volume = meta_window_actor_get_paint_volume;
-
   klass->assign_surface_actor = meta_window_actor_real_assign_surface_actor;
 
   /**
@@ -234,6 +184,18 @@ meta_window_actor_class_init (MetaWindowActorClass *klass)
                   NULL, NULL, NULL,
                   G_TYPE_NONE, 0);
 
+  /**
+   * MetaWindowActor::thawed:
+   * @actor: the #MetaWindowActor instance
+   */
+  signals[THAWED] =
+    g_signal_new ("thawed",
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+
   pspec = g_param_spec_object ("meta-window",
                                "MetaWindow",
                                "The displayed MetaWindow",
@@ -243,27 +205,6 @@ meta_window_actor_class_init (MetaWindowActorClass *klass)
   g_object_class_install_property (object_class,
                                    PROP_META_WINDOW,
                                    pspec);
-
-  pspec = g_param_spec_enum ("shadow-mode",
-                             "Shadow mode",
-                             "Decides when to paint shadows",
-                             META_TYPE_SHADOW_MODE,
-                             META_SHADOW_MODE_AUTO,
-                             G_PARAM_READWRITE);
-
-  g_object_class_install_property (object_class,
-                                   PROP_SHADOW_MODE,
-                                   pspec);
-
-  pspec = g_param_spec_string ("shadow-class",
-                               "Name of the shadow class for this window.",
-                               "NULL means to use the default shadow class for this window type",
-                               NULL,
-                               G_PARAM_READWRITE);
-
-  g_object_class_install_property (object_class,
-                                   PROP_SHADOW_CLASS,
-                                   pspec);
 }
 
 static void
@@ -283,43 +224,24 @@ window_appears_focused_notify (MetaWindow *mw,
   clutter_actor_queue_redraw (CLUTTER_ACTOR (data));
 }
 
-static void
-surface_size_changed (MetaSurfaceActor *actor,
-                      gpointer          user_data)
-{
-  MetaWindowActor *self = META_WINDOW_ACTOR (user_data);
-
-  meta_window_actor_update_shape (self);
-}
-
-static gboolean
-is_argb32 (MetaWindowActor *self)
+gboolean
+meta_window_actor_is_opaque (MetaWindowActor *self)
 {
   MetaWindowActorPrivate *priv =
     meta_window_actor_get_instance_private (self);
+  MetaWindow *window = priv->window;
 
-  /* assume we're argb until we get the window (because
-     in practice we're drawing nothing, so we're fully
-     transparent)
-  */
-  if (priv->surface)
-    return meta_surface_actor_is_argb32 (priv->surface);
-  else
-    return TRUE;
-}
+  if (window->opacity != 0xff)
+    return FALSE;
 
-static gboolean
-is_opaque (MetaWindowActor *self)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-  MetaWindow *window = priv->window;
+  if (!priv->surface)
+    return FALSE;
 
-  return !is_argb32 (self) && (window->opacity == 0xFF);
+  return meta_surface_actor_is_opaque (priv->surface);
 }
 
-static gboolean
-is_frozen (MetaWindowActor *self)
+gboolean
+meta_window_actor_is_frozen (MetaWindowActor *self)
 {
   MetaWindowActorPrivate *priv =
     meta_window_actor_get_instance_private (self);
@@ -369,14 +291,12 @@ meta_window_actor_thaw (MetaWindowActor *self)
     return;
 
   /* We still might be frozen due to lack of a MetaSurfaceActor */
-  if (is_frozen (self))
+  if (meta_window_actor_is_frozen (self))
     return;
 
   meta_window_actor_sync_thawed_state (self);
 
-  /* We do this now since we might be going right back into the
-   * frozen state */
-  meta_window_actor_handle_updates (self);
+  g_signal_emit (self, signals[THAWED], 0);
 }
 
 static void
@@ -386,25 +306,10 @@ meta_window_actor_real_assign_surface_actor (MetaWindowActor  *self,
   MetaWindowActorPrivate *priv =
     meta_window_actor_get_instance_private (self);
 
-  if (priv->surface)
-    {
-      g_warn_if_fail (priv->window->client_type == META_WINDOW_CLIENT_TYPE_X11 &&
-                      meta_is_wayland_compositor ());
-
-      g_clear_signal_handler (&priv->size_changed_id, priv->surface);
-      clutter_actor_remove_child (CLUTTER_ACTOR (self),
-                                  CLUTTER_ACTOR (priv->surface));
-      g_clear_object (&priv->surface);
-    }
-
+  g_clear_object (&priv->surface);
   priv->surface = g_object_ref_sink (surface_actor);
-  priv->size_changed_id = g_signal_connect (priv->surface, "size-changed",
-                                            G_CALLBACK (surface_size_changed),
-                                            self);
-
-  meta_window_actor_update_shape (self);
 
-  if (is_frozen (self))
+  if (meta_window_actor_is_frozen (self))
     meta_surface_actor_set_frozen (priv->surface, TRUE);
   else
     meta_window_actor_sync_thawed_state (self);
@@ -456,13 +361,9 @@ meta_window_actor_constructed (GObject *object)
 
   meta_window_actor_update_opacity (self);
 
-  /* Start off with an empty shape region to maintain the invariant
-   * that it's always set */
-  priv->shape_region = cairo_region_create ();
-
   meta_window_actor_sync_updates_frozen (self);
 
-  if (is_frozen (self))
+  if (meta_window_actor_is_frozen (self))
     priv->first_frame_state = INITIALLY_FROZEN;
   else
     priv->first_frame_state = DRAWING_FIRST_FRAME;
@@ -486,21 +387,12 @@ meta_window_actor_dispose (GObject *object)
 
   priv->disposed = TRUE;
 
-  g_clear_pointer (&priv->shape_region, cairo_region_destroy);
-  g_clear_pointer (&priv->shadow_clip, cairo_region_destroy);
-
-  g_clear_pointer (&priv->shadow_class, g_free);
-  g_clear_pointer (&priv->focused_shadow, meta_shadow_unref);
-  g_clear_pointer (&priv->unfocused_shadow, meta_shadow_unref);
-  g_clear_pointer (&priv->shadow_shape, meta_window_shape_unref);
-
   meta_compositor_remove_window_actor (compositor, self);
 
   g_clear_object (&priv->window);
 
   if (priv->surface)
     {
-      g_clear_signal_handler (&priv->size_changed_id, priv->surface);
       clutter_actor_remove_child (CLUTTER_ACTOR (self),
                                   CLUTTER_ACTOR (priv->surface));
       g_clear_object (&priv->surface);
@@ -526,31 +418,6 @@ meta_window_actor_set_property (GObject      *object,
       g_signal_connect_object (priv->window, "notify::appears-focused",
                                G_CALLBACK (window_appears_focused_notify), self, 0);
       break;
-    case PROP_SHADOW_MODE:
-      {
-        MetaShadowMode newv = g_value_get_enum (value);
-
-        if (newv == priv->shadow_mode)
-          return;
-
-        priv->shadow_mode = newv;
-
-        meta_window_actor_invalidate_shadow (self);
-      }
-      break;
-    case PROP_SHADOW_CLASS:
-      {
-        const char *newv = g_value_get_string (value);
-
-        if (g_strcmp0 (newv, priv->shadow_class) == 0)
-          return;
-
-        g_free (priv->shadow_class);
-        priv->shadow_class = g_strdup (newv);
-
-        meta_window_actor_invalidate_shadow (self);
-      }
-      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -572,278 +439,12 @@ meta_window_actor_get_property (GObject      *object,
     case PROP_META_WINDOW:
       g_value_set_object (value, priv->window);
       break;
-    case PROP_SHADOW_MODE:
-      g_value_set_enum (value, priv->shadow_mode);
-      break;
-    case PROP_SHADOW_CLASS:
-      g_value_set_string (value, priv->shadow_class);
-      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
     }
 }
 
-static const char *
-meta_window_actor_get_shadow_class (MetaWindowActor *self)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-
-  if (priv->shadow_class != NULL)
-    return priv->shadow_class;
-  else
-    {
-      MetaWindowType window_type = meta_window_get_window_type (priv->window);
-
-      switch (window_type)
-        {
-        case META_WINDOW_DROPDOWN_MENU:
-        case META_WINDOW_COMBO:
-          return "dropdown-menu";
-        case META_WINDOW_POPUP_MENU:
-          return "popup-menu";
-        default:
-          {
-            MetaFrameType frame_type = meta_window_get_frame_type (priv->window);
-            return meta_frame_type_to_string (frame_type);
-          }
-        }
-    }
-}
-
-static void
-meta_window_actor_get_shadow_params (MetaWindowActor  *self,
-                                     gboolean          appears_focused,
-                                     MetaShadowParams *params)
-{
-  const char *shadow_class = meta_window_actor_get_shadow_class (self);
-
-  meta_shadow_factory_get_params (meta_shadow_factory_get_default (),
-                                  shadow_class, appears_focused,
-                                  params);
-}
-
-void
-meta_window_actor_get_shape_bounds (MetaWindowActor       *self,
-                                    cairo_rectangle_int_t *bounds)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-
-  cairo_region_get_extents (priv->shape_region, bounds);
-}
-
-static void
-meta_window_actor_get_shadow_bounds (MetaWindowActor       *self,
-                                     gboolean               appears_focused,
-                                     cairo_rectangle_int_t *bounds)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-  MetaShadow *shadow;
-  cairo_rectangle_int_t shape_bounds;
-  MetaShadowParams params;
-
-  shadow = appears_focused ? priv->focused_shadow : priv->unfocused_shadow;
-
-  meta_window_actor_get_shape_bounds (self, &shape_bounds);
-  meta_window_actor_get_shadow_params (self, appears_focused, &params);
-
-  meta_shadow_get_bounds (shadow,
-                          params.x_offset + shape_bounds.x,
-                          params.y_offset + shape_bounds.y,
-                          shape_bounds.width,
-                          shape_bounds.height,
-                          bounds);
-}
-
-/* If we have an ARGB32 window that we decorate with a frame, it's
- * probably something like a translucent terminal - something where
- * the alpha channel represents transparency rather than a shape.  We
- * don't want to show the shadow through the translucent areas since
- * the shadow is wrong for translucent windows (it should be
- * translucent itself and colored), and not only that, will /look/
- * horribly wrong - a misplaced big black blob. As a hack, what we
- * want to do is just draw the shadow as normal outside the frame, and
- * inside the frame draw no shadow.  This is also not even close to
- * the right result, but looks OK. We also apply this approach to
- * windows set to be partially translucent with _NET_WM_WINDOW_OPACITY.
- */
-static gboolean
-clip_shadow_under_window (MetaWindowActor *self)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-
-  if (priv->window->frame)
-    return TRUE;
-
-  return is_opaque (self);
-}
-
-static void
-meta_window_actor_paint (ClutterActor *actor)
-{
-  MetaWindowActor *self = META_WINDOW_ACTOR (actor);
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-  gboolean appears_focused = meta_window_appears_focused (priv->window);
-  MetaShadow *shadow;
-  CoglFramebuffer *framebuffer = cogl_get_draw_framebuffer ();
-
-  shadow = appears_focused ? priv->focused_shadow : priv->unfocused_shadow;
-
-  if (shadow != NULL)
-    {
-      MetaShadowParams params;
-      cairo_rectangle_int_t shape_bounds;
-      cairo_region_t *clip = priv->shadow_clip;
-      MetaWindow *window = priv->window;
-
-      meta_window_actor_get_shape_bounds (self, &shape_bounds);
-      meta_window_actor_get_shadow_params (self, appears_focused, &params);
-
-      /* The frame bounds are already subtracted from priv->shadow_clip
-       * if that exists.
-       */
-      if (!clip && clip_shadow_under_window (self))
-        {
-          cairo_region_t *frame_bounds = meta_window_get_frame_bounds (priv->window);
-          cairo_rectangle_int_t bounds;
-
-          meta_window_actor_get_shadow_bounds (self, appears_focused, &bounds);
-          clip = cairo_region_create_rectangle (&bounds);
-
-          if (frame_bounds)
-            cairo_region_subtract (clip, frame_bounds);
-        }
-
-      meta_shadow_paint (shadow,
-                         framebuffer,
-                         params.x_offset + shape_bounds.x,
-                         params.y_offset + shape_bounds.y,
-                         shape_bounds.width,
-                         shape_bounds.height,
-                         (clutter_actor_get_paint_opacity (actor) * params.opacity * window->opacity) / (255 * 255),
-                         clip,
-                         clip_shadow_under_window (self)); /* clip_strictly - not just as an optimization */
-
-      if (clip && clip != priv->shadow_clip)
-        cairo_region_destroy (clip);
-    }
-
-  CLUTTER_ACTOR_CLASS (meta_window_actor_parent_class)->paint (actor);
-}
-
-static gboolean
-meta_window_actor_get_paint_volume (ClutterActor       *actor,
-                                    ClutterPaintVolume *volume)
-{
-  MetaWindowActor *self = META_WINDOW_ACTOR (actor);
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-  gboolean appears_focused = meta_window_appears_focused (priv->window);
-
-  /* The paint volume is computed before paint functions are called
-   * so our bounds might not be updated yet. Force an update. */
-  meta_window_actor_handle_updates (self);
-
-  if (appears_focused ? priv->focused_shadow : priv->unfocused_shadow)
-    {
-      cairo_rectangle_int_t shadow_bounds;
-      ClutterActorBox shadow_box;
-
-      /* We could compute an full clip region as we do for the window
-       * texture, but the shadow is relatively cheap to draw, and
-       * a little more complex to clip, so we just catch the case where
-       * the shadow is completely obscured and doesn't need to be drawn
-       * at all.
-       */
-
-      meta_window_actor_get_shadow_bounds (self, appears_focused, &shadow_bounds);
-      shadow_box.x1 = shadow_bounds.x;
-      shadow_box.x2 = shadow_bounds.x + shadow_bounds.width;
-      shadow_box.y1 = shadow_bounds.y;
-      shadow_box.y2 = shadow_bounds.y + shadow_bounds.height;
-
-      clutter_paint_volume_union_box (volume, &shadow_box);
-    }
-
-  if (priv->surface)
-    {
-      const ClutterPaintVolume *child_volume;
-
-      child_volume = clutter_actor_get_transformed_paint_volume (CLUTTER_ACTOR (priv->surface), actor);
-      if (!child_volume)
-        return FALSE;
-
-      clutter_paint_volume_union (volume, child_volume);
-    }
-
-  return TRUE;
-}
-
-static gboolean
-meta_window_actor_has_shadow (MetaWindowActor *self)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-
-  if (priv->shadow_mode == META_SHADOW_MODE_FORCED_OFF)
-    return FALSE;
-  if (priv->shadow_mode == META_SHADOW_MODE_FORCED_ON)
-    return TRUE;
-
-  /* Leaving out shadows for maximized and fullscreen windows is an effeciency
-   * win and also prevents the unsightly effect of the shadow of maximized
-   * window appearing on an adjacent window */
-  if ((meta_window_get_maximized (priv->window) == META_MAXIMIZE_BOTH) ||
-      meta_window_is_fullscreen (priv->window))
-    return FALSE;
-
-  /*
-   * If we have two snap-tiled windows, we don't want the shadow to obstruct
-   * the other window.
-   */
-  if (meta_window_get_tile_match (priv->window))
-    return FALSE;
-
-  /*
-   * Always put a shadow around windows with a frame - This should override
-   * the restriction about not putting a shadow around ARGB windows.
-   */
-  if (meta_window_get_frame (priv->window))
-    return TRUE;
-
-  /*
-   * Do not add shadows to non-opaque (ARGB32) windows, as we can't easily
-   * generate shadows for them.
-   */
-  if (!is_opaque (self))
-    return FALSE;
-
-  /*
-   * If a window specifies that it has custom frame extents, that likely
-   * means that it is drawing a shadow itself. Don't draw our own.
-   */
-  if (priv->window->has_custom_frame_extents)
-    return FALSE;
-
-  /*
-   * OpenJDK wrongly assumes that shaping a window implies no compositor
-   * shadows; make its compliance tests happy to give it what it wants ...
-   */
-  if (g_strcmp0 (priv->window->res_name, "sun-awt-X11-XWindowPeer") == 0 &&
-      priv->window->shape_region != NULL)
-    return FALSE;
-
-  /*
-   * Generate shadows for all other windows.
-   */
-  return TRUE;
-}
-
 /**
  * meta_window_actor_get_meta_window:
  * @self: a #MetaWindowActor
@@ -1099,29 +708,6 @@ meta_window_actor_effect_completed (MetaWindowActor  *self,
     meta_window_actor_after_effects (self);
 }
 
-gboolean
-meta_window_actor_should_unredirect (MetaWindowActor *self)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-
-  if (!meta_window_actor_is_destroyed (self) && priv->surface)
-    return meta_surface_actor_should_unredirect (priv->surface);
-  else
-    return FALSE;
-}
-
-void
-meta_window_actor_set_unredirected (MetaWindowActor *self,
-                                    gboolean         unredirected)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-
-  g_assert (priv->surface); /* because otherwise should_unredirect() is FALSE */
-  meta_surface_actor_set_unredirected (priv->surface, unredirected);
-}
-
 void
 meta_window_actor_queue_destroy (MetaWindowActor *self)
 {
@@ -1180,7 +766,7 @@ meta_window_actor_sync_actor_geometry (MetaWindowActor *self,
    * is shown, the map effect will go into effect and prevent further geometry
    * updates.
    */
-  if (is_frozen (self) && !did_placement)
+  if (meta_window_actor_is_frozen (self) && !did_placement)
     return META_WINDOW_ACTOR_CHANGE_POSITION | META_WINDOW_ACTOR_CHANGE_SIZE;
 
   if (meta_window_actor_effect_in_progress (self))
@@ -1357,45 +943,6 @@ see_region (cairo_region_t *region,
 }
 #endif
 
-/**
- * meta_window_actor_set_clip_region_beneath:
- * @self: a #MetaWindowActor
- * @clip_region: the region of the screen that isn't completely
- *  obscured beneath the main window texture.
- *
- * Provides a hint as to what areas need to be drawn *beneath*
- * the main window texture.  This is the relevant clip region
- * when drawing the shadow, properly accounting for areas of the
- * shadow hid by the window itself. This will be set before painting
- * then unset afterwards.
- */
-static void
-meta_window_actor_set_clip_region_beneath (MetaWindowActor *self,
-                                           cairo_region_t  *beneath_region)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-  gboolean appears_focused = meta_window_appears_focused (priv->window);
-
-  if (appears_focused ? priv->focused_shadow : priv->unfocused_shadow)
-    {
-      g_clear_pointer (&priv->shadow_clip, cairo_region_destroy);
-
-      if (beneath_region)
-        {
-          priv->shadow_clip = cairo_region_copy (beneath_region);
-
-          if (clip_shadow_under_window (self))
-            {
-              cairo_region_t *frame_bounds = meta_window_get_frame_bounds (priv->window);
-              if (frame_bounds)
-                cairo_region_subtract (priv->shadow_clip, frame_bounds);
-            }
-        }
-      else
-        priv->shadow_clip = NULL;
-    }
-}
 
 static void
 meta_window_actor_cull_out (MetaCullable   *cullable,
@@ -1407,9 +954,8 @@ meta_window_actor_cull_out (MetaCullable   *cullable,
     meta_window_actor_get_instance_private (self);
 
   meta_cullable_cull_out_children (cullable, unobscured_region, clip_region);
-  meta_window_actor_set_clip_region_beneath (self, clip_region);
 
-  if (unobscured_region && is_opaque (self))
+  if (unobscured_region && meta_window_actor_is_opaque (self))
     {
       cairo_region_t *region = meta_window_get_frame_bounds (priv->window);
 
@@ -1430,12 +976,6 @@ meta_window_actor_cull_out (MetaCullable   *cullable,
 static void
 meta_window_actor_reset_culling (MetaCullable *cullable)
 {
-  MetaWindowActor *self = META_WINDOW_ACTOR (cullable);
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-
-  g_clear_pointer (&priv->shadow_clip, cairo_region_destroy);
-
   meta_cullable_reset_culling_children (cullable);
 }
 
@@ -1446,86 +986,6 @@ cullable_iface_init (MetaCullableInterface *iface)
   iface->reset_culling = meta_window_actor_reset_culling;
 }
 
-static void
-check_needs_shadow (MetaWindowActor *self)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-  MetaShadow *old_shadow = NULL;
-  MetaShadow **shadow_location;
-  gboolean recompute_shadow;
-  gboolean should_have_shadow;
-  gboolean appears_focused;
-
-  /* Calling meta_window_actor_has_shadow() here at every pre-paint is cheap
-   * and avoids the need to explicitly handle window type changes, which
-   * we would do if tried to keep track of when we might be adding or removing
-   * a shadow more explicitly. We only keep track of changes to the *shape* of
-   * the shadow with priv->recompute_shadow.
-   */
-
-  should_have_shadow = meta_window_actor_has_shadow (self);
-  appears_focused = meta_window_appears_focused (priv->window);
-
-  if (appears_focused)
-    {
-      recompute_shadow = priv->recompute_focused_shadow;
-      priv->recompute_focused_shadow = FALSE;
-      shadow_location = &priv->focused_shadow;
-    }
-  else
-    {
-      recompute_shadow = priv->recompute_unfocused_shadow;
-      priv->recompute_unfocused_shadow = FALSE;
-      shadow_location = &priv->unfocused_shadow;
-    }
-
-  if (!should_have_shadow || recompute_shadow)
-    {
-      if (*shadow_location != NULL)
-        {
-          old_shadow = *shadow_location;
-          *shadow_location = NULL;
-        }
-    }
-
-  if (*shadow_location == NULL && should_have_shadow)
-    {
-      if (priv->shadow_shape == NULL)
-        priv->shadow_shape = meta_window_shape_new (priv->shape_region);
-
-      MetaShadowFactory *factory = meta_shadow_factory_get_default ();
-      const char *shadow_class = meta_window_actor_get_shadow_class (self);
-      cairo_rectangle_int_t shape_bounds;
-
-      meta_window_actor_get_shape_bounds (self, &shape_bounds);
-      *shadow_location = meta_shadow_factory_get_shadow (factory,
-                                                         priv->shadow_shape,
-                                                         shape_bounds.width, shape_bounds.height,
-                                                         shadow_class, appears_focused);
-    }
-
-  if (old_shadow != NULL)
-    meta_shadow_unref (old_shadow);
-}
-
-void
-meta_window_actor_process_x11_damage (MetaWindowActor    *self,
-                                      XDamageNotifyEvent *event)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-
-  if (priv->surface)
-    meta_surface_actor_process_damage (priv->surface,
-                                       event->area.x,
-                                       event->area.y,
-                                       event->area.width,
-                                       event->area.height);
-
-  meta_window_actor_notify_damaged (self);
-}
-
 void
 meta_window_actor_sync_visibility (MetaWindowActor *self)
 {
@@ -1541,295 +1001,12 @@ meta_window_actor_sync_visibility (MetaWindowActor *self)
     }
 }
 
-static cairo_region_t *
-scan_visible_region (guchar         *mask_data,
-                     int             stride,
-                     cairo_region_t *scan_area)
-{
-  int i, n_rects = cairo_region_num_rectangles (scan_area);
-  MetaRegionBuilder builder;
-
-  meta_region_builder_init (&builder);
-
-  for (i = 0; i < n_rects; i++)
-    {
-      int x, y;
-      cairo_rectangle_int_t rect;
-
-      cairo_region_get_rectangle (scan_area, i, &rect);
-
-      for (y = rect.y; y < (rect.y + rect.height); y++)
-        {
-          for (x = rect.x; x < (rect.x + rect.width); x++)
-            {
-              int x2 = x;
-              while (mask_data[y * stride + x2] == 255 && x2 < (rect.x + rect.width))
-                x2++;
-
-              if (x2 > x)
-                {
-                  meta_region_builder_add_rectangle (&builder, x, y, x2 - x, 1);
-                  x = x2;
-                }
-            }
-        }
-    }
-
-  return meta_region_builder_finish (&builder);
-}
-
-static void
-build_and_scan_frame_mask (MetaWindowActor       *self,
-                           cairo_rectangle_int_t *client_area,
-                           cairo_region_t        *shape_region)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-  ClutterBackend *backend = clutter_get_default_backend ();
-  CoglContext *ctx = clutter_backend_get_cogl_context (backend);
-  guchar *mask_data;
-  guint tex_width, tex_height;
-  MetaShapedTexture *stex;
-  CoglTexture *paint_tex, *mask_texture;
-  int stride;
-  cairo_t *cr;
-  cairo_surface_t *surface;
-  GError *error = NULL;
-
-  stex = meta_surface_actor_get_texture (priv->surface);
-  g_return_if_fail (stex);
-
-  meta_shaped_texture_set_mask_texture (stex, NULL);
-
-  paint_tex = meta_shaped_texture_get_texture (stex);
-  if (paint_tex == NULL)
-    return;
-
-  tex_width = cogl_texture_get_width (paint_tex);
-  tex_height = cogl_texture_get_height (paint_tex);
-
-  stride = cairo_format_stride_for_width (CAIRO_FORMAT_A8, tex_width);
-
-  /* Create data for an empty image */
-  mask_data = g_malloc0 (stride * tex_height);
-
-  surface = cairo_image_surface_create_for_data (mask_data,
-                                                 CAIRO_FORMAT_A8,
-                                                 tex_width,
-                                                 tex_height,
-                                                 stride);
-  cr = cairo_create (surface);
-
-  gdk_cairo_region (cr, shape_region);
-  cairo_fill (cr);
-
-  if (priv->window->frame != NULL)
-    {
-      cairo_region_t *frame_paint_region, *scanned_region;
-      cairo_rectangle_int_t rect = { 0, 0, tex_width, tex_height };
-
-      /* Make sure we don't paint the frame over the client window. */
-      frame_paint_region = cairo_region_create_rectangle (&rect);
-      cairo_region_subtract_rectangle (frame_paint_region, client_area);
-
-      gdk_cairo_region (cr, frame_paint_region);
-      cairo_clip (cr);
-
-      meta_frame_get_mask (priv->window->frame, cr);
-
-      cairo_surface_flush (surface);
-      scanned_region = scan_visible_region (mask_data, stride, frame_paint_region);
-      cairo_region_union (shape_region, scanned_region);
-      cairo_region_destroy (scanned_region);
-      cairo_region_destroy (frame_paint_region);
-    }
-
-  cairo_destroy (cr);
-  cairo_surface_destroy (surface);
-
-  mask_texture = COGL_TEXTURE (cogl_texture_2d_new_from_data (ctx, tex_width, tex_height,
-                                                              COGL_PIXEL_FORMAT_A_8,
-                                                              stride, mask_data, &error));
-
-  if (error)
-    {
-      g_warning ("Failed to allocate mask texture: %s", error->message);
-      g_error_free (error);
-    }
-
-  meta_shaped_texture_set_mask_texture (stex, mask_texture);
-  if (mask_texture)
-    cogl_object_unref (mask_texture);
-
-  g_free (mask_data);
-}
-
-static void
-meta_window_actor_update_shape_region (MetaWindowActor *self)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-  cairo_region_t *region = NULL;
-  cairo_rectangle_int_t client_area;
-
-  meta_window_get_client_area_rect (priv->window, &client_area);
-
-  if (priv->window->frame != NULL && priv->window->shape_region != NULL)
-    {
-      region = cairo_region_copy (priv->window->shape_region);
-      cairo_region_translate (region, client_area.x, client_area.y);
-    }
-  else if (priv->window->shape_region != NULL)
-    {
-      region = cairo_region_reference (priv->window->shape_region);
-    }
-  else
-    {
-      /* If we don't have a shape on the server, that means that
-       * we have an implicit shape of one rectangle covering the
-       * entire window. */
-      region = cairo_region_create_rectangle (&client_area);
-    }
-
-  if ((priv->window->shape_region != NULL) || (priv->window->frame != NULL))
-    build_and_scan_frame_mask (self, &client_area, region);
-
-  g_clear_pointer (&priv->shape_region, cairo_region_destroy);
-  priv->shape_region = region;
-
-  g_clear_pointer (&priv->shadow_shape, meta_window_shape_unref);
-
-  meta_window_actor_invalidate_shadow (self);
-}
-
-static void
-meta_window_actor_update_input_region (MetaWindowActor *self)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-  MetaWindow *window = priv->window;
-  cairo_region_t *region;
-
-  if (window->shape_region && window->input_region)
-    {
-      region = cairo_region_copy (window->shape_region);
-      cairo_region_intersect (region, window->input_region);
-    }
-  else if (window->shape_region)
-    region = cairo_region_reference (window->shape_region);
-  else if (window->input_region)
-    region = cairo_region_reference (window->input_region);
-  else
-    region = NULL;
-
-  meta_surface_actor_set_input_region (priv->surface, region);
-  cairo_region_destroy (region);
-}
-
-static void
-meta_window_actor_update_opaque_region (MetaWindowActor *self)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-  cairo_region_t *opaque_region;
-  gboolean argb32 = is_argb32 (self);
-
-  if (argb32 && priv->window->opaque_region != NULL)
-    {
-      cairo_rectangle_int_t client_area;
-
-      meta_window_get_client_area_rect (priv->window, &client_area);
-
-      /* The opaque region is defined to be a part of the
-       * window which ARGB32 will always paint with opaque
-       * pixels. For these regions, we want to avoid painting
-       * windows and shadows beneath them.
-       *
-       * If the client gives bad coordinates where it does not
-       * fully paint, the behavior is defined by the specification
-       * to be undefined, and considered a client bug. In mutter's
-       * case, graphical glitches will occur.
-       */
-      opaque_region = cairo_region_copy (priv->window->opaque_region);
-      cairo_region_translate (opaque_region, client_area.x, client_area.y);
-      cairo_region_intersect (opaque_region, priv->shape_region);
-    }
-  else if (argb32)
-    opaque_region = NULL;
-  else
-    opaque_region = cairo_region_reference (priv->shape_region);
-
-  meta_surface_actor_set_opaque_region (priv->surface, opaque_region);
-  cairo_region_destroy (opaque_region);
-}
-
-static void
-check_needs_reshape (MetaWindowActor *self)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-
-  if (!priv->needs_reshape)
-    return;
-
-  meta_window_actor_update_shape_region (self);
-
-  if (priv->window->client_type == META_WINDOW_CLIENT_TYPE_X11)
-    {
-      meta_window_actor_update_input_region (self);
-      meta_window_actor_update_opaque_region (self);
-    }
-
-  priv->needs_reshape = FALSE;
-}
-
-void
-meta_window_actor_update_shape (MetaWindowActor *self)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-
-  priv->needs_reshape = TRUE;
-
-  if (is_frozen (self))
-    return;
-
-  clutter_actor_queue_redraw (CLUTTER_ACTOR (priv->surface));
-}
-
-static void
-meta_window_actor_handle_updates (MetaWindowActor *self)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-
-  if (is_frozen (self))
-    {
-      /* The window is frozen due to a pending animation: we'll wait until
-       * the animation finishes to reshape and repair the window */
-      return;
-    }
-
-  if (meta_surface_actor_is_unredirected (priv->surface))
-    return;
-
-  meta_surface_actor_pre_paint (priv->surface);
-
-  if (!meta_surface_actor_is_visible (priv->surface))
-    return;
-
-  check_needs_reshape (self);
-  check_needs_shadow (self);
-}
-
 void
 meta_window_actor_pre_paint (MetaWindowActor *self)
 {
   if (meta_window_actor_is_destroyed (self))
     return;
 
-  meta_window_actor_handle_updates (self);
-
   META_WINDOW_ACTOR_GET_CLASS (self)->pre_paint (self);
 }
 
@@ -1861,21 +1038,6 @@ meta_window_actor_frame_complete (MetaWindowActor  *self,
                                                       presentation_time);
 }
 
-void
-meta_window_actor_invalidate_shadow (MetaWindowActor *self)
-{
-  MetaWindowActorPrivate *priv =
-    meta_window_actor_get_instance_private (self);
-
-  priv->recompute_focused_shadow = TRUE;
-  priv->recompute_unfocused_shadow = TRUE;
-
-  if (is_frozen (self))
-    return;
-
-  clutter_actor_queue_redraw (CLUTTER_ACTOR (self));
-}
-
 void
 meta_window_actor_update_opacity (MetaWindowActor *self)
 {
diff --git a/src/core/display.c b/src/core/display.c
index 2ddcbbc1f38f3a7541cf0818987a404cb3e029d9..7d1ec3f57c9f4c9ba6595313c5d33ecdf1722f3f 100644
--- a/src/core/display.c
+++ b/src/core/display.c
@@ -49,6 +49,7 @@
 #include "backends/x11/meta-backend-x11.h"
 #include "backends/x11/meta-event-x11.h"
 #include "backends/x11/cm/meta-backend-x11-cm.h"
+#include "backends/x11/nested/meta-backend-x11-nested.h"
 #include "clutter/x11/clutter-x11.h"
 #include "compositor/compositor-private.h"
 #include "compositor/meta-compositor-x11.h"
@@ -79,6 +80,7 @@
 #include "x11/xprops.h"
 
 #ifdef HAVE_WAYLAND
+#include "compositor/meta-compositor-native.h"
 #include "compositor/meta-compositor-server.h"
 #include "wayland/meta-xwayland-private.h"
 #include "wayland/meta-wayland-tablet-seat.h"
@@ -555,11 +557,16 @@ static MetaCompositor *
 create_compositor (MetaDisplay *display)
 {
 #ifdef HAVE_WAYLAND
-  if (meta_is_wayland_compositor ())
+  MetaBackend *backend = meta_get_backend ();
+
+#ifdef HAVE_NATIVE_BACKEND
+  if (META_IS_BACKEND_NATIVE (backend))
+    return META_COMPOSITOR (meta_compositor_native_new (display));
+#endif
+  if (META_IS_BACKEND_X11_NESTED (backend))
     return META_COMPOSITOR (meta_compositor_server_new (display));
-  else
 #endif
-    return META_COMPOSITOR (meta_compositor_x11_new (display));
+  return META_COMPOSITOR (meta_compositor_x11_new (display));
 }
 
 static void
diff --git a/src/core/window-private.h b/src/core/window-private.h
index dd89fdc90964d3ec27ecad04da067ed3d58e74eb..1e0e358e990dd82cc9f2dd8a40cb3e31e553214b 100644
--- a/src/core/window-private.h
+++ b/src/core/window-private.h
@@ -65,13 +65,6 @@ typedef enum
 
 #define NUMBER_OF_QUEUES 3
 
-typedef enum
-{
-  _NET_WM_BYPASS_COMPOSITOR_HINT_AUTO = 0,
-  _NET_WM_BYPASS_COMPOSITOR_HINT_ON = 1,
-  _NET_WM_BYPASS_COMPOSITOR_HINT_OFF = 2,
-} MetaBypassCompositorHintValue;
-
 typedef enum
 {
   META_MOVE_RESIZE_CONFIGURE_REQUEST = 1 << 0,
@@ -531,9 +524,6 @@ struct _MetaWindow
   /* The currently complementary tiled window, if any */
   MetaWindow *tile_match;
 
-  /* Bypass compositor hints */
-  guint bypass_compositor;
-
   MetaPlacementRule *placement_rule;
   MetaPlacementState placement_state;
   int constrained_placement_rule_offset_x;
diff --git a/src/core/window.c b/src/core/window.c
index e276b1e5972d176ad79a2915d464f72fa25d8f57..a645532fdf5a62580c78e71e6d1552ed21c4351b 100644
--- a/src/core/window.c
+++ b/src/core/window.c
@@ -3003,6 +3003,21 @@ meta_window_is_screen_sized (MetaWindow *window)
   return FALSE;
 }
 
+gboolean
+meta_window_is_logical_monitor_sized (MetaWindow *window)
+{
+  MetaRectangle window_rect;
+  MetaRectangle logical_monitor_rect;
+
+  if (!window->monitor)
+    return FALSE;
+
+  meta_window_get_frame_rect (window, &window_rect);
+  logical_monitor_rect = meta_logical_monitor_get_layout (window->monitor);
+
+  return meta_rectangle_equal (&window_rect, &logical_monitor_rect);
+}
+
 /**
  * meta_window_is_monitor_sized:
  * @window: a #MetaWindow
@@ -3050,30 +3065,6 @@ meta_window_is_on_primary_monitor (MetaWindow *window)
   return window->monitor->is_primary;
 }
 
-/**
- * meta_window_requested_bypass_compositor:
- * @window: a #MetaWindow
- *
- * Return value: %TRUE if the window requested to bypass the compositor
- */
-gboolean
-meta_window_requested_bypass_compositor (MetaWindow *window)
-{
-  return window->bypass_compositor == _NET_WM_BYPASS_COMPOSITOR_HINT_ON;
-}
-
-/**
- * meta_window_requested_dont_bypass_compositor:
- * @window: a #MetaWindow
- *
- * Return value: %TRUE if the window requested to opt out of unredirecting
- */
-gboolean
-meta_window_requested_dont_bypass_compositor (MetaWindow *window)
-{
-  return window->bypass_compositor == _NET_WM_BYPASS_COMPOSITOR_HINT_OFF;
-}
-
 static void
 meta_window_get_tile_fraction (MetaWindow   *window,
                                MetaTileMode  tile_mode,
diff --git a/src/meson.build b/src/meson.build
index 182f7f5f530a1e1eeb262c243ace0b86f347e251..d1f60b1ad5e89e4eda7d079cb68ae33be237a655 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -290,6 +290,8 @@ mutter_sources = [
   'compositor/meta-background-group.c',
   'compositor/meta-background-image.c',
   'compositor/meta-background-private.h',
+  'compositor/meta-compositor-server.c',
+  'compositor/meta-compositor-server.h',
   'compositor/meta-compositor-x11.c',
   'compositor/meta-compositor-x11.h',
   'compositor/meta-cullable.c',
@@ -475,10 +477,8 @@ if have_wayland
   mutter_sources += [
     'compositor/meta-surface-actor-wayland.c',
     'compositor/meta-surface-actor-wayland.h',
     'compositor/meta-window-actor-wayland.c',
     'compositor/meta-window-actor-wayland.h',
-    'compositor/meta-compositor-server.c',
-    'compositor/meta-compositor-server.h',
     'wayland/meta-cursor-sprite-wayland.c',
     'wayland/meta-cursor-sprite-wayland.h',
     'wayland/meta-pointer-confinement-wayland.c',
@@ -669,6 +669,8 @@ if have_native_backend
     'backends/native/meta-virtual-input-device-native.h',
     'backends/native/meta-xkb-utils.c',
     'backends/native/meta-xkb-utils.h',
+    'compositor/meta-compositor-native.c',
+    'compositor/meta-compositor-native.h',
   ]
 endif
 
diff --git a/src/meta/window.h b/src/meta/window.h
index 6261fffbb4e252aa72a8742b4338b220541ef35e..706fde15f50e906284fc46de883cf59c22ce7393 100644
--- a/src/meta/window.h
+++ b/src/meta/window.h
@@ -99,6 +99,8 @@ typedef enum
 #define META_IS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  META_TYPE_WINDOW))
 #define META_WINDOW_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  META_TYPE_WINDOW, MetaWindowClass))
 
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (MetaWindow, g_object_unref)
+
 typedef struct _MetaWindowClass   MetaWindowClass;
 
 META_EXPORT
@@ -279,13 +281,10 @@ META_EXPORT
 gboolean          meta_window_is_monitor_sized (MetaWindow *window);
 
 META_EXPORT
-gboolean          meta_window_is_on_primary_monitor (MetaWindow *window);
+gboolean          meta_window_is_logical_monitor_sized (MetaWindow *window);
 
 META_EXPORT
-gboolean          meta_window_requested_bypass_compositor (MetaWindow *window);
-
-META_EXPORT
-gboolean          meta_window_requested_dont_bypass_compositor (MetaWindow *window);
+gboolean          meta_window_is_on_primary_monitor (MetaWindow *window);
 
 META_EXPORT
 gboolean meta_window_get_icon_geometry (MetaWindow    *window,
diff --git a/src/ui/frames.c b/src/ui/frames.c
index 33dfaa0711a5ba73dadb4b4b3d25dac1aff0f69f..4db41efa253c1b947f74f5b0608e58c8c21b8309 100644
--- a/src/ui/frames.c
+++ b/src/ui/frames.c
@@ -409,7 +409,7 @@ meta_ui_frame_calc_geometry (MetaUIFrame       *frame,
   MetaFrameType type;
   MetaButtonLayout button_layout;
   MetaWindowX11 *window_x11 = META_WINDOW_X11 (frame->meta_window);
-  MetaWindowX11Private *priv = window_x11->priv;
+  MetaRectangle client_rect;
 
   flags = meta_frame_get_flags (frame->meta_window->frame);
   type = meta_window_get_frame_type (frame->meta_window);
@@ -418,13 +418,15 @@ meta_ui_frame_calc_geometry (MetaUIFrame       *frame,
 
   meta_prefs_get_button_layout (&button_layout);
 
+  client_rect = meta_window_x11_get_client_rect (window_x11);
+
   meta_theme_calc_geometry (meta_theme_get_default (),
                             frame->style_info,
                             type,
                             frame->text_height,
                             flags,
-                            priv->client_rect.width,
-                            priv->client_rect.height,
+                            client_rect.width,
+                            client_rect.height,
                             &button_layout,
                             fgeom);
 }
@@ -1516,7 +1518,7 @@ meta_ui_frame_paint (MetaUIFrame  *frame,
   int button_type = -1;
   MetaButtonLayout button_layout;
   MetaWindowX11 *window_x11 = META_WINDOW_X11 (frame->meta_window);
-  MetaWindowX11Private *priv = window_x11->priv;
+  MetaRectangle client_rect;
 
   for (i = 0; i < META_BUTTON_TYPE_LAST; i++)
     button_states[i] = META_BUTTON_STATE_NORMAL;
@@ -1554,13 +1556,15 @@ meta_ui_frame_paint (MetaUIFrame  *frame,
 
   meta_prefs_get_button_layout (&button_layout);
 
+  client_rect = meta_window_x11_get_client_rect (window_x11);
+
   meta_theme_draw_frame (meta_theme_get_default (),
                          frame->style_info,
                          cr,
                          type,
                          flags,
-                         priv->client_rect.width,
-                         priv->client_rect.height,
+                         client_rect.width,
+                         client_rect.height,
                          frame->text_layout,
                          frame->text_height,
                          &button_layout,
diff --git a/src/wayland/meta-wayland-buffer.c b/src/wayland/meta-wayland-buffer.c
index cdaad26eba77d7b962bb0e29228614f9b22d2c7f..ea063b55645547bad18a431ce83bdd55b78d06c6 100644
--- a/src/wayland/meta-wayland-buffer.c
+++ b/src/wayland/meta-wayland-buffer.c
@@ -34,6 +34,11 @@
 #include "meta/util.h"
 #include "wayland/meta-wayland-dma-buf.h"
 
+#ifdef HAVE_NATIVE_BACKEND
+#include "backends/native/meta-drm-buffer-gbm.h"
+#include "backends/native/meta-renderer-native.h"
+#endif
+
 #ifndef DRM_FORMAT_MOD_INVALID
 #define DRM_FORMAT_MOD_INVALID ((1ULL << 56) - 1)
 #endif
@@ -551,6 +556,91 @@ meta_wayland_buffer_process_damage (MetaWaylandBuffer *buffer,
     }
 }
 
+static CoglScanout *
+try_acquire_egl_image_scanout (MetaWaylandBuffer *buffer,
+                               CoglOnscreen      *onscreen)
+{
+#ifdef HAVE_NATIVE_BACKEND
+  MetaBackend *backend = meta_get_backend ();
+  MetaRenderer *renderer = meta_backend_get_renderer (backend);
+  MetaRendererNative *renderer_native = META_RENDERER_NATIVE (renderer);
+  MetaGpuKms *gpu_kms;
+  struct gbm_device *gbm_device;
+  struct gbm_bo *gbm_bo;
+  uint32_t drm_format;
+  uint64_t drm_modifier;
+  MetaDrmBufferGbm *fb;
+  GError *error = NULL;
+
+  gpu_kms = meta_renderer_native_get_primary_gpu (renderer_native);
+  gbm_device = meta_gbm_device_from_gpu (gpu_kms);
+
+  gbm_bo = gbm_bo_import (gbm_device,
+                          GBM_BO_IMPORT_WL_BUFFER, buffer->resource,
+                          GBM_BO_USE_SCANOUT);
+  if (!gbm_bo)
+    return NULL;
+
+  drm_format = gbm_bo_get_format (gbm_bo);
+  drm_modifier = gbm_bo_get_modifier (gbm_bo);
+  if (!meta_onscreen_native_is_format_scanout_compatible (onscreen,
+                                                          drm_format,
+                                                          drm_modifier))
+    {
+      gbm_bo_destroy (gbm_bo);
+      return NULL;
+    }
+
+  fb = meta_drm_buffer_gbm_new_take (gpu_kms, gbm_bo,
+                                     drm_modifier != DRM_FORMAT_MOD_INVALID,
+                                     &error);
+  if (!fb)
+    {
+      g_debug ("Failed to create scanout buffer: %s", error->message);
+      g_error_free (error);
+      gbm_bo_destroy (gbm_bo);
+      return NULL;
+    }
+
+  return COGL_SCANOUT (fb);
+#else
+  return NULL;
+#endif
+}
+
+CoglScanout *
+meta_wayland_buffer_try_acquire_scanout (MetaWaylandBuffer *buffer,
+                                         CoglOnscreen      *onscreen)
+{
+  switch (buffer->type)
+    {
+    case META_WAYLAND_BUFFER_TYPE_SHM:
+      return NULL;
+    case META_WAYLAND_BUFFER_TYPE_EGL_IMAGE:
+      return try_acquire_egl_image_scanout (buffer, onscreen);
+#ifdef HAVE_WAYLAND_EGLSTREAM
+    case META_WAYLAND_BUFFER_TYPE_EGL_STREAM:
+      return NULL;
+#endif
+    case META_WAYLAND_BUFFER_TYPE_DMA_BUF:
+      {
+        MetaWaylandDmaBufBuffer *dma_buf;
+
+        dma_buf = meta_wayland_dma_buf_from_buffer (buffer);
+        if (!dma_buf)
+          return NULL;
+
+        return meta_wayland_dma_buf_try_acquire_scanout (dma_buf, onscreen);
+      }
+    case META_WAYLAND_BUFFER_TYPE_UNKNOWN:
+      g_warn_if_reached ();
+      return NULL;
+    }
+
+  g_assert_not_reached ();
+  return NULL;
+}
+
 static void
 meta_wayland_buffer_finalize (GObject *object)
 {
diff --git a/src/wayland/meta-wayland-buffer.h b/src/wayland/meta-wayland-buffer.h
index 5d75a3451eaaa9d7fabb4dd46e146edd3c66cf9e..671783bf2c557d65825c75f72f6a5da9f24a3ae9 100644
--- a/src/wayland/meta-wayland-buffer.h
+++ b/src/wayland/meta-wayland-buffer.h
@@ -89,5 +89,7 @@ gboolean                meta_wayland_buffer_is_y_inverted       (MetaWaylandBuff
 void                    meta_wayland_buffer_process_damage      (MetaWaylandBuffer     *buffer,
                                                                  CoglTexture           *texture,
                                                                  cairo_region_t        *region);
+CoglScanout *           meta_wayland_buffer_try_acquire_scanout (MetaWaylandBuffer     *buffer,
+                                                                 CoglOnscreen          *onscreen);
 
 #endif /* META_WAYLAND_BUFFER_H */
diff --git a/src/wayland/meta-wayland-dma-buf.c b/src/wayland/meta-wayland-dma-buf.c
index e672749e4a7b72f88f139b6bcfeb737833afc764..c8a13941507919d9b9edea39d167b943c30c90bc 100644
--- a/src/wayland/meta-wayland-dma-buf.c
+++ b/src/wayland/meta-wayland-dma-buf.c
@@ -41,6 +41,11 @@
 #include "wayland/meta-wayland-private.h"
 #include "wayland/meta-wayland-versions.h"
 
+#ifdef HAVE_NATIVE_BACKEND
+#include "backends/native/meta-drm-buffer-gbm.h"
+#include "backends/native/meta-renderer-native.h"
+#endif
+
 #include "linux-dmabuf-unstable-v1-server-protocol.h"
 
 #ifndef DRM_FORMAT_MOD_INVALID
@@ -170,6 +175,114 @@ meta_wayland_dma_buf_buffer_attach (MetaWaylandBuffer  *buffer,
   return TRUE;
 }
 
+#ifdef HAVE_NATIVE_BACKEND
+static struct gbm_bo *
+create_gbm_bo (MetaWaylandDmaBufBuffer *dma_buf,
+               MetaGpuKms              *gpu_kms,
+               int                      n_planes,
+               gboolean                *use_modifier)
+{
+  struct gbm_device *gbm_device;
+
+  gbm_device = meta_gbm_device_from_gpu (gpu_kms);
+
+  if (dma_buf->drm_modifier != DRM_FORMAT_MOD_INVALID ||
+      n_planes > 1 ||
+      dma_buf->offsets[0] > 0)
+    {
+      struct gbm_import_fd_modifier_data import_with_modifier;
+
+      import_with_modifier = (struct gbm_import_fd_modifier_data) {
+        .width = dma_buf->width,
+        .height = dma_buf->height,
+        .format = dma_buf->drm_format,
+        .num_fds = n_planes,
+        .modifier = dma_buf->drm_modifier,
+      };
+      memcpy (import_with_modifier.fds,
+              dma_buf->fds,
+              sizeof (dma_buf->fds));
+      memcpy (import_with_modifier.strides,
+              dma_buf->strides,
+              sizeof (import_with_modifier.strides));
+      memcpy (import_with_modifier.offsets,
+              dma_buf->offsets,
+              sizeof (import_with_modifier.offsets));
+
+      *use_modifier = TRUE;
+      return gbm_bo_import (gbm_device, GBM_BO_IMPORT_FD_MODIFIER,
+                            &import_with_modifier,
+                            GBM_BO_USE_SCANOUT);
+    }
+  else
+    {
+      struct gbm_import_fd_data import_legacy;
+
+      import_legacy = (struct gbm_import_fd_data) {
+        .width = dma_buf->width,
+        .height = dma_buf->height,
+        .format = dma_buf->drm_format,
+        .stride = dma_buf->strides[0],
+        .fd = dma_buf->fds[0],
+      };
+
+      *use_modifier = FALSE;
+      return gbm_bo_import(gbm_device, GBM_BO_IMPORT_FD,
+                           &import_legacy,
+                           GBM_BO_USE_SCANOUT);
+    }
+}
+#endif
+
+CoglScanout *
+meta_wayland_dma_buf_try_acquire_scanout (MetaWaylandDmaBufBuffer *dma_buf,
+                                          CoglOnscreen            *onscreen)
+{
+#ifdef HAVE_NATIVE_BACKEND
+  MetaBackend *backend = meta_get_backend ();
+  MetaRenderer *renderer = meta_backend_get_renderer (backend);
+  MetaRendererNative *renderer_native = META_RENDERER_NATIVE (renderer);
+  MetaGpuKms *gpu_kms;
+  int n_planes;
+  uint32_t drm_format;
+  uint64_t drm_modifier;
+  struct gbm_bo *gbm_bo;
+  gboolean use_modifier;
+  g_autoptr (GError) error = NULL;
+  MetaDrmBufferGbm *fb;
+
+  for (n_planes = 0; n_planes < META_WAYLAND_DMA_BUF_MAX_FDS; n_planes++)
+    {
+      if (dma_buf->fds[n_planes] < 0)
+        break;
+    }
+
+  drm_format = dma_buf->drm_format;
+  drm_modifier = dma_buf->drm_modifier;
+  if (!meta_onscreen_native_is_format_scanout_compatible (onscreen,
+                                                          drm_format,
+                                                          drm_modifier))
+    return NULL;
+
+  gpu_kms = meta_renderer_native_get_primary_gpu (renderer_native);
+  gbm_bo = create_gbm_bo (dma_buf, gpu_kms, n_planes, &use_modifier);
+
+  fb = meta_drm_buffer_gbm_new_take (gpu_kms, gbm_bo,
+                                     use_modifier,
+                                     &error);
+  if (!fb)
+    {
+      g_debug ("Failed to create scanout buffer: %s", error->message);
+      gbm_bo_destroy (gbm_bo);
+      return NULL;
+    }
+
+  return COGL_SCANOUT (fb);
+#else
+  return NULL;
+#endif
+}
+
 static void
 buffer_params_add (struct wl_client   *client,
                    struct wl_resource *resource,
@@ -263,9 +376,12 @@ static const struct wl_buffer_interface dma_buf_buffer_impl =
 MetaWaylandDmaBufBuffer *
 meta_wayland_dma_buf_from_buffer (MetaWaylandBuffer *buffer)
 {
+  if (!buffer->resource)
+    return NULL;
+
   if (wl_resource_instance_of (buffer->resource, &wl_buffer_interface,
                                &dma_buf_buffer_impl))
-      return wl_resource_get_user_data (buffer->resource);
+    return wl_resource_get_user_data (buffer->resource);
 
   return NULL;
 }
@@ -435,6 +551,15 @@ static const struct zwp_linux_dmabuf_v1_interface dma_buf_implementation =
   dma_buf_handle_create_buffer_params,
 };
 
+static gboolean
+should_send_modifiers (MetaBackend *backend)
+{
+  MetaSettings *settings = meta_backend_get_settings (backend);
+
+  return meta_settings_is_experimental_feature_enabled (
+           settings, META_EXPERIMENTAL_FEATURE_KMS_MODIFIERS);
+}
+
 static void
 send_modifiers (struct wl_resource *resource,
                 uint32_t            format)
@@ -457,6 +582,14 @@ send_modifiers (struct wl_resource *resource,
   if (wl_resource_get_version (resource) < ZWP_LINUX_DMABUF_V1_MODIFIER_SINCE_VERSION)
     return;
 
+  if (!should_send_modifiers (backend))
+    {
+      zwp_linux_dmabuf_v1_send_modifier (resource, format,
+                                         DRM_FORMAT_MOD_INVALID >> 32,
+                                         DRM_FORMAT_MOD_INVALID & 0xffffffff);
+      return;
+    }
+
   /* First query the number of available modifiers, then allocate an array,
    * then fill the array. */
   ret = meta_egl_query_dma_buf_modifiers (egl, egl_display, format, 0, NULL,
diff --git a/src/wayland/meta-wayland-dma-buf.h b/src/wayland/meta-wayland-dma-buf.h
index 580a3e7774664888c9ee609c3c48928cff625569..568ce1512303cb7cefdfd37de0eca9a58469c93b 100644
--- a/src/wayland/meta-wayland-dma-buf.h
+++ b/src/wayland/meta-wayland-dma-buf.h
@@ -50,4 +50,8 @@ meta_wayland_dma_buf_buffer_attach (MetaWaylandBuffer  *buffer,
 MetaWaylandDmaBufBuffer *
 meta_wayland_dma_buf_from_buffer (MetaWaylandBuffer *buffer);
 
+CoglScanout *
+meta_wayland_dma_buf_try_acquire_scanout (MetaWaylandDmaBufBuffer *dma_buf,
+                                          CoglOnscreen            *onscreen);
+
 #endif /* META_WAYLAND_DMA_BUF_H */
diff --git a/src/wayland/meta-wayland-legacy-xdg-shell.c b/src/wayland/meta-wayland-legacy-xdg-shell.c
index 823064177033159f6c572914dbbd7527287a606a..ed8fb15e1301ded0e6d81fa966df741296ba2c82 100644
--- a/src/wayland/meta-wayland-legacy-xdg-shell.c
+++ b/src/wayland/meta-wayland-legacy-xdg-shell.c
@@ -989,7 +989,7 @@ meta_wayland_zxdg_popup_v6_commit (MetaWaylandSurfaceRole  *surface_role,
   if (!pending->newly_attached)
     return;
 
-  if (!surface->buffer_ref.buffer)
+  if (!surface->buffer_ref->buffer)
     return;
 
   window_geometry =
@@ -1348,7 +1348,7 @@ meta_wayland_zxdg_surface_v6_commit (MetaWaylandSurfaceRole  *surface_role,
   if (!priv->resource)
     return;
 
-  if (surface->buffer_ref.buffer == NULL && priv->first_buffer_attached)
+  if (!surface->buffer_ref->buffer && priv->first_buffer_attached)
     {
       /* XDG surfaces can't commit NULL buffers */
       wl_resource_post_error (surface->resource,
@@ -1357,7 +1357,7 @@ meta_wayland_zxdg_surface_v6_commit (MetaWaylandSurfaceRole  *surface_role,
       return;
     }
 
-  if (surface->buffer_ref.buffer && !priv->configure_sent)
+  if (surface->buffer_ref->buffer && !priv->configure_sent)
     {
       wl_resource_post_error (surface->resource,
                               ZXDG_SURFACE_V6_ERROR_UNCONFIGURED_BUFFER,
@@ -1368,7 +1368,7 @@ meta_wayland_zxdg_surface_v6_commit (MetaWaylandSurfaceRole  *surface_role,
   if (!window)
     return;
 
-  if (surface->buffer_ref.buffer)
+  if (surface->buffer_ref->buffer)
     priv->first_buffer_attached = TRUE;
   else
     return;
@@ -1413,7 +1413,7 @@ meta_wayland_zxdg_surface_v6_assigned (MetaWaylandSurfaceRole *surface_role)
   priv->configure_sent = FALSE;
   priv->first_buffer_attached = FALSE;
 
-  if (surface->buffer_ref.buffer)
+  if (surface->buffer_ref->buffer)
     {
       wl_resource_post_error (xdg_shell_resource,
                               ZXDG_SHELL_V6_ERROR_INVALID_SURFACE_STATE,
@@ -1957,7 +1957,7 @@ zxdg_shell_v6_get_xdg_surface (struct wl_client   *client,
       return;
     }
 
-  if (surface->buffer_ref.buffer)
+  if (surface->buffer_ref->buffer)
     {
       wl_resource_post_error (resource,
                               ZXDG_SHELL_V6_ERROR_INVALID_SURFACE_STATE,
diff --git a/src/wayland/meta-wayland-shell-surface.c b/src/wayland/meta-wayland-shell-surface.c
index 32b4d981ca54fe37a69c619e56f733f70a5a1ee1..cf9e3ed4fa7276acf6607d858b42e6d7f67c5cad 100644
--- a/src/wayland/meta-wayland-shell-surface.c
+++ b/src/wayland/meta-wayland-shell-surface.c
@@ -164,7 +164,7 @@ meta_wayland_shell_surface_surface_commit (MetaWaylandSurfaceRole  *surface_role
     META_WAYLAND_SURFACE_ROLE_CLASS (meta_wayland_shell_surface_parent_class);
   surface_role_class->commit (surface_role, pending);
 
-  buffer = surface->buffer_ref.buffer;
+  buffer = surface->buffer_ref->buffer;
   if (!buffer)
     return;
 
diff --git a/src/wayland/meta-wayland-subsurface.c b/src/wayland/meta-wayland-subsurface.c
index 8724da39feae8454c53d103f1bd60a1b41ea5420..dd42a8c1106afb026634cd59f279e63712e0fc03 100644
--- a/src/wayland/meta-wayland-subsurface.c
+++ b/src/wayland/meta-wayland-subsurface.c
@@ -86,7 +86,7 @@ sync_actor_subsurface_state (MetaWaylandSurface *surface)
 
   clutter_actor_set_position (actor, x, y);
 
-  if (surface->buffer_ref.buffer)
+  if (surface->buffer_ref->buffer)
     clutter_actor_show (actor);
   else
     clutter_actor_hide (actor);
diff a/src/wayland/meta-wayland-actor-surface.c b/src/wayland/meta-wayland-actor-surface.c
--- a/src/wayland/meta-wayland-actor-surface.c
+++ b/src/wayland/meta-wayland-actor-surface.c
@@ -157,4 +157,4 @@ meta_wayland_actor_surface_real_sync_actor_state (MetaWaylandActorSurface *actor
   stex = meta_surface_actor_get_texture (surface_actor);
 
-  buffer = surface->buffer_ref.buffer;
+  buffer = surface->buffer_ref->buffer;
   if (buffer)
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index 2612e53f98a53ed89551077a7fb6ba5f95598cf1..c60100740cd687602e8c252e912c6111d267e7e0 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -126,6 +126,61 @@ static void
 window_actor_effects_completed (MetaWindowActor    *window_actor,
                                 MetaWaylandSurface *surface);
 
+static MetaWaylandBufferRef *
+meta_wayland_buffer_ref_new (void)
+{
+  MetaWaylandBufferRef *buffer_ref;
+
+  buffer_ref = g_new0 (MetaWaylandBufferRef, 1);
+  buffer_ref->ref_count = 1;
+
+  return buffer_ref;
+}
+
+static MetaWaylandBufferRef *
+meta_wayland_buffer_ref_ref (MetaWaylandBufferRef *buffer_ref)
+{
+  buffer_ref->ref_count++;
+  return buffer_ref;
+}
+
+static void
+meta_wayland_buffer_ref_unref (MetaWaylandBufferRef *buffer_ref)
+{
+  g_return_if_fail (buffer_ref->ref_count > 0);
+
+  buffer_ref->ref_count--;
+  if (buffer_ref->ref_count == 0)
+    {
+      g_warn_if_fail (buffer_ref->use_count == 0);
+      g_clear_object (&buffer_ref->buffer);
+      g_free (buffer_ref);
+    }
+}
+
+static void
+meta_wayland_buffer_ref_inc_use_count (MetaWaylandBufferRef *buffer_ref)
+{
+  g_return_if_fail (buffer_ref->buffer);
+  g_warn_if_fail (buffer_ref->buffer->resource);
+
+  buffer_ref->use_count++;
+}
+
+static void
+meta_wayland_buffer_ref_dec_use_count (MetaWaylandBufferRef *buffer_ref)
+{
+  MetaWaylandBuffer *buffer = buffer_ref->buffer;
+
+  g_return_if_fail (buffer_ref->use_count > 0);
+  g_return_if_fail (buffer);
+
+  buffer_ref->use_count--;
+
+  if (buffer_ref->use_count == 0 && buffer->resource)
+    wl_buffer_send_release (buffer->resource);
+}
+
 static void
 role_assignment_valist_to_properties (GType       role_type,
                                       const char *first_property_name,
@@ -384,31 +439,19 @@ meta_wayland_surface_destroy_window (MetaWaylandSurface *surface)
 MetaWaylandBuffer *
 meta_wayland_surface_get_buffer (MetaWaylandSurface *surface)
 {
-  return surface->buffer_ref.buffer;
+  return surface->buffer_ref->buffer;
 }
 
 void
 meta_wayland_surface_ref_buffer_use_count (MetaWaylandSurface *surface)
 {
-  g_return_if_fail (surface->buffer_ref.buffer);
-  g_warn_if_fail (surface->buffer_ref.buffer->resource);
-
-  surface->buffer_ref.use_count++;
+  meta_wayland_buffer_ref_inc_use_count (surface->buffer_ref);
 }
 
 void
 meta_wayland_surface_unref_buffer_use_count (MetaWaylandSurface *surface)
 {
-  MetaWaylandBuffer *buffer = surface->buffer_ref.buffer;
-
-  g_return_if_fail (surface->buffer_ref.use_count != 0);
-
-  surface->buffer_ref.use_count--;
-
-  g_return_if_fail (buffer);
-
-  if (surface->buffer_ref.use_count == 0 && buffer->resource)
-    wl_buffer_send_release (buffer->resource);
+  meta_wayland_buffer_ref_dec_use_count (surface->buffer_ref);
 }
 
 static void
@@ -690,7 +733,7 @@ meta_wayland_surface_apply_pending_state (MetaWaylandSurface      *surface,
 
   if (pending->newly_attached)
     {
-      if (!surface->buffer_ref.buffer && surface->window)
+      if (!surface->buffer_ref->buffer && surface->window)
         meta_window_queue (surface->window, META_QUEUE_CALC_SHOWING);
 
       /* Always release any previously held buffer. If the buffer held is same
@@ -701,7 +744,13 @@ meta_wayland_surface_apply_pending_state (MetaWaylandSurface      *surface,
       if (surface->buffer_held)
         meta_wayland_surface_unref_buffer_use_count (surface);
 
-      g_set_object (&surface->buffer_ref.buffer, pending->buffer);
+      if (surface->buffer_ref->use_count > 0)
+        {
+          meta_wayland_buffer_ref_unref (surface->buffer_ref);
+          surface->buffer_ref = meta_wayland_buffer_ref_new ();
+        }
+
+      g_set_object (&surface->buffer_ref->buffer, pending->buffer);
 
       if (pending->buffer)
         meta_wayland_surface_ref_buffer_use_count (surface);
@@ -826,18 +875,21 @@ meta_wayland_surface_apply_pending_state (MetaWaylandSurface      *surface,
            * role the surface is given. That means we need to also keep a use
            * count for wl_buffer's that are used by unassigned wl_surface's.
            */
-          g_set_object (&surface->unassigned.buffer, surface->buffer_ref.buffer);
+          g_set_object (&surface->unassigned.buffer,
+                        surface->buffer_ref->buffer);
           if (surface->unassigned.buffer)
             meta_wayland_surface_ref_buffer_use_count (surface);
         }
     }
 
+  //sync_can_scanout (surface);
+
 cleanup:
   /* If we have a buffer that we are not using, decrease the use count so it may
    * be released if no-one else has a use-reference to it.
    */
   if (pending->newly_attached &&
-      !surface->buffer_held && surface->buffer_ref.buffer)
+      !surface->buffer_held && surface->buffer_ref->buffer)
     meta_wayland_surface_unref_buffer_use_count (surface);
 
   g_signal_emit (pending,
@@ -1379,7 +1431,7 @@ wl_surface_destructor (struct wl_resource *resource)
   if (surface->buffer_held)
     meta_wayland_surface_unref_buffer_use_count (surface);
   g_clear_pointer (&surface->texture, cogl_object_unref);
-  g_clear_object (&surface->buffer_ref.buffer);
+  g_clear_pointer (&surface->buffer_ref, meta_wayland_buffer_ref_unref);
 
   g_clear_object (&surface->pending);
 
@@ -1668,10 +1720,13 @@ static void
 meta_wayland_surface_init (MetaWaylandSurface *surface)
 {
   surface->pending = g_object_new (META_TYPE_WAYLAND_PENDING_STATE, NULL);
+
   surface->subsurface_branch_node = g_node_new (surface);
   surface->subsurface_leaf_node =
     g_node_prepend_data (surface->subsurface_branch_node, surface);
 
+  surface->buffer_ref = meta_wayland_buffer_ref_new ();
+
   g_signal_connect (surface, "geometry-changed",
                     G_CALLBACK (meta_wayland_surface_update_outputs_recursively),
                     NULL);
@@ -1869,7 +1924,7 @@ meta_wayland_surface_calculate_input_region (MetaWaylandSurface *surface)
   cairo_region_t *region;
   cairo_rectangle_int_t buffer_rect;
 
-  if (!surface->buffer_ref.buffer)
+  if (!surface->buffer_ref->buffer)
     return NULL;
 
   buffer_rect = (cairo_rectangle_int_t) {
@@ -1978,3 +2033,38 @@ meta_wayland_surface_get_height (MetaWaylandSurface *surface)
       return height / surface->scale;
     }
 }
+
+static void
+scanout_destroyed (gpointer  data,
+                   GObject  *where_the_object_was)
+{
+  MetaWaylandBufferRef *buffer_ref = data;
+
+  meta_wayland_buffer_ref_dec_use_count (buffer_ref);
+  meta_wayland_buffer_ref_unref (buffer_ref);
+}
+
+CoglScanout *
+meta_wayland_surface_try_acquire_scanout (MetaWaylandSurface *surface,
+                                          CoglOnscreen       *onscreen)
+{
+  CoglScanout *scanout;
+  MetaWaylandBufferRef *buffer_ref;
+
+  if (!surface->buffer_ref->buffer)
+    return NULL;
+
+  if (surface->buffer_ref->use_count == 0)
+    return NULL;
+
+  scanout = meta_wayland_buffer_try_acquire_scanout (surface->buffer_ref->buffer,
+                                                     onscreen);
+  if (!scanout)
+    return NULL;
+
+  buffer_ref = meta_wayland_buffer_ref_ref (surface->buffer_ref);
+  meta_wayland_buffer_ref_inc_use_count (buffer_ref);
+  g_object_weak_ref (G_OBJECT (scanout), scanout_destroyed, buffer_ref);
+
+  return scanout;
+}
diff --git a/src/wayland/meta-wayland-surface.h b/src/wayland/meta-wayland-surface.h
index 9b225fc6f47219c553a5ff0c0bb88ca21c886f13..7a928057a631f72984b50b704f836735198fe3fc 100644
--- a/src/wayland/meta-wayland-surface.h
+++ b/src/wayland/meta-wayland-surface.h
@@ -132,6 +132,13 @@ struct _MetaWaylandDragDestFuncs
                       MetaWaylandSurface    *surface);
 };
 
+typedef struct _MetaWaylandBufferRef
+{
+  int ref_count;
+  MetaWaylandBuffer *buffer;
+  unsigned int use_count;
+} MetaWaylandBufferRef;
+
 struct _MetaWaylandSurface
 {
   GObject parent;
@@ -153,10 +160,7 @@ struct _MetaWaylandSurface
   CoglTexture *texture;
 
   /* Buffer reference state. */
-  struct {
-    MetaWaylandBuffer *buffer;
-    unsigned int use_count;
-  } buffer_ref;
+  MetaWaylandBufferRef *buffer_ref;
 
   /* Buffer renderer state. */
   gboolean buffer_held;
@@ -329,4 +333,7 @@ void                meta_wayland_surface_notify_geometry_changed (MetaWaylandSur
 int                 meta_wayland_surface_get_width (MetaWaylandSurface *surface);
 int                 meta_wayland_surface_get_height (MetaWaylandSurface *surface);
 
+CoglScanout *       meta_wayland_surface_try_acquire_scanout (MetaWaylandSurface *surface,
+                                                              CoglOnscreen       *onscreen);
+
 static inline GNode *
diff --git a/src/wayland/meta-wayland-wl-shell.c b/src/wayland/meta-wayland-wl-shell.c
index 539fb9858e49b9d8b704c6d738ef2fdb61cc11c9..3f8dc0983bff1a56b90c455d9aee7f0146e9de2a 100644
--- a/src/wayland/meta-wayland-wl-shell.c
+++ b/src/wayland/meta-wayland-wl-shell.c
@@ -582,11 +582,11 @@ wl_shell_surface_role_commit (MetaWaylandSurfaceRole  *surface_role,
   /* For wl_shell, it's equivalent to an unmap. Semantics
    * are poorly defined, so we can choose some that are
    * convenient for us. */
-  if (surface->buffer_ref.buffer && !window)
+  if (surface->buffer_ref->buffer && !window)
     {
       create_wl_shell_surface_window (surface);
     }
-  else if (!surface->buffer_ref.buffer && window)
+  else if (!surface->buffer_ref->buffer && window)
     {
       if (wl_shell_surface->popup)
         meta_wayland_popup_dismiss (wl_shell_surface->popup);
diff --git a/src/wayland/meta-wayland-xdg-shell.c b/src/wayland/meta-wayland-xdg-shell.c
index fa0207a03c5742154a2b6984b9543595330b8557..5147fb89a839b1b704fa07763a7dc3c3f0d75889 100644
--- a/src/wayland/meta-wayland-xdg-shell.c
+++ b/src/wayland/meta-wayland-xdg-shell.c
@@ -699,7 +699,7 @@ meta_wayland_xdg_toplevel_commit (MetaWaylandSurfaceRole  *surface_role,
       return;
     }
 
-  if (!surface->buffer_ref.buffer && xdg_surface_priv->first_buffer_attached)
+  if (!surface->buffer_ref->buffer && xdg_surface_priv->first_buffer_attached)
     {
       MetaWaylandActorSurface *actor_surface =
         META_WAYLAND_ACTOR_SURFACE (xdg_toplevel);
@@ -1045,7 +1045,7 @@ meta_wayland_xdg_popup_commit (MetaWaylandSurfaceRole  *surface_role,
   if (xdg_popup->setup.parent_surface)
     finish_popup_setup (xdg_popup);
 
-  if (!surface->buffer_ref.buffer && xdg_surface_priv->first_buffer_attached)
+  if (!surface->buffer_ref->buffer && xdg_surface_priv->first_buffer_attached)
     {
       meta_wayland_xdg_surface_reset (xdg_surface);
       meta_wayland_surface_cache_pending_frame_callbacks (surface, pending);
@@ -1056,7 +1056,7 @@ meta_wayland_xdg_popup_commit (MetaWaylandSurfaceRole  *surface_role,
     META_WAYLAND_SURFACE_ROLE_CLASS (meta_wayland_xdg_popup_parent_class);
   surface_role_class->commit (surface_role, pending);
 
-  if (xdg_popup->dismissed_by_client && surface->buffer_ref.buffer)
+  if (xdg_popup->dismissed_by_client && surface->buffer_ref->buffer)
     {
       wl_resource_post_error (xdg_popup->resource,
                               XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE,
@@ -1071,7 +1071,7 @@ meta_wayland_xdg_popup_commit (MetaWaylandSurfaceRole  *surface_role,
   if (!pending->newly_attached)
     return;
 
-  if (!surface->buffer_ref.buffer)
+  if (!surface->buffer_ref->buffer)
     return;
 
   window_geometry = meta_wayland_xdg_surface_get_window_geometry (xdg_surface);
@@ -1455,7 +1455,7 @@ meta_wayland_xdg_surface_commit (MetaWaylandSurfaceRole  *surface_role,
   if (!window)
     return;
 
-  if (surface->buffer_ref.buffer)
+  if (surface->buffer_ref->buffer)
     priv->first_buffer_attached = TRUE;
   else
     return;
@@ -1499,7 +1499,7 @@ meta_wayland_xdg_surface_assigned (MetaWaylandSurfaceRole *surface_role)
   priv->configure_sent = FALSE;
   priv->first_buffer_attached = FALSE;
 
-  if (surface->buffer_ref.buffer)
+  if (surface->buffer_ref->buffer)
     {
       wl_resource_post_error (xdg_wm_base_resource,
                               XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE,
@@ -2093,7 +2093,7 @@ xdg_wm_base_get_xdg_surface (struct wl_client   *client,
       return;
     }
 
-  if (surface->buffer_ref.buffer)
+  if (surface->buffer_ref->buffer)
     {
       wl_resource_post_error (resource,
                               XDG_WM_BASE_ERROR_INVALID_SURFACE_STATE,
diff --git a/src/x11/window-props.c b/src/x11/window-props.c
index 48454befe8c6836757c2fe3f74bb8d4020e402e6..1a1c7db741ecbdba42adc7ffb1420be944edd018 100644
--- a/src/x11/window-props.c
+++ b/src/x11/window-props.c
@@ -249,7 +249,7 @@ reload_net_wm_window_type (MetaWindow    *window,
 {
   MetaX11Display *x11_display = window->display->x11_display;
   MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
-  MetaWindowX11Private *priv = window_x11->priv;
+  MetaWindowX11Private *priv = meta_window_x11_get_private (window_x11);
 
   if (value->type != META_PROP_VALUE_INVALID)
     {
@@ -291,7 +291,7 @@ reload_icon (MetaWindow    *window,
              Atom           atom)
 {
   MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
-  MetaWindowX11Private *priv = window_x11->priv;
+  MetaWindowX11Private *priv = meta_window_x11_get_private (window_x11);
 
   meta_icon_cache_property_changed (&priv->icon_cache,
                                     window->display->x11_display,
@@ -596,7 +596,7 @@ set_window_title (MetaWindow *window,
                   const char *title)
 {
   MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
-  MetaWindowX11Private *priv = window_x11->priv;
+  MetaWindowX11Private *priv = meta_window_x11_get_private (window_x11);
 
   char *new_title = NULL;
 
@@ -619,7 +619,7 @@ reload_net_wm_name (MetaWindow    *window,
                     gboolean       initial)
 {
   MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
-  MetaWindowX11Private *priv = window_x11->priv;
+  MetaWindowX11Private *priv = meta_window_x11_get_private (window_x11);
 
   if (value->type != META_PROP_VALUE_INVALID)
     {
@@ -644,7 +644,7 @@ reload_wm_name (MetaWindow    *window,
                 gboolean       initial)
 {
   MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
-  MetaWindowX11Private *priv = window_x11->priv;
+  MetaWindowX11Private *priv = meta_window_x11_get_private (window_x11);
 
   if (priv->using_net_wm_name)
     {
@@ -784,7 +784,7 @@ reload_net_wm_state (MetaWindow    *window,
 {
   MetaX11Display *x11_display = window->display->x11_display;
   MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
-  MetaWindowX11Private *priv = window_x11->priv;
+  MetaWindowX11Private *priv = meta_window_x11_get_private (window_x11);
 
   int i;
 
@@ -1565,7 +1565,7 @@ reload_wm_hints (MetaWindow    *window,
                  gboolean       initial)
 {
   MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
-  MetaWindowX11Private *priv = window_x11->priv;
+  MetaWindowX11Private *priv = meta_window_x11_get_private (window_x11);
   Window old_group_leader;
   gboolean urgent;
 
@@ -1716,23 +1716,28 @@ reload_bypass_compositor (MetaWindow    *window,
                           MetaPropValue *value,
                           gboolean       initial)
 {
-  int requested_value = 0;
-  int current_value = window->bypass_compositor;
+  MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
+  MetaWindowX11Private *priv = meta_window_x11_get_private (window_x11);
+  MetaBypassCompositorHint requested_value;
+  MetaBypassCompositorHint current_value;
 
   if (value->type != META_PROP_VALUE_INVALID)
-      requested_value = (int) value->v.cardinal;
+    requested_value = (MetaBypassCompositorHint) value->v.cardinal;
+  else
+    requested_value = META_BYPASS_COMPOSITOR_HINT_AUTO;
 
+  current_value = priv->bypass_compositor;
   if (requested_value == current_value)
     return;
 
-  if (requested_value == _NET_WM_BYPASS_COMPOSITOR_HINT_ON)
+  if (requested_value == META_BYPASS_COMPOSITOR_HINT_ON)
     meta_verbose ("Request to bypass compositor for window %s.\n", window->desc);
-  else if (requested_value == _NET_WM_BYPASS_COMPOSITOR_HINT_OFF)
+  else if (requested_value == META_BYPASS_COMPOSITOR_HINT_OFF)
     meta_verbose ("Request to don't bypass compositor for window %s.\n", window->desc);
-  else if (requested_value != _NET_WM_BYPASS_COMPOSITOR_HINT_AUTO)
+  else if (requested_value != META_BYPASS_COMPOSITOR_HINT_AUTO)
     return;
 
-  window->bypass_compositor = requested_value;
+  priv->bypass_compositor = requested_value;
 }
 
 static void
diff --git a/src/x11/window-x11-private.h b/src/x11/window-x11-private.h
index c582118c79beb02dd892d64f6f9b22fed74af513..6b7bcd4b380de6a5b1760180d634fe98cdf32283 100644
--- a/src/x11/window-x11-private.h
+++ b/src/x11/window-x11-private.h
@@ -25,22 +25,21 @@
 
 #include "core/window-private.h"
 #include "x11/iconcache.h"
+#include "x11/window-x11.h"
 
 G_BEGIN_DECLS
 
-typedef struct _MetaWindowX11Private MetaWindowX11Private;
-
-struct _MetaWindowX11Class
-{
-  MetaWindowClass parent_class;
-};
-
-struct _MetaWindowX11
+/*
+ * Mirrors _NET_WM_BYPASS_COMPOSITOR preference values.
+ */
+typedef enum _MetaBypassCompositorHint
 {
-  MetaWindow parent;
+  META_BYPASS_COMPOSITOR_HINT_AUTO = 0,
+  META_BYPASS_COMPOSITOR_HINT_ON = 1,
+  META_BYPASS_COMPOSITOR_HINT_OFF = 2,
+} MetaBypassCompositorHint;
 
-  MetaWindowX11Private *priv;
-};
+typedef struct _MetaWindowX11Private MetaWindowX11Private;
 
 struct _MetaWindowX11Private
 {
@@ -72,8 +71,16 @@ struct _MetaWindowX11Private
   MetaIconCache icon_cache;
   Pixmap wm_hints_pixmap;
   Pixmap wm_hints_mask;
+
+  /* Bypass compositor hints */
+  MetaBypassCompositorHint bypass_compositor;
 };
 
+MetaWindowX11Private * meta_window_x11_get_private (MetaWindowX11 *window_x11);
+
+void meta_window_x11_set_bypass_compositor_hint (MetaWindowX11            *window_x11,
+                                                 MetaBypassCompositorHint  requested_value);
+
 G_END_DECLS
 
 #endif
diff --git a/src/x11/window-x11.c b/src/x11/window-x11.c
index 15d37c5c99732aed67db07474f78ece957ee9231..b59bc44820946d5ab8653189c339eb0d5600f3c4 100644
--- a/src/x11/window-x11.c
+++ b/src/x11/window-x11.c
@@ -74,7 +74,12 @@ meta_window_x11_maybe_focus_delayed (MetaWindow *window,
 static void
 meta_window_x11_init (MetaWindowX11 *window_x11)
 {
-  window_x11->priv = meta_window_x11_get_instance_private (window_x11);
+}
+
+MetaWindowX11Private *
+meta_window_x11_get_private (MetaWindowX11 *window_x11)
+{
+  return meta_window_x11_get_instance_private (window_x11);
 }
 
 static void
@@ -3885,3 +3890,70 @@ meta_window_x11_get_toplevel_xwindow (MetaWindow *window)
 {
   return window->frame ? window->frame->xwindow : window->xwindow;
 }
+
+MetaRectangle
+meta_window_x11_get_client_rect (MetaWindowX11 *window_x11)
+{
+  MetaWindowX11Private *priv = meta_window_x11_get_instance_private (window_x11);
+
+  return priv->client_rect;
+}
+
+static gboolean
+has_requested_bypass_compositor (MetaWindowX11 *window_x11)
+{
+  MetaWindowX11Private *priv = meta_window_x11_get_instance_private (window_x11);
+
+  return priv->bypass_compositor == META_BYPASS_COMPOSITOR_HINT_ON;
+}
+
+static gboolean
+has_requested_dont_bypass_compositor (MetaWindowX11 *window_x11)
+{
+  MetaWindowX11Private *priv = meta_window_x11_get_instance_private (window_x11);
+
+  return priv->bypass_compositor == META_BYPASS_COMPOSITOR_HINT_OFF;
+}
+
+gboolean
+meta_window_x11_is_unredirectable (MetaWindowX11 *window_x11)
+{
+  MetaWindow *window = META_WINDOW (window_x11);
+
+  if (has_requested_dont_bypass_compositor (window_x11))
+    return FALSE;
+
+  if (window->opacity != 0xFF)
+    return FALSE;
+
+  if (window->shape_region != NULL)
+    return FALSE;
+
+  if (!window->monitor)
+    return FALSE;
+
+  if (window->fullscreen)
+    return TRUE;
+
+  if (meta_window_is_screen_sized (window))
+    return TRUE;
+
+  if (has_requested_bypass_compositor (window_x11))
+    return TRUE;
+
+  if (window->override_redirect)
+    {
+      MetaRectangle window_rect;
+      MetaRectangle logical_monitor_layout;
+      MetaLogicalMonitor *logical_monitor = window->monitor;
+
+      meta_window_get_frame_rect (window, &window_rect);
+      logical_monitor_layout =
+        meta_logical_monitor_get_layout (logical_monitor);
+
+      if (meta_rectangle_equal (&window_rect, &logical_monitor_layout))
+        return TRUE;
+    }
+
+  return FALSE;
+}
diff --git a/src/x11/window-x11.h b/src/x11/window-x11.h
index f3f3f1de1437ca6d3480edf064863d38d1391b97..cbe77aa32153c392bf37bbda4fcba2288f5f8e2a 100644
--- a/src/x11/window-x11.h
+++ b/src/x11/window-x11.h
@@ -25,24 +25,20 @@
 
 #include <X11/Xlib.h>
 
+#include "core/window-private.h"
 #include "meta/compositor.h"
 #include "meta/window.h"
 
 G_BEGIN_DECLS
 
-#define META_TYPE_WINDOW_X11            (meta_window_x11_get_type())
-#define META_WINDOW_X11(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), META_TYPE_WINDOW_X11, MetaWindowX11))
-#define META_WINDOW_X11_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  META_TYPE_WINDOW_X11, MetaWindowX11Class))
-#define META_IS_WINDOW_X11(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), META_TYPE_WINDOW_X11))
-#define META_IS_WINDOW_X11_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  META_TYPE_WINDOW_X11))
-#define META_WINDOW_X11_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  META_TYPE_WINDOW_X11, MetaWindowX11Class))
+#define META_TYPE_WINDOW_X11 (meta_window_x11_get_type())
+G_DECLARE_DERIVABLE_TYPE (MetaWindowX11, meta_window_x11,
+                          META, WINDOW_X11, MetaWindow)
 
-GType meta_window_x11_get_type (void);
-
-typedef struct _MetaWindowX11      MetaWindowX11;
-typedef struct _MetaWindowX11Class MetaWindowX11Class;
-
-G_DEFINE_AUTOPTR_CLEANUP_FUNC (MetaWindowX11, g_object_unref)
+struct _MetaWindowX11Class
+{
+  MetaWindowClass parent_class;
+};
 
 MetaWindow * meta_window_x11_new           (MetaDisplay        *display,
                                             Window              xwindow,
@@ -81,4 +77,8 @@ void     meta_window_x11_configure_notify        (MetaWindow      *window,
 
 Window   meta_window_x11_get_toplevel_xwindow    (MetaWindow *window);
 
+MetaRectangle meta_window_x11_get_client_rect (MetaWindowX11 *window_x11);
+
+gboolean meta_window_x11_is_unredirectable (MetaWindowX11 *window_x11);
+
 #endif
