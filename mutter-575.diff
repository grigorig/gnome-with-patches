diff --git a/clutter/clutter/clutter-actor.c b/clutter/clutter/clutter-actor.c
index 9546f76c34a94a6454da9438df15a37c8a5c5618..665310c97b4a631d9d165a52702d465c086a9b9d 100644
--- a/clutter/clutter/clutter-actor.c
+++ b/clutter/clutter/clutter-actor.c
@@ -1680,6 +1680,15 @@ clutter_actor_unmap (ClutterActor *self)
   clutter_actor_update_map_state (self, MAP_STATE_MAKE_UNMAPPED);
 }
 
+static void
+clutter_actor_queue_shallow_relayout (ClutterActor *self)
+{
+  ClutterActor *stage = _clutter_actor_get_stage_internal (self);
+
+  if (stage != NULL)
+    clutter_stage_queue_actor_relayout (CLUTTER_STAGE (stage), self);
+}
+
 static void
 clutter_actor_real_show (ClutterActor *self)
 {
@@ -1713,6 +1722,11 @@ clutter_actor_real_show (ClutterActor *self)
 
       clutter_actor_queue_relayout (self);
     }
+  else  /* but still don't leave the actor un-allocated before showing it */
+    {
+      clutter_actor_queue_shallow_relayout (self);
+      clutter_actor_queue_redraw (self);
+    }
 }
 
 static inline void
@@ -2819,9 +2833,23 @@ clutter_actor_real_queue_relayout (ClutterActor *self)
   memset (priv->height_requests, 0,
           N_CACHED_SIZE_REQUESTS * sizeof (SizeRequest));
 
-  /* We need to go all the way up the hierarchy */
+  /* We may need to go all the way up the hierarchy */
   if (priv->parent != NULL)
-    _clutter_actor_queue_only_relayout (priv->parent);
+    {
+      if (priv->parent->flags & CLUTTER_ACTOR_NO_LAYOUT)
+        {
+          clutter_actor_queue_shallow_relayout (self);
+
+          /* The above might have invalidated the parent's paint volume if self
+           * has moved or resized. DnD seems to require this...
+           */
+          priv->parent->priv->needs_paint_volume_update = TRUE;
+        }
+      else
+        {
+          _clutter_actor_queue_only_relayout (priv->parent);
+        }
+    }
 }
 
 /**
diff --git a/clutter/clutter/clutter-stage-private.h b/clutter/clutter/clutter-stage-private.h
index b4255a47538d43e3e2fb4990a37038a4a37e760b..b6b5a3a94d868a78a202041ae4dd741a654fa747 100644
--- a/clutter/clutter/clutter-stage-private.h
+++ b/clutter/clutter/clutter-stage-private.h
@@ -134,6 +134,9 @@ void            _clutter_stage_presented                (ClutterStage      *stag
 
 GList *         _clutter_stage_peek_stage_views         (ClutterStage *stage);
 
+void            clutter_stage_queue_actor_relayout      (ClutterStage *stage,
+                                                         ClutterActor *actor);
+
 G_END_DECLS
 
 #endif /* __CLUTTER_STAGE_PRIVATE_H__ */
diff --git a/clutter/clutter/clutter-stage.c b/clutter/clutter/clutter-stage.c
index e81614eeeffb57b627fcd59d4b231a5f88e8dba8..3eda33300e9f17dad9faf09ddac3cb04128d1efa 100644
--- a/clutter/clutter/clutter-stage.c
+++ b/clutter/clutter/clutter-stage.c
@@ -129,6 +129,7 @@ struct _ClutterStagePrivate
 
   ClutterPlane current_clip_planes[4];
 
+  GList *pending_queue_relayouts;
   GList *pending_queue_redraws;
 
   CoglFramebuffer *active_framebuffer;
@@ -155,2 +156,1 @@ struct _ClutterStagePrivate
-  guint relayout_pending       : 1;
   guint redraw_pending         : 1;
@@ -1033,7 +1033,36 @@ _clutter_stage_needs_update (ClutterStage *stage)
 
   priv = stage->priv;
 
-  return priv->relayout_pending || priv->redraw_pending;
+  return priv->pending_queue_relayouts || priv->redraw_pending;
+}
+
+void
+clutter_stage_queue_actor_relayout (ClutterStage *stage,
+                                    ClutterActor *actor)
+{
+  ClutterStagePrivate *priv = stage->priv;
+
+  if (priv->pending_queue_relayouts)
+    {
+      ClutterActor *first = priv->pending_queue_relayouts->data;
+
+      if (first == (ClutterActor *) stage)
+        {
+          return;
+        }
+      else if (actor == (ClutterActor *) stage)
+        {
+          g_list_free_full (priv->pending_queue_relayouts, g_object_unref);
+          priv->pending_queue_relayouts = NULL;
+        }
+    }
+  else
+    {
+      _clutter_stage_schedule_update (stage);
+    }
+
+  priv->pending_queue_relayouts =
+    g_list_prepend (priv->pending_queue_relayouts, g_object_ref (actor));
 }
 
 void
@@ -1041,41 +1070,47 @@ _clutter_stage_maybe_relayout (ClutterActor *actor)
 {
   ClutterStage *stage = CLUTTER_STAGE (actor);
   ClutterStagePrivate *priv = stage->priv;
-  gfloat natural_width, natural_height;
-  ClutterActorBox box = { 0, };
+  GList *pending_queue_relayouts;
+  GList *l;
+  int count = 0;
 
-  if (!priv->relayout_pending)
+  if (!priv->pending_queue_relayouts)
     return;
 
-  /* avoid reentrancy */
-  if (!CLUTTER_ACTOR_IN_RELAYOUT (stage))
-    {
-      priv->relayout_pending = FALSE;
-      priv->stage_was_relayout = TRUE;
+  pending_queue_relayouts = g_steal_pointer (&priv->pending_queue_relayouts);
 
-      CLUTTER_NOTE (ACTOR, "Recomputing layout");
+  CLUTTER_NOTE (ACTOR, ">>> Recomputing layout");
 
-      CLUTTER_SET_PRIVATE_FLAGS (stage, CLUTTER_IN_RELAYOUT);
+  for (l = pending_queue_relayouts; l != NULL; l = l->next)
+    {
+      ClutterActor *queued_actor = CLUTTER_ACTOR (l->data);
+
+      if (CLUTTER_ACTOR_IN_RELAYOUT (queued_actor))  /* avoid reentrancy */
+        continue;
 
-      natural_width = natural_height = 0;
-      clutter_actor_get_preferred_size (CLUTTER_ACTOR (stage),
-                                        NULL, NULL,
-                                        &natural_width, &natural_height);
+      if (l == pending_queue_relayouts && queued_actor == actor)
+        CLUTTER_NOTE (ACTOR, "    Deep relayout of stage %s",
+                      _clutter_actor_get_debug_name (queued_actor));
+      else
+        CLUTTER_NOTE (ACTOR, "    Shallow relayout of actor %s",
+                      _clutter_actor_get_debug_name (queued_actor));
 
-      box.x1 = 0;
-      box.y1 = 0;
-      box.x2 = natural_width;
-      box.y2 = natural_height;
+      CLUTTER_SET_PRIVATE_FLAGS (queued_actor, CLUTTER_IN_RELAYOUT);
 
-      CLUTTER_NOTE (ACTOR, "Allocating (0, 0 - %d, %d) for the stage",
-                    (int) natural_width,
-                    (int) natural_height);
+      clutter_actor_allocate_preferred_size (queued_actor,
+                                             CLUTTER_ALLOCATION_NONE);
 
-      clutter_actor_allocate (CLUTTER_ACTOR (stage),
-                              &box, CLUTTER_ALLOCATION_NONE);
+      CLUTTER_UNSET_PRIVATE_FLAGS (queued_actor, CLUTTER_IN_RELAYOUT);
 
-      CLUTTER_UNSET_PRIVATE_FLAGS (stage, CLUTTER_IN_RELAYOUT);
+      count++;
     }
+
+  CLUTTER_NOTE (ACTOR, "<<< Completed recomputing layout of %d subtrees", count);
+
+  g_list_free_full (pending_queue_relayouts, g_object_unref);
+
+  if (count)
+    priv->stage_was_relayout = TRUE;
 }
 
 static void
@@ -1256,14 +1291,9 @@ static void
 clutter_stage_real_queue_relayout (ClutterActor *self)
 {
   ClutterStage *stage = CLUTTER_STAGE (self);
-  ClutterStagePrivate *priv = stage->priv;
   ClutterActorClass *parent_class;
 
-  if (!priv->relayout_pending)
-    {
-      _clutter_stage_schedule_update (stage);
-      priv->relayout_pending = TRUE;
-    }
+  clutter_stage_queue_actor_relayout (stage, self);
 
   /* chain up */
   parent_class = CLUTTER_ACTOR_CLASS (clutter_stage_parent_class);
@@ -1831,6 +1861,9 @@ clutter_stage_dispose (GObject *object)
                     (GDestroyNotify) free_queue_redraw_entry);
   priv->pending_queue_redraws = NULL;
 
+  g_list_free_full (priv->pending_queue_relayouts, g_object_unref);
+  priv->pending_queue_relayouts = NULL;
+
   /* this will release the reference on the stage */
   stage_manager = clutter_stage_manager_get_default ();
   _clutter_stage_manager_remove_stage (stage_manager, stage);
@@ -2272,7 +2305,7 @@ clutter_stage_init (ClutterStage *self)
   priv->fog.z_near = 1.0;
   priv->fog.z_far  = 2.0;
 
-  priv->relayout_pending = TRUE;
+  clutter_stage_queue_actor_relayout (self, CLUTTER_ACTOR (self));
 
   clutter_actor_set_reactive (CLUTTER_ACTOR (self), TRUE);
   clutter_stage_set_title (self, g_get_prgname ());
@@ -3497,10 +3530,9 @@ clutter_stage_ensure_redraw (ClutterStage *stage)
 
   priv = stage->priv;
 
-  if (!priv->relayout_pending && !priv->redraw_pending)
+  if (!priv->pending_queue_relayouts && !priv->redraw_pending)
     _clutter_stage_schedule_update (stage);
 
-  priv->relayout_pending = TRUE;
   priv->redraw_pending = TRUE;
 
   master_clock = _clutter_master_clock_get_default ();
diff --git a/src/compositor/meta-window-group.c b/src/compositor/meta-window-group.c
index 29ec1e74223ce2b86167378a7879306e7b0dcc21..2a95d73116130df9bb47739fcbeb1f3ef9969e8b 100644
--- a/src/compositor/meta-window-group.c
+++ b/src/compositor/meta-window-group.c
@@ -196,9 +196,41 @@ meta_window_group_class_init (MetaWindowGroupClass *klass)
   actor_class->get_preferred_height = meta_window_group_get_preferred_height;
 }
 
+static void
+on_monitors_changed (MetaMonitorManager *monitor_manager,
+                     MetaWindowGroup    *window_group)
+{
+  ClutterActor *actor = CLUTTER_ACTOR (window_group);
+
+  clutter_actor_queue_relayout (actor);
+}
+
 static void
 meta_window_group_init (MetaWindowGroup *window_group)
 {
+  ClutterActor *actor = CLUTTER_ACTOR (window_group);
+  MetaMonitorManager *monitor_manager = meta_monitor_manager_get ();
+
+  clutter_actor_set_flags (actor, CLUTTER_ACTOR_NO_LAYOUT);
+
+  /* Hotplugging monitors causes background actors (children of the window
+   * group) to change and trigger relayouts. Without CLUTTER_ACTOR_NO_LAYOUT
+   * this would automatically trickle up to the stage and then reallocate
+   * everything including all windows and backgrounds.
+   *
+   * After introducing CLUTTER_ACTOR_NO_LAYOUT however, we need to ensure that
+   * relayout of the whole window group happens manually. Otherwise you get
+   * backgrounds left unallocated (totally clipped so not rendering), and
+   * window actors that have been moved to the remaining monitors might not
+   * know their scaling factors need to change. So this is more explicit than
+   * it was prior to CLUTTER_ACTOR_NO_LAYOUT but the performance benefits are
+   * worth it.
+   */
+  g_signal_connect_object (monitor_manager,
+                           "monitors-changed",
+                           G_CALLBACK (on_monitors_changed),
+                           window_group,
+                           G_CONNECT_AFTER);
 }
 
 ClutterActor *
