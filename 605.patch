From efc9cbb80a6932b6bae383e3a34c3fd49d6c5a1c Mon Sep 17 00:00:00 2001
From: Alexander Mikhaylenko <alexm@gnome.org>
Date: Sun, 7 Jul 2019 22:51:55 +0500
Subject: [PATCH 21/36] workspacesView: Use shared adjustment

Instead of having a scroll adjustment in each WorkspacesView, and using the
one from primary screen in WorkspacesDisplay, have just one adjustment in
WorkspacesDisplay, and sync the changes between WorkspacesView.

This will allow to share the adjustment between WorkspacesDisplay and
ThumbnailsBox in the next commits.

https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/821
---
 js/ui/workspacesView.js | 136 ++++++++++++++++++++++------------------
 1 file changed, 76 insertions(+), 60 deletions(-)

diff --git a/js/ui/workspacesView.js b/js/ui/workspacesView.js
index 172d2d490..46a87861d 100644
--- a/js/ui/workspacesView.js
+++ b/js/ui/workspacesView.js
@@ -76,7 +76,7 @@ var WorkspacesViewBase = class {
 };
 
 var WorkspacesView = class extends WorkspacesViewBase {
-    constructor(monitorIndex) {
+    constructor(monitorIndex, adjustment) {
         let workspaceManager = global.workspace_manager;
 
         super(monitorIndex);
@@ -84,17 +84,11 @@ var WorkspacesView = class extends WorkspacesViewBase {
         this._animating = false; // tweening
         this._scrolling = false; // swipe-scrolling
         this._gestureActive = false; // touch(pad) gestures
-        this._animatingScroll = false; // programmatically updating the adjustment
 
-        let activeWorkspaceIndex = workspaceManager.get_active_workspace_index();
-        this.scrollAdjustment = new St.Adjustment({ value: activeWorkspaceIndex,
-                                                    lower: 0,
-                                                    page_increment: 1,
-                                                    page_size: 1,
-                                                    step_increment: 0,
-                                                    upper: workspaceManager.n_workspaces });
-        this.scrollAdjustment.connect('notify::value',
-                                      this._onScroll.bind(this));
+        this._scrollAdjustment = adjustment;
+        this._onScrollId =
+            this._scrollAdjustment.connect('notify::value',
+                                           this._onScroll.bind(this));
 
         this._workspaces = [];
         this._updateWorkspaces();
@@ -168,14 +162,6 @@ var WorkspacesView = class extends WorkspacesViewBase {
             this._workspaces[i].syncStacking(stackIndices);
     }
 
-    _scrollToActive() {
-        let workspaceManager = global.workspace_manager;
-        let active = workspaceManager.get_active_workspace_index();
-
-        this._updateWorkspaceActors(true);
-        this._updateScrollAdjustment(active);
-    }
-
     // Update workspace actors parameters
     // @showAnimation: iff %true, transition between states
     _updateWorkspaceActors(showAnimation) {
@@ -238,25 +224,10 @@ var WorkspacesView = class extends WorkspacesViewBase {
         }
     }
 
-    _updateScrollAdjustment(index) {
-        if (this._scrolling || this._gestureActive)
-            return;
-
-        this._animatingScroll = true;
-
-        this.scrollAdjustment.ease(index, {
-            mode: Clutter.AnimationMode.EASE_OUT_QUAD,
-            duration: WORKSPACE_SWITCH_TIME,
-            onComplete: () => (this._animatingScroll = false)
-        });
-    }
-
     _updateWorkspaces() {
         let workspaceManager = global.workspace_manager;
         let newNumWorkspaces = workspaceManager.n_workspaces;
 
-        this.scrollAdjustment.upper = newNumWorkspaces;
-
         for (let j = 0; j < newNumWorkspaces; j++) {
             let metaWorkspace = workspaceManager.get_workspace_by_index(j);
             let workspace;
@@ -287,13 +258,13 @@ var WorkspacesView = class extends WorkspacesViewBase {
         if (this._scrolling)
             return;
 
-        this._scrollToActive();
+        this._updateWorkspaceActors(true);
     }
 
     _onDestroy() {
         super._onDestroy();
 
-        this.scrollAdjustment.run_dispose();
+        this._scrollAdjustment.disconnect(this._onScrollId);
         Main.overview.disconnect(this._overviewShownId);
         global.window_manager.disconnect(this._switchWorkspaceNotifyId);
         let workspaceManager = global.workspace_manager;
@@ -309,7 +280,7 @@ var WorkspacesView = class extends WorkspacesViewBase {
         this._scrolling = false;
 
         // Make sure title captions etc are shown as necessary
-        this._scrollToActive();
+        this._updateWorkspaceActors(true);
         this._updateVisibility();
     }
 
@@ -321,14 +292,14 @@ var WorkspacesView = class extends WorkspacesViewBase {
         this._gestureActive = false;
 
         // Make sure title captions etc are shown as necessary
-        this._scrollToActive();
+        this._updateWorkspaceActors(true);
         this._updateVisibility();
     }
 
     // sync the workspaces' positions to the value of the scroll adjustment
     // and change the active workspace if appropriate
     _onScroll(adj) {
-        if (this._animatingScroll)
+        if (adj.get_transition("value") !== null && !this._gestureActive)
             return;
 
         let workspaceManager = global.workspace_manager;
@@ -455,6 +426,25 @@ var WorkspacesDisplay = class {
         this.actor.connect('notify::allocation', this._updateWorkspacesActualGeometry.bind(this));
         this.actor.connect('parent-set', this._parentSet.bind(this));
 
+        let workspaceManager = global.workspace_manager;
+        let activeWorkspaceIndex = workspaceManager.get_active_workspace_index();
+        this._scrollAdjustment = new St.Adjustment({ value: activeWorkspaceIndex,
+                                                     lower: 0,
+                                                     page_increment: 1,
+                                                     page_size: 1,
+                                                     step_increment: 0,
+                                                     upper: workspaceManager.n_workspaces });
+
+        this._updateWorkspaces();
+        workspaceManager.connect('notify::n-workspaces',
+                                 this._updateWorkspaces.bind(this));
+
+        global.window_manager.connect('switch-workspace',
+                                      this._activeWorkspaceChanged.bind(this));
+
+        workspaceManager.connect('workspaces-reordered',
+                                 this._workspacesReordered.bind(this));
+
         let clickAction = new Clutter.ClickAction();
         clickAction.connect('clicked', action => {
             // Only switch to the workspace when there's no application
@@ -525,6 +515,9 @@ var WorkspacesDisplay = class {
 
         this._fullGeometry = null;
 
+        this._scrolling = false; // swipe-scrolling
+        this._gestureActive = false; // touch(pad) gestures
+
         this.actor.connect('destroy', this._onDestroy.bind(this));
     }
 
@@ -542,6 +535,43 @@ var WorkspacesDisplay = class {
         }
     }
 
+    _updateWorkspaces() {
+        let workspaceManager = global.workspace_manager;
+        let newNumWorkspaces = workspaceManager.n_workspaces;
+
+        this._scrollAdjustment.upper = newNumWorkspaces;
+    }
+
+    _workspacesReordered() {
+        let workspaceManager = global.workspace_manager;
+
+        this._scrollAdjustment.value = workspaceManager.get_active_workspace_index();
+    }
+
+    _activeWorkspaceChanged(_wm, _from, _to, _direction) {
+        if (this._scrolling)
+            return;
+
+        this._scrollToActive();
+    }
+
+    _scrollToActive() {
+        let workspaceManager = global.workspace_manager;
+        let active = workspaceManager.get_active_workspace_index();
+
+        this._updateScrollAdjustment(active);
+    }
+
+    _updateScrollAdjustment(index) {
+        if (this._scrolling || this._gestureActive)
+            return;
+
+        this._scrollAdjustment.ease(index, {
+            mode: Clutter.AnimationMode.EASE_OUT_QUAD,
+            duration: WORKSPACE_SWITCH_TIME,
+        });
+    }
+
     _onPan(action) {
         let [dist_, dx, dy] = action.get_motion_delta(0);
         let adjustment = this._scrollAdjustment;
@@ -557,21 +587,27 @@ var WorkspacesDisplay = class {
     _startSwipeScroll() {
         for (let i = 0; i < this._workspacesViews.length; i++)
             this._workspacesViews[i].startSwipeScroll();
+        this._scrolling = true;
     }
 
     _endSwipeScroll() {
         for (let i = 0; i < this._workspacesViews.length; i++)
             this._workspacesViews[i].endSwipeScroll();
+        this._scrolling = false;
+        this._scrollToActive();
     }
 
     _startTouchGesture() {
         for (let i = 0; i < this._workspacesViews.length; i++)
             this._workspacesViews[i].startTouchGesture();
+        this._gestureActive = true;
     }
 
     _endTouchGesture() {
         for (let i = 0; i < this._workspacesViews.length; i++)
             this._workspacesViews[i].endTouchGesture();
+        this._gestureActive = false;
+        this._scrollToActive();
     }
 
     _onSwitchWorkspaceMotion(action, xRel, yRel) {
@@ -675,14 +711,9 @@ var WorkspacesDisplay = class {
             if (this._workspacesOnlyOnPrimary && i != this._primaryIndex)
                 view = new ExtraWorkspaceView(i);
             else
-                view = new WorkspacesView(i);
+                view = new WorkspacesView(i, this._scrollAdjustment);
 
             view.actor.connect('scroll-event', this._onScrollEvent.bind(this));
-            if (i == this._primaryIndex) {
-                this._scrollAdjustment = view.scrollAdjustment;
-                this._scrollAdjustment.connect('notify::value',
-                                               this._scrollValueChanged.bind(this));
-            }
 
             // HACK: Avoid spurious allocation changes while updating views
             view.actor.hide();
@@ -697,21 +728,6 @@ var WorkspacesDisplay = class {
         this._updateWorkspacesActualGeometry();
     }
 
-    _scrollValueChanged() {
-        for (let i = 0; i < this._workspacesViews.length; i++) {
-            if (i == this._primaryIndex)
-                continue;
-
-            let adjustment = this._workspacesViews[i].scrollAdjustment;
-            if (!adjustment)
-                continue;
-
-            // the adjustments work in terms of workspaces, so the
-            // values map directly
-            adjustment.value = this._scrollAdjustment.value;
-        }
-    }
-
     _getMonitorIndexForEvent(event) {
         let [x, y] = event.get_coords();
         let rect = new Meta.Rectangle({ x: x, y: y, width: 1, height: 1 });
-- 
2.23.0

From d1a1012632505374aff2478df81e82e4b56d012b Mon Sep 17 00:00:00 2001
From: Alexander Mikhaylenko <alexm@gnome.org>
Date: Fri, 28 Jun 2019 01:51:10 +0500
Subject: [PATCH 22/36] workspaceThumbnail: Use scroll adjustment

This will allow it to share adjustment with WorkspacesDisplay in the next
commit.

https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/821
---
 js/ui/workspaceThumbnail.js | 73 +++++++++++++++++++------------------
 1 file changed, 38 insertions(+), 35 deletions(-)

diff --git a/js/ui/workspaceThumbnail.js b/js/ui/workspaceThumbnail.js
index 206fbd863..4055d75ad 100644
--- a/js/ui/workspaceThumbnail.js
+++ b/js/ui/workspaceThumbnail.js
@@ -660,7 +660,6 @@ var ThumbnailsBox = GObject.registerClass({
         this._pendingScaleUpdate = false;
         this._stateUpdateQueued = false;
         this._animatingIndicator = false;
-        this._indicatorY = 0; // only used when _animatingIndicator is true
 
         this._stateCounts = {};
         for (let key in ThumbnailState)
@@ -707,6 +706,19 @@ var ThumbnailsBox = GObject.registerClass({
         this._nWorkspacesNotifyId = 0;
         this._syncStackingId = 0;
         this._workareasChangedId = 0;
+
+        let workspaceManager = global.workspace_manager;
+        let activeWorkspaceIndex = workspaceManager.get_active_workspace_index();
+        this._scrollAdjustment = new St.Adjustment({ value: activeWorkspaceIndex,
+                                                     lower: 0,
+                                                     page_increment: 1,
+                                                     page_size: 1,
+                                                     step_increment: 0,
+                                                     upper: workspaceManager.n_workspaces });
+
+        this._scrollAdjustment.connect('notify::value', adj => {
+            this.queue_relayout();
+        });
     }
 
     _updateSwitcherVisibility() {
@@ -974,6 +986,8 @@ var ThumbnailsBox = GObject.registerClass({
         let oldNumWorkspaces = validThumbnails.length;
         let newNumWorkspaces = workspaceManager.n_workspaces;
 
+        this._scrollAdjustment.upper = newNumWorkspaces;
+
         if (newNumWorkspaces > oldNumWorkspaces) {
             this.addThumbnails(oldNumWorkspaces, newNumWorkspaces - oldNumWorkspaces);
         } else {
@@ -1062,21 +1076,6 @@ var ThumbnailsBox = GObject.registerClass({
         return this._scale;
     }
 
-    // eslint-disable-next-line camelcase
-    set indicator_y(indicatorY) {
-        if (this._indicatorY == indicatorY)
-            return;
-
-        this._indicatorY = indicatorY;
-        this.notify('indicator-y');
-        this.queue_relayout();
-    }
-
-    // eslint-disable-next-line camelcase
-    get indicator_y() {
-        return this._indicatorY;
-    }
-
     _setThumbnailState(thumbnail, state) {
         this._stateCounts[thumbnail.state]--;
         thumbnail.state = state;
@@ -1268,13 +1267,16 @@ var ThumbnailsBox = GObject.registerClass({
         else
             slideOffset = thumbnailWidth + themeNode.get_padding(St.Side.RIGHT);
 
-        let indicatorY1 = this._indicatorY;
-        let indicatorY2;
-        // when not animating, the workspace position overrides this._indicatorY
-        let activeWorkspace = workspaceManager.get_active_workspace();
-        let indicatorWorkspace = !this._animatingIndicator ? activeWorkspace : null;
-        let indicatorThemeNode = this._indicator.get_theme_node();
+        let indicatorValue = this._scrollAdjustment.value;
+        let indicatorUpperWs = Math.ceil(indicatorValue);
+        let indicatorLowerWs = Math.floor(indicatorValue);
 
+        let indicatorLowerY1;
+        let indicatorLowerY2;
+        let indicatorUpperY1;
+        let indicatorUpperY2;
+
+        let indicatorThemeNode = this._indicator.get_theme_node();
         let indicatorTopFullBorder = indicatorThemeNode.get_padding(St.Side.TOP) + indicatorThemeNode.get_border_width(St.Side.TOP);
         let indicatorBottomFullBorder = indicatorThemeNode.get_padding(St.Side.BOTTOM) + indicatorThemeNode.get_border_width(St.Side.BOTTOM);
         let indicatorLeftFullBorder = indicatorThemeNode.get_padding(St.Side.LEFT) + indicatorThemeNode.get_border_width(St.Side.LEFT);
@@ -1326,9 +1328,13 @@ var ThumbnailsBox = GObject.registerClass({
             let y2 = Math.round(y + thumbnailHeight);
             let roundedVScale = (y2 - y1) / portholeHeight;
 
-            if (thumbnail.metaWorkspace == indicatorWorkspace) {
-                indicatorY1 = y1;
-                indicatorY2 = y2;
+            if (i == indicatorUpperWs) {
+                indicatorUpperY1 = y1;
+                indicatorUpperY2 = y2;
+            }
+            if (i == indicatorLowerWs) {
+                indicatorLowerY1 = y1;
+                indicatorLowerY2 = y2;
             }
 
             // Allocating a scaled actor is funny - x1/y1 correspond to the origin
@@ -1354,23 +1360,20 @@ var ThumbnailsBox = GObject.registerClass({
             childBox.x1 = box.x2 - thumbnailWidth;
             childBox.x2 = box.x2;
         }
+        let indicatorY1 = indicatorLowerY1 + (indicatorUpperY1 - indicatorLowerY1) * (indicatorValue % 1);
+        let indicatorY2 = indicatorLowerY2 + (indicatorUpperY2 - indicatorLowerY2) * (indicatorValue % 1);
+
         childBox.x1 -= indicatorLeftFullBorder;
         childBox.x2 += indicatorRightFullBorder;
         childBox.y1 = indicatorY1 - indicatorTopFullBorder;
-        childBox.y2 = (indicatorY2 ? indicatorY2 : (indicatorY1 + thumbnailHeight)) + indicatorBottomFullBorder;
+        childBox.y2 = indicatorY2 + indicatorBottomFullBorder;
         this._indicator.allocate(childBox, flags);
     }
 
-    _activeWorkspaceChanged(_wm, _from, _to, _direction) {
-        let workspaceManager = global.workspace_manager;
-        let activeWorkspace = workspaceManager.get_active_workspace();
-        let thumbnail = this._thumbnails.find(t => t.metaWorkspace == activeWorkspace);
-
+    _activeWorkspaceChanged(_wm, from, to, _direction) {
+        this._scrollAdjustment.value = from;
         this._animatingIndicator = true;
-        let indicatorThemeNode = this._indicator.get_theme_node();
-        let indicatorTopFullBorder = indicatorThemeNode.get_padding(St.Side.TOP) + indicatorThemeNode.get_border_width(St.Side.TOP);
-        this.indicator_y = this._indicator.allocation.y1 + indicatorTopFullBorder;
-        this.ease_property('indicator-y', thumbnail.allocation.y1, {
+        this._scrollAdjustment.ease(to, {
             progress_mode: Clutter.AnimationMode.EASE_OUT_QUAD,
             duration: WorkspacesView.WORKSPACE_SWITCH_TIME,
             onComplete: () => {
-- 
2.23.0

From aa7d6efe006e2114d631eb82507c31be5dbee670 Mon Sep 17 00:00:00 2001
From: Alexander Mikhaylenko <alexm@gnome.org>
Date: Mon, 8 Jul 2019 13:03:20 +0500
Subject: [PATCH 23/36] workspaceThumbnail: Sync indicator with
 WorkspacesDisplay

Now that both ThumbnailsBox and WorkspacesDisplay use single adjustments for
controlling indicator and scrolling, create the adjustment in OverviewControls
and pass it to both objects, effectively syncing indicator to scrolling.

https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/821
---
 js/ui/overviewControls.js   | 27 +++++++++++++++++++++++++--
 js/ui/viewSelector.js       |  4 ++--
 js/ui/workspaceThumbnail.js | 37 +++++--------------------------------
 js/ui/workspacesView.js     | 20 ++------------------
 4 files changed, 34 insertions(+), 54 deletions(-)

diff --git a/js/ui/overviewControls.js b/js/ui/overviewControls.js
index 0edf8cd5d..36b1995bb 100644
--- a/js/ui/overviewControls.js
+++ b/js/ui/overviewControls.js
@@ -423,10 +423,25 @@ var ControlsManager = class {
         this._dashSpacer = new DashSpacer();
         this._dashSpacer.setDashActor(this._dashSlider.actor);
 
-        this._thumbnailsBox = new WorkspaceThumbnail.ThumbnailsBox();
+        let workspaceManager = global.workspace_manager;
+        let activeWorkspaceIndex = workspaceManager.get_active_workspace_index();
+
+        this._workspaceAdjustment = new St.Adjustment({
+            value: activeWorkspaceIndex,
+            lower: 0,
+            page_increment: 1,
+            page_size: 1,
+            step_increment: 0,
+            upper: workspaceManager.n_workspaces,
+        });
+        this._updateWorkspaces();
+        workspaceManager.connect('notify::n-workspaces',
+            this._updateWorkspaces.bind(this));
+
+        this._thumbnailsBox = new WorkspaceThumbnail.ThumbnailsBox(this._workspaceAdjustment);
         this._thumbnailsSlider = new ThumbnailsSlider(this._thumbnailsBox);
 
-        this.viewSelector = new ViewSelector.ViewSelector(searchEntry,
+        this.viewSelector = new ViewSelector.ViewSelector(searchEntry, this._workspaceAdjustment,
                                                           this.dash.showAppsButton);
         this.viewSelector.connect('page-changed', this._setVisibility.bind(this));
         this.viewSelector.connect('page-empty', this._onPageEmpty.bind(this));
@@ -451,6 +466,14 @@ var ControlsManager = class {
         Main.overview.connect('showing', this._updateSpacerVisibility.bind(this));
     }
 
+    _updateWorkspaces() {
+        let workspaceManager = global.workspace_manager;
+        let newNumWorkspaces = workspaceManager.n_workspaces;
+
+        this._workspaceAdjustment.upper = newNumWorkspaces;
+        this._workspaceAdjustment.value = workspaceManager.get_active_workspace_index();
+    }
+
     _updateWorkspacesGeometry() {
         let [x, y] = this.actor.get_transformed_position();
         let [width, height] = this.actor.get_transformed_size();
diff --git a/js/ui/viewSelector.js b/js/ui/viewSelector.js
index 4e82c4968..ab2f6a3ab 100644
--- a/js/ui/viewSelector.js
+++ b/js/ui/viewSelector.js
@@ -124,7 +124,7 @@ var ShowOverviewAction = GObject.registerClass({
 });
 
 var ViewSelector = class {
-    constructor(searchEntry, showAppsButton) {
+    constructor(searchEntry, workspaceAdjustment, showAppsButton) {
         this.actor = new Shell.Stack({ name: 'viewSelector' });
 
         this._showAppsButton = showAppsButton;
@@ -164,7 +164,7 @@ var ViewSelector = class {
         this._iconClickedId = 0;
         this._capturedEventId = 0;
 
-        this._workspacesDisplay = new WorkspacesView.WorkspacesDisplay();
+        this._workspacesDisplay = new WorkspacesView.WorkspacesDisplay(workspaceAdjustment);
         this._workspacesPage = this._addPage(this._workspacesDisplay.actor,
                                              _("Windows"), 'focus-windows-symbolic');
 
diff --git a/js/ui/workspaceThumbnail.js b/js/ui/workspaceThumbnail.js
index 4055d75ad..cb03284fc 100644
--- a/js/ui/workspaceThumbnail.js
+++ b/js/ui/workspaceThumbnail.js
@@ -8,7 +8,6 @@ const Background = imports.ui.background;
 const DND = imports.ui.dnd;
 const Main = imports.ui.main;
 const Workspace = imports.ui.workspace;
-const WorkspacesView = imports.ui.workspacesView;
 
 // The maximum size of a thumbnail is 1/10 the width and height of the screen
 let MAX_THUMBNAIL_SCALE = 1 / 10.;
@@ -630,7 +629,7 @@ var ThumbnailsBox = GObject.registerClass({
             0, Infinity, 0)
     }
 }, class ThumbnailsBox extends St.Widget {
-    _init() {
+    _init(adjustment) {
         super._init({ reactive: true,
                       style_class: 'workspace-thumbnails',
                       request_mode: Clutter.RequestMode.WIDTH_FOR_HEIGHT });
@@ -707,16 +706,12 @@ var ThumbnailsBox = GObject.registerClass({
         this._syncStackingId = 0;
         this._workareasChangedId = 0;
 
-        let workspaceManager = global.workspace_manager;
-        let activeWorkspaceIndex = workspaceManager.get_active_workspace_index();
-        this._scrollAdjustment = new St.Adjustment({ value: activeWorkspaceIndex,
-                                                     lower: 0,
-                                                     page_increment: 1,
-                                                     page_size: 1,
-                                                     step_increment: 0,
-                                                     upper: workspaceManager.n_workspaces });
+        this._scrollAdjustment = adjustment;
 
         this._scrollAdjustment.connect('notify::value', adj => {
+            this._animatingIndicator = (adj.value % 1) != 0;
+            if (!this._animatingIndicator)
+                this._queueUpdateStates();
             this.queue_relayout();
         });
     }
@@ -919,9 +914,6 @@ var ThumbnailsBox = GObject.registerClass({
     _createThumbnails() {
         let workspaceManager = global.workspace_manager;
 
-        this._switchWorkspaceNotifyId =
-            global.window_manager.connect('switch-workspace',
-                                          this._activeWorkspaceChanged.bind(this));
         this._nWorkspacesNotifyId =
             workspaceManager.connect('notify::n-workspaces',
                                      this._workspacesChanged.bind(this));
@@ -954,10 +946,6 @@ var ThumbnailsBox = GObject.registerClass({
         if (this._thumbnails.length == 0)
             return;
 
-        if (this._switchWorkspaceNotifyId > 0) {
-            global.window_manager.disconnect(this._switchWorkspaceNotifyId);
-            this._switchWorkspaceNotifyId = 0;
-        }
         if (this._nWorkspacesNotifyId > 0) {
             let workspaceManager = global.workspace_manager;
             workspaceManager.disconnect(this._nWorkspacesNotifyId);
@@ -986,8 +974,6 @@ var ThumbnailsBox = GObject.registerClass({
         let oldNumWorkspaces = validThumbnails.length;
         let newNumWorkspaces = workspaceManager.n_workspaces;
 
-        this._scrollAdjustment.upper = newNumWorkspaces;
-
         if (newNumWorkspaces > oldNumWorkspaces) {
             this.addThumbnails(oldNumWorkspaces, newNumWorkspaces - oldNumWorkspaces);
         } else {
@@ -1369,17 +1355,4 @@ var ThumbnailsBox = GObject.registerClass({
         childBox.y2 = indicatorY2 + indicatorBottomFullBorder;
         this._indicator.allocate(childBox, flags);
     }
-
-    _activeWorkspaceChanged(_wm, from, to, _direction) {
-        this._scrollAdjustment.value = from;
-        this._animatingIndicator = true;
-        this._scrollAdjustment.ease(to, {
-            progress_mode: Clutter.AnimationMode.EASE_OUT_QUAD,
-            duration: WorkspacesView.WORKSPACE_SWITCH_TIME,
-            onComplete: () => {
-                this._animatingIndicator = false;
-                this._queueUpdateStates();
-            }
-        });
-    }
 });
diff --git a/js/ui/workspacesView.js b/js/ui/workspacesView.js
index 46a87861d..9d5163432 100644
--- a/js/ui/workspacesView.js
+++ b/js/ui/workspacesView.js
@@ -420,24 +420,15 @@ class DelegateFocusNavigator extends St.Widget {
 });
 
 var WorkspacesDisplay = class {
-    constructor() {
+    constructor(adjustment) {
         this.actor = new DelegateFocusNavigator({ clip_to_allocation: true });
         this.actor._delegate = this;
         this.actor.connect('notify::allocation', this._updateWorkspacesActualGeometry.bind(this));
         this.actor.connect('parent-set', this._parentSet.bind(this));
 
         let workspaceManager = global.workspace_manager;
-        let activeWorkspaceIndex = workspaceManager.get_active_workspace_index();
-        this._scrollAdjustment = new St.Adjustment({ value: activeWorkspaceIndex,
-                                                     lower: 0,
-                                                     page_increment: 1,
-                                                     page_size: 1,
-                                                     step_increment: 0,
-                                                     upper: workspaceManager.n_workspaces });
+        this._scrollAdjustment = adjustment;
 
-        this._updateWorkspaces();
-        workspaceManager.connect('notify::n-workspaces',
-                                 this._updateWorkspaces.bind(this));
 
         global.window_manager.connect('switch-workspace',
                                       this._activeWorkspaceChanged.bind(this));
@@ -535,13 +526,6 @@ var WorkspacesDisplay = class {
         }
     }
 
-    _updateWorkspaces() {
-        let workspaceManager = global.workspace_manager;
-        let newNumWorkspaces = workspaceManager.n_workspaces;
-
-        this._scrollAdjustment.upper = newNumWorkspaces;
-    }
-
     _workspacesReordered() {
         let workspaceManager = global.workspace_manager;
 
-- 
2.23.0

From 64a2e247c5d28f3af6af23d05efd7df0b777eb23 Mon Sep 17 00:00:00 2001
From: Alexander Mikhaylenko <exalm7659@gmail.com>
Date: Sat, 2 Nov 2019 16:37:06 +0500
Subject: [PATCH 24/36] appDisplay: Reduce page switch time to 250ms

Be consistent with workspace switching.

https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/825
---
 js/ui/appDisplay.js | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/js/ui/appDisplay.js b/js/ui/appDisplay.js
index 7a41b32ae..16f39f259 100644
--- a/js/ui/appDisplay.js
+++ b/js/ui/appDisplay.js
@@ -35,7 +35,7 @@ var MIN_FREQUENT_APPS_COUNT = 3;
 var VIEWS_SWITCH_TIME = 400;
 var VIEWS_SWITCH_ANIMATION_DELAY = 100;
 
-var PAGE_SWITCH_TIME = 300;
+var PAGE_SWITCH_TIME = 250;
 
 var APP_ICON_SCALE_IN_TIME = 500;
 var APP_ICON_SCALE_IN_DELAY = 700;
-- 
2.23.0

From 7087b8868947cb942d9a05f4e964053e07eec7fa Mon Sep 17 00:00:00 2001
From: Alexander Mikhaylenko <alexm@gnome.org>
Date: Wed, 16 Oct 2019 12:30:14 +0500
Subject: [PATCH 25/36] appDisplay: Add timeout for mouse scrolling

Prevent uncontrollably fast scrolling. Use the same duration as switching
animation, but add a separate timeout to account for disabled animations.

https://gitlab.gnome.org/GNOME/gnome-shell/issues/1338

https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/825
---
 js/ui/appDisplay.js | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/js/ui/appDisplay.js b/js/ui/appDisplay.js
index 16f39f259..759740485 100644
--- a/js/ui/appDisplay.js
+++ b/js/ui/appDisplay.js
@@ -341,6 +341,9 @@ var AllView = class AllView extends BaseAppView {
         this._displayingPopup = false;
         this._currentPopupDestroyId = 0;
 
+        this._canScroll = true; // limiting scrolling speed
+        this._scrollTimeoutId = 0;
+
         this._availWidth = 0;
         this._availHeight = 0;
 
@@ -382,6 +385,15 @@ var AllView = class AllView extends BaseAppView {
 
         Main.overview.connect('item-drag-begin', this._onDragBegin.bind(this));
         Main.overview.connect('item-drag-end', this._onDragEnd.bind(this));
+
+        this.actor.connect('destroy', this._onDestroy.bind(this));
+    }
+
+    _onDestroy() {
+        if (this._scrollTimeoutId != 0) {
+            GLib.source_remove(this._scrollTimeoutId);
+            this._scrollTimeoutId = 0;
+        }
     }
 
     _redisplay() {
@@ -592,11 +604,23 @@ var AllView = class AllView extends BaseAppView {
         if (this._displayingPopup || !this._scrollView.reactive)
             return Clutter.EVENT_STOP;
 
+        if (!this._canScroll)
+            return Clutter.EVENT_STOP;
+
         let direction = event.get_scroll_direction();
         if (direction == Clutter.ScrollDirection.UP)
             this.goToPage(this._grid.currentPage - 1);
         else if (direction == Clutter.ScrollDirection.DOWN)
             this.goToPage(this._grid.currentPage + 1);
+        else
+            return Clutter.EVENT_STOP;
+
+        this._canScroll = false;
+        this._scrollTimeoutId = GLib.timeout_add(GLib.PRIORITY_DEFAULT, PAGE_SWITCH_TIME, () => {
+            this._canScroll = true;
+            this._scrollTimeoutId = 0;
+            return GLib.SOURCE_REMOVE;
+        });
 
         return Clutter.EVENT_STOP;
     }
-- 
2.23.0

From 8bfc112ed87e04cdaf5c38d0c019232d72f59793 Mon Sep 17 00:00:00 2001
From: Alexander Mikhaylenko <alexm@gnome.org>
Date: Wed, 16 Oct 2019 10:39:48 +0500
Subject: [PATCH 26/36] workspacesView: Add timeout for mouse scrolling

Prevent uncontrollably fast scrolling. Use the same duration as switching
animation, but add a separate timeout to account for disabled animations.

https://gitlab.gnome.org/GNOME/gnome-shell/issues/1338

https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/825
---
 js/ui/workspacesView.js | 20 +++++++++++++++++++-
 1 file changed, 19 insertions(+), 1 deletion(-)

diff --git a/js/ui/workspacesView.js b/js/ui/workspacesView.js
index 9d5163432..2e9ed87ae 100644
--- a/js/ui/workspacesView.js
+++ b/js/ui/workspacesView.js
@@ -1,7 +1,7 @@
 // -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
 /* exported WorkspacesView */
 
-const { Clutter, Gio, GObject, Meta, Shell, St } = imports.gi;
+const { Clutter, Gio, GLib, GObject, Meta, Shell, St } = imports.gi;
 const Signals = imports.signals;
 
 const Main = imports.ui.main;
@@ -503,11 +503,13 @@ var WorkspacesDisplay = class {
         this._restackedNotifyId = 0;
         this._scrollEventId = 0;
         this._keyPressEventId = 0;
+        this._scrollTimeoutId = 0;
 
         this._fullGeometry = null;
 
         this._scrolling = false; // swipe-scrolling
         this._gestureActive = false; // touch(pad) gestures
+        this._canScroll = true; // limiting scrolling speed
 
         this.actor.connect('destroy', this._onDestroy.bind(this));
     }
@@ -524,6 +526,11 @@ var WorkspacesDisplay = class {
             Meta.later_remove(this._parentSetLater);
             this._parentSetLater = 0;
         }
+
+        if (this._scrollTimeoutId != 0) {
+            GLib.source_remove(this._scrollTimeoutId);
+            this._scrollTimeoutId = 0;
+        }
     }
 
     _workspacesReordered() {
@@ -805,6 +812,9 @@ var WorkspacesDisplay = class {
             this._getMonitorIndexForEvent(event) != this._primaryIndex)
             return Clutter.EVENT_PROPAGATE;
 
+        if (!this._canScroll)
+            return Clutter.EVENT_PROPAGATE;
+
         let workspaceManager = global.workspace_manager;
         let activeWs = workspaceManager.get_active_workspace();
         let ws;
@@ -825,6 +835,14 @@ var WorkspacesDisplay = class {
             return Clutter.EVENT_PROPAGATE;
         }
         Main.wm.actionMoveWorkspace(ws);
+
+        this._canScroll = false;
+        this._scrollTimeoutId = GLib.timeout_add(GLib.PRIORITY_DEFAULT, WORKSPACE_SWITCH_TIME, () => {
+            this._canScroll = true;
+            this._scrollTimeoutId = 0;
+            return GLib.SOURCE_REMOVE;
+        });
+
         return Clutter.EVENT_STOP;
     }
 
-- 
2.23.0

From deef22cb0dd9680a16dfb46ddb1c8fb63957991f Mon Sep 17 00:00:00 2001
From: Alexander Mikhaylenko <alexm@gnome.org>
Date: Sun, 30 Jun 2019 17:11:27 +0500
Subject: [PATCH 27/36] swipeTracker: Introduce swipe tracker

Add a unified swipe tracker supporting dragging, four-finger swipe on both
touchscreen and touchpad, and touchpad scrolling.

The shared logic is largely same as the one in WebKit and libhandy.

https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/826
---
 js/js-resources.gresource.xml |   1 +
 js/ui/swipeTracker.js         | 485 ++++++++++++++++++++++++++++++++++
 2 files changed, 486 insertions(+)
 create mode 100644 js/ui/swipeTracker.js

diff --git a/js/js-resources.gresource.xml b/js/js-resources.gresource.xml
index b5348ddcb..aec3427e0 100644
--- a/js/js-resources.gresource.xml
+++ b/js/js-resources.gresource.xml
@@ -98,6 +98,7 @@
     <file>ui/shellEntry.js</file>
     <file>ui/shellMountOperation.js</file>
     <file>ui/slider.js</file>
+    <file>ui/swipeTracker.js</file>
     <file>ui/switcherPopup.js</file>
     <file>ui/switchMonitor.js</file>
     <file>ui/tweener.js</file>
diff --git a/js/ui/swipeTracker.js b/js/ui/swipeTracker.js
new file mode 100644
index 000000000..cc697986e
--- /dev/null
+++ b/js/ui/swipeTracker.js
@@ -0,0 +1,485 @@
+// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
+/* exported SwipeTracker */
+
+const { Clutter, Gio, GObject, Meta } = imports.gi;
+
+const Signals = imports.signals;
+
+const Main = imports.ui.main;
+
+// FIXME: ideally this value matches physical touchpad size. We can get this value for gnome-shell
+// specifically, since mutter uses libinput directly, but GTK apps cannot get it, so use an arbitrary
+// value so that it's consistent with apps instead.
+const TOUCHPAD_BASE_DISTANCE_V = 300;
+const TOUCHPAD_BASE_DISTANCE_H = 400;
+const SCROLL_MULTIPLIER = 10;
+const SWIPE_MULTIPLIER = 0.5;
+
+const MIN_ANIMATION_DURATION = 100;
+const MAX_ANIMATION_DURATION = 400;
+const VELOCITY_THRESHOLD = 0.4;
+const DURATION_MULTIPLIER = 3;
+const ANIMATION_BASE_VELOCITY = 0.002;
+
+var State = {
+    NONE: 0,
+    SCROLLING: 1,
+};
+
+function clamp(value, min, max) {
+    return Math.max(min, Math.min(max, value));
+}
+
+var TouchpadSwipeGesture = class TouchpadSwipeGesture {
+    constructor(shouldSkip) {
+        this._shouldSkip = shouldSkip;
+        this._touchpadSettings = new Gio.Settings({ schema_id: 'org.gnome.desktop.peripherals.touchpad' });
+        this._orientation = Clutter.Orientation.VERTICAL;
+
+        global.stage.connect('captured-event', this._handleEvent.bind(this));
+    }
+
+    _handleEvent(_actor, event) {
+        if (event.type() != Clutter.EventType.TOUCHPAD_SWIPE)
+            return Clutter.EVENT_PROPAGATE;
+
+        if (event.get_touchpad_gesture_finger_count() != 4)
+            return Clutter.EVENT_PROPAGATE;
+
+        if (this._shouldSkip())
+            return Clutter.EVENT_PROPAGATE;
+
+        let time = event.get_time();
+
+        let [x, y] = event.get_coords();
+        let [dx, dy] = event.get_gesture_motion_delta();
+
+        let delta;
+        if (this._orientation == Clutter.Orientation.VERTICAL)
+            delta = dy / TOUCHPAD_BASE_DISTANCE_V;
+        else
+            delta = dx / TOUCHPAD_BASE_DISTANCE_H;
+
+        switch (event.get_gesture_phase()) {
+        case Clutter.TouchpadGesturePhase.BEGIN:
+            this.emit('begin', time, x, y);
+            break;
+
+        case Clutter.TouchpadGesturePhase.UPDATE:
+            if (this._touchpadSettings.get_boolean('natural-scroll'))
+                delta = -delta;
+
+            this.emit('update', time, delta * SWIPE_MULTIPLIER);
+            break;
+
+        case Clutter.TouchpadGesturePhase.END:
+        case Clutter.TouchpadGesturePhase.CANCEL:
+            this.emit('end', time);
+            break;
+        }
+
+        return Clutter.EVENT_STOP;
+    }
+
+    setOrientation(orientation) {
+        this._orientation = orientation;
+    }
+};
+Signals.addSignalMethods(TouchpadSwipeGesture.prototype);
+
+var TouchSwipeGesture = GObject.registerClass({
+    Signals: { 'begin':  { param_types: [GObject.TYPE_UINT, GObject.TYPE_DOUBLE, GObject.TYPE_DOUBLE] },
+               'update': { param_types: [GObject.TYPE_UINT, GObject.TYPE_DOUBLE] },
+               'end':    { param_types: [GObject.TYPE_UINT] },
+               'cancel': { param_types: [GObject.TYPE_UINT] } },
+}, class TouchSwipeGesture extends Clutter.GestureAction {
+    _init(shouldSkip, nTouchPoints, thresholdTriggerEdge) {
+        super._init();
+        this.set_n_touch_points(nTouchPoints);
+        this.set_threshold_trigger_edge(thresholdTriggerEdge);
+
+        this._shouldSkip = shouldSkip;
+        this._distance = global.screen_height;
+        this._orientation = Clutter.Orientation.VERTICAL;
+
+        if (nTouchPoints > 1) {
+            global.display.connect('grab-op-begin', () => {
+                this.cancel();
+            });
+        }
+
+        this._lastPosition = 0;
+    }
+
+    vfunc_gesture_prepare(actor) {
+        if (!super.vfunc_gesture_prepare(actor))
+            return false;
+
+        if (this._shouldSkip())
+            return false;
+
+        let time = this.get_last_event(0).get_time();
+        let [xPress, yPress] = this.get_press_coords(0);
+        let [x, y] = this.get_motion_coords(0);
+
+        this._lastPosition = this._orientation == Clutter.Orientation.VERTICAL ? y : x;
+
+        this.emit('begin', time, xPress, yPress);
+        return true;
+    }
+
+    // TODO: track center of the gesture instead of the first one
+    vfunc_gesture_progress(_actor) {
+        let [x, y] = this.get_motion_coords(0);
+        let pos = this._orientation == Clutter.Orientation.VERTICAL ? y : x;
+
+        let delta = pos - this._lastPosition;
+        this._lastPosition = pos;
+
+        let time = this.get_last_event(0).get_time();
+
+        this.emit('update', time, -delta / this._distance);
+
+        return true;
+    }
+
+    vfunc_gesture_end(_actor) {
+        let time = this.get_last_event(0).get_time();
+
+        this.emit('end', time);
+    }
+
+    vfunc_gesture_cancel(_actor) {
+        let time = Clutter.get_current_event_time();
+
+        this.emit('cancel', time);
+    }
+
+    setDistance(distance) {
+        this._distance = distance;
+    }
+
+    setOrientation(orientation) {
+        this._orientation = orientation;
+    }
+});
+
+var ScrollGesture = class ScrollGesture {
+    constructor(actor, shouldSkip) {
+        this._shouldSkip = shouldSkip;
+        this._began = false;
+        this._orientation = Clutter.Orientation.VERTICAL;
+
+        actor.connect('scroll-event', this._handleEvent.bind(this));
+    }
+
+    canHandleEvent(event) {
+        if (event.type() != Clutter.EventType.SCROLL)
+            return false;
+
+        if (event.get_scroll_source() != Clutter.ScrollSource.FINGER &&
+            event.get_source_device().get_device_type() != Clutter.InputDeviceType.TOUCHPAD_DEVICE)
+            return false;
+
+        if (this._shouldSkip())
+            return false;
+
+        return true;
+    }
+
+    _handleEvent(_actor, event) {
+        if (!this.canHandleEvent(event))
+            return Clutter.EVENT_PROPAGATE;
+
+        if (event.get_scroll_direction() != Clutter.ScrollDirection.SMOOTH)
+            return false;
+
+        let time = event.get_time();
+        let [dx, dy] = event.get_scroll_delta();
+        if (dx == 0 && dy == 0) {
+            this.emit('end', time);
+            this._began = false;
+            return Clutter.EVENT_STOP;
+        }
+
+        if (!this._began) {
+            let [x, y] = event.get_coords();
+            this.emit('begin', time, x, y);
+            this._began = true;
+        }
+
+        let delta;
+        if (this._orientation == Clutter.Orientation.VERTICAL)
+            delta = dy / TOUCHPAD_BASE_DISTANCE_V;
+        else
+            delta = dx / TOUCHPAD_BASE_DISTANCE_H;
+
+        this.emit('update', time, delta * SCROLL_MULTIPLIER);
+
+        return Clutter.EVENT_STOP;
+    }
+
+    setOrientation(orientation) {
+        this._orientation = orientation;
+    }
+};
+Signals.addSignalMethods(ScrollGesture.prototype);
+
+// USAGE:
+//
+// To correctly implement the gesture, there must be handlers for the following signals:
+//
+// begin(tracker, monitor)
+//   The handler should check whether a deceleration animation is currently
+//   running. If it is, it should stop the animation (without resetting progress).
+//   Then it should call tracker.confirmSwipe(distance, snapPoints, currentProgress, cancelProgress).
+//   If it's not called, the swipe would be ignored.
+//   The parameters are:
+//    * distance: the page size;
+//    * snapPoints: an (sorted with ascending order) array of snap points;
+//    * currentProgress: the current progress;
+//    * cancelprogress: a non-transient value that would be used if the gesture is cancelled.
+//   If no animation was running, currentProgress and cancelProgress should be same.
+//   The handler may set 'orientation' property here.
+//
+// update(tracker, progress)
+//   The handler should set the progress to the given value.
+//
+// end(tracker, duration, endProgress)
+//   The handler should animate the progress to endProgress. If endProgress is 0, it
+//   should do nothing after the animation, otherwise it should change the state,
+//   e.g. change the current page or switch workspace.
+//   NOTE: duration can be 0 in some cases, in this case it should finish instantly.
+
+var SwipeTracker = class {
+    constructor(actor, allowedModes, allowDrag = true, allowScroll = true) {
+        this._allowedModes = allowedModes;
+        this._enabled = true;
+        this._orientation = Clutter.Orientation.VERTICAL;
+
+        this._reset();
+
+        let shouldSkip = () =>
+            (this._allowedModes & Main.actionMode) == 0 || !this._enabled;
+
+        this._touchpadGesture = new TouchpadSwipeGesture(shouldSkip);
+        this._touchpadGesture.connect('begin', this._beginGesture.bind(this));
+        this._touchpadGesture.connect('update', this._updateGesture.bind(this));
+        this._touchpadGesture.connect('end', this._endGesture.bind(this));
+        // this._touchpadGesture.connect('cancel', this._cancelGesture.bind(this)); // End the gesture normally for touchpads
+
+        this._touchGesture = new TouchSwipeGesture(shouldSkip, 4, Clutter.GestureTriggerEdge.NONE);
+        this._touchGesture.connect('begin', this._beginTouchSwipe.bind(this));
+        this._touchGesture.connect('update', this._updateGesture.bind(this));
+        this._touchGesture.connect('end', this._endGesture.bind(this));
+        this._touchGesture.connect('cancel', this._cancelGesture.bind(this));
+        global.stage.add_action(this._touchGesture);
+
+        if (allowDrag) {
+            this._dragGesture = new TouchSwipeGesture(shouldSkip, 1, Clutter.GestureTriggerEdge.AFTER);
+            this._dragGesture.connect('begin', this._beginGesture.bind(this));
+            this._dragGesture.connect('update', this._updateGesture.bind(this));
+            this._dragGesture.connect('end', this._endGesture.bind(this));
+            this._dragGesture.connect('cancel', this._cancelGesture.bind(this));
+            actor.add_action(this._dragGesture);
+        } else {
+            this._dragGesture = null;
+        }
+
+        if (allowScroll) {
+            this._scrollGesture = new ScrollGesture(actor, shouldSkip);
+            this._scrollGesture.connect('begin', this._beginGesture.bind(this));
+            this._scrollGesture.connect('update', this._updateGesture.bind(this));
+            this._scrollGesture.connect('end', this._endGesture.bind(this));
+        } else {
+            this._scrollGesture = null;
+        }
+    }
+
+    canHandleScrollEvent(event) {
+        if (!this.enabled || this._scrollGesture == null)
+            return false;
+
+        return this._scrollGesture.canHandleEvent(event);
+    }
+
+    get enabled() {
+        return this._enabled;
+    }
+
+    set enabled(enabled) {
+        if (this._enabled == enabled)
+            return;
+
+        this._enabled = enabled;
+        if (!enabled && this._state == State.SCROLLING)
+            this._cancel();
+    }
+
+    get orientation() {
+        return this._orientation;
+    }
+
+    set orientation(orientation) {
+        if (this._orientation == orientation)
+            return;
+
+        this._orientation = orientation;
+
+        this._touchpadGesture.setOrientation(orientation);
+        this._touchGesture.setOrientation(orientation);
+        if (this._dragGesture)
+            this._dragGesture.setOrientation(orientation);
+        if (this._scrollGesture)
+            this._scrollGesture.setOrientation(orientation);
+    }
+
+    _reset() {
+        this._state = State.NONE;
+
+        this._snapPoints = [];
+        this._distance = 0;
+        this._initialProgress = 0;
+        this._cancelProgress = 0;
+
+        this._prevOffset = 0;
+        this._progress = 0;
+
+        this._prevTime = 0;
+        this._velocity = 0;
+
+        this._cancelled = false;
+    }
+
+    _cancel() {
+        this.emit('end', 0, this._cancelProgress);
+        this._reset();
+    }
+
+    _beginTouchSwipe(gesture, time, x, y) {
+        if (this._dragGesture)
+            this._dragGesture.cancel();
+
+        this._beginGesture(gesture, time, x, y);
+    }
+
+    _beginGesture(_gesture, time, x, y) {
+        if (this._state == State.SCROLLING)
+            return;
+
+        this._prevTime = time;
+
+        let rect = new Meta.Rectangle({ x, y, width: 1, height: 1 });
+        let monitor = global.display.get_monitor_index_for_rect(rect);
+
+        this.emit('begin', monitor);
+    }
+
+    _updateGesture(_gesture, time, delta) {
+        if ((this._allowedModes & Main.actionMode) == 0 || !this._enabled)
+            return;
+
+        if (this._state != State.SCROLLING)
+            return;
+
+        if (this.orientation == Clutter.Orientation.HORIZONTAL &&
+            Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
+            delta = -delta;
+
+        this._progress += delta;
+
+        if (time != this._prevTime)
+            this._velocity = delta / (time - this._prevTime);
+
+        let firstPoint = this._snapPoints[0];
+        let lastPoint = this._snapPoints[this._snapPoints.length - 1];
+        this._progress = clamp(this._progress, firstPoint, lastPoint);
+        this._progress = clamp(this._progress, this._initialProgress - 1, this._initialProgress + 1);
+
+        this.emit('update', this._progress);
+
+        this._prevTime = time;
+    }
+
+    _getClosestSnapPoints() {
+        let upper, lower;
+
+        for (let i = 0; i < this._snapPoints.length; i++) {
+            if (this._snapPoints[i] >= this._progress) {
+                upper = this._snapPoints[i];
+                break;
+            }
+        }
+
+        for (let i = this._snapPoints.length - 1; i >= 0; i--) {
+            if (this._snapPoints[i] <= this._progress) {
+                lower = this._snapPoints[i];
+                break;
+            }
+        }
+
+        return [upper, lower];
+    }
+
+    _getEndProgress() {
+        if (this._cancelled)
+            return this._cancelProgress;
+
+        let [upper, lower] = this._getClosestSnapPoints();
+        let middle = (upper + lower) / 2;
+
+        if (this._progress > middle) {
+            return this._velocity * this._distance > -VELOCITY_THRESHOLD ||
+                   this._initialProgress > upper ? upper : lower;
+        } else {
+            return this._velocity * this._distance < VELOCITY_THRESHOLD ||
+                   this._initialProgress < lower ? lower : upper;
+        }
+    }
+
+    _endGesture(_gesture, _time) {
+        if ((this._allowedModes & Main.actionMode) == 0 || !this._enabled) {
+            // this._cancel();
+            return;
+        }
+
+        if (this._state != State.SCROLLING)
+            return;
+
+        let endProgress = this._getEndProgress();
+
+        let velocity = ANIMATION_BASE_VELOCITY;
+        if ((endProgress - this._progress) * this._velocity > 0)
+            velocity = this._velocity;
+
+        let duration = Math.abs((this._progress - endProgress) / velocity * DURATION_MULTIPLIER);
+        duration = clamp(duration, MIN_ANIMATION_DURATION, MAX_ANIMATION_DURATION);
+
+        this.emit('end', duration, endProgress);
+        this._reset();
+    }
+
+    _cancelGesture(gesture, time) {
+        if (this._state != State.SCROLLING)
+            return;
+
+        this._cancelled = true;
+        this._endGesture(gesture, time);
+    }
+
+    confirmSwipe(distance, snapPoints, currentProgress, cancelProgress) {
+        this._distance = distance;
+        this._snapPoints = snapPoints;
+        this._initialProgress = currentProgress;
+        this._progress = currentProgress;
+        this._cancelProgress = cancelProgress;
+
+        this._touchGesture.setDistance(distance);
+        if (this._dragGesture)
+            this._dragGesture.setDistance(distance);
+
+        this._velocity = 0;
+        this._state = State.SCROLLING;
+    }
+};
+Signals.addSignalMethods(SwipeTracker.prototype);
-- 
2.23.0

From 038bddc9eb6e533fa1565ba211a90c85fc80c4c3 Mon Sep 17 00:00:00 2001
From: Alexander Mikhaylenko <alexm@gnome.org>
Date: Mon, 8 Jul 2019 13:47:04 +0500
Subject: [PATCH 28/36] workspacesView: Use SwipeTracker

Replace existing panning, touchpad scrolling and four-finger gesture by
SwipeTracker.

Change programmatic workspace animation to use easeOutCubic interpolator
to match the gesture.

Also change the dragging distance to always match the current monitor.

Fixes touchpad parts of https://gitlab.gnome.org/GNOME/gnome-shell/issues/1338

https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/826
---
 js/ui/workspacesView.js | 181 ++++++++++++++++------------------------
 1 file changed, 73 insertions(+), 108 deletions(-)

diff --git a/js/ui/workspacesView.js b/js/ui/workspacesView.js
index 2e9ed87ae..38e74de21 100644
--- a/js/ui/workspacesView.js
+++ b/js/ui/workspacesView.js
@@ -5,7 +5,7 @@ const { Clutter, Gio, GLib, GObject, Meta, Shell, St } = imports.gi;
 const Signals = imports.signals;
 
 const Main = imports.ui.main;
-const WindowManager = imports.ui.windowManager;
+const SwipeTracker = imports.ui.swipeTracker;
 const Workspace = imports.ui.workspace;
 
 var WORKSPACE_SWITCH_TIME = 250;
@@ -82,7 +82,6 @@ var WorkspacesView = class extends WorkspacesViewBase {
         super(monitorIndex);
 
         this._animating = false; // tweening
-        this._scrolling = false; // swipe-scrolling
         this._gestureActive = false; // touch(pad) gestures
 
         this._scrollAdjustment = adjustment;
@@ -186,7 +185,7 @@ var WorkspacesView = class extends WorkspacesViewBase {
             if (showAnimation) {
                 let easeParams = Object.assign(params, {
                     duration: WORKSPACE_SWITCH_TIME,
-                    mode: Clutter.AnimationMode.EASE_OUT_QUAD
+                    mode: Clutter.AnimationMode.EASE_OUT_CUBIC
                 });
                 // we have to call _updateVisibility() once before the
                 // animation and once afterwards - it does not really
@@ -213,7 +212,7 @@ var WorkspacesView = class extends WorkspacesViewBase {
 
         for (let w = 0; w < this._workspaces.length; w++) {
             let workspace = this._workspaces[w];
-            if (this._animating || this._scrolling || this._gestureActive) {
+            if (this._animating || this._gestureActive) {
                 workspace.actor.show();
             } else {
                 if (this._inDrag)
@@ -272,18 +271,6 @@ var WorkspacesView = class extends WorkspacesViewBase {
         workspaceManager.disconnect(this._reorderWorkspacesId);
     }
 
-    startSwipeScroll() {
-        this._scrolling = true;
-    }
-
-    endSwipeScroll() {
-        this._scrolling = false;
-
-        // Make sure title captions etc are shown as necessary
-        this._updateWorkspaceActors(true);
-        this._updateVisibility();
-    }
-
     startTouchGesture() {
         this._gestureActive = true;
     }
@@ -399,12 +386,6 @@ var ExtraWorkspaceView = class extends WorkspacesViewBase {
         this._workspace.syncStacking(stackIndices);
     }
 
-    startSwipeScroll() {
-    }
-
-    endSwipeScroll() {
-    }
-
     startTouchGesture() {
     }
 
@@ -449,50 +430,21 @@ var WorkspacesDisplay = class {
         });
         Main.overview.addAction(clickAction);
         this.actor.bind_property('mapped', clickAction, 'enabled', GObject.BindingFlags.SYNC_CREATE);
-
-        let panAction = new Clutter.PanAction({ threshold_trigger_edge: Clutter.GestureTriggerEdge.AFTER });
-        panAction.connect('pan', this._onPan.bind(this));
-        panAction.connect('gesture-begin', () => {
-            if (this._workspacesOnlyOnPrimary) {
-                let event = Clutter.get_current_event();
-                if (this._getMonitorIndexForEvent(event) != this._primaryIndex)
-                    return false;
-            }
-
-            this._startSwipeScroll();
-            return true;
-        });
-        panAction.connect('gesture-cancel', () => {
-            clickAction.release();
-            this._endSwipeScroll();
-        });
-        panAction.connect('gesture-end', () => {
-            clickAction.release();
-            this._endSwipeScroll();
-        });
-        Main.overview.addAction(panAction);
-        this.actor.bind_property('mapped', panAction, 'enabled', GObject.BindingFlags.SYNC_CREATE);
+        this._clickAction = clickAction;
 
         let allowedModes = Shell.ActionMode.OVERVIEW;
-        let switchGesture = new WindowManager.WorkspaceSwitchAction(allowedModes);
-        switchGesture.connect('motion', this._onSwitchWorkspaceMotion.bind(this));
-        switchGesture.connect('activated', this._onSwitchWorkspaceActivated.bind(this));
-        switchGesture.connect('cancel', this._endTouchGesture.bind(this));
-        Main.overview.addAction(switchGesture);
-        this.actor.bind_property('mapped', switchGesture, 'enabled', GObject.BindingFlags.SYNC_CREATE);
-
-        switchGesture = new WindowManager.TouchpadWorkspaceSwitchAction(global.stage, allowedModes);
-        switchGesture.connect('motion', this._onSwitchWorkspaceMotion.bind(this));
-        switchGesture.connect('activated', this._onSwitchWorkspaceActivated.bind(this));
-        switchGesture.connect('cancel', this._endTouchGesture.bind(this));
+        this._swipeTracker = new SwipeTracker.SwipeTracker(Main.layoutManager.overviewGroup, allowedModes);
+        this._swipeTracker.connect('begin', this._switchWorkspaceBegin.bind(this));
+        this._swipeTracker.connect('update', this._switchWorkspaceUpdate.bind(this));
+        this._swipeTracker.connect('end', this._switchWorkspaceEnd.bind(this));
+        this._swipeTracker.enabled = this.actor.mapped;
         this.actor.connect('notify::mapped', () => {
-            switchGesture.enabled = this.actor.mapped;
+            this._swipeTracker.enabled = this.actor.mapped;
         });
 
         this._primaryIndex = Main.layoutManager.primaryIndex;
 
         this._workspacesViews = [];
-        switchGesture.enabled = this.actor.mapped;
 
         this._settings = new Gio.Settings({ schema_id: MUTTER_SCHEMA });
         this._settings.connect('changed::workspaces-only-on-primary',
@@ -507,7 +459,6 @@ var WorkspacesDisplay = class {
 
         this._fullGeometry = null;
 
-        this._scrolling = false; // swipe-scrolling
         this._gestureActive = false; // touch(pad) gestures
         this._canScroll = true; // limiting scrolling speed
 
@@ -540,7 +491,7 @@ var WorkspacesDisplay = class {
     }
 
     _activeWorkspaceChanged(_wm, _from, _to, _direction) {
-        if (this._scrolling)
+        if (this._gestureActive)
             return;
 
         this._scrollToActive();
@@ -554,77 +505,90 @@ var WorkspacesDisplay = class {
     }
 
     _updateScrollAdjustment(index) {
-        if (this._scrolling || this._gestureActive)
+        if (this._gestureActive)
             return;
 
         this._scrollAdjustment.ease(index, {
-            mode: Clutter.AnimationMode.EASE_OUT_QUAD,
+            mode: Clutter.AnimationMode.EASE_OUT_CUBIC,
             duration: WORKSPACE_SWITCH_TIME,
         });
     }
 
-    _onPan(action) {
-        let [dist_, dx, dy] = action.get_motion_delta(0);
-        let adjustment = this._scrollAdjustment;
+    _directionForProgress(progress) {
         if (global.workspace_manager.layout_rows == -1)
-            adjustment.value -= (dy / this.actor.height) * adjustment.page_size;
+            return progress > 0 ? Meta.MotionDirection.DOWN : Meta.MotionDirection.UP;
         else if (this.actor.text_direction == Clutter.TextDirection.RTL)
-            adjustment.value += (dx / this.actor.width) * adjustment.page_size;
+            return progress > 0 ? Meta.MotionDirection.LEFT : Meta.MotionDirection.RIGHT;
         else
-            adjustment.value -= (dx / this.actor.width) * adjustment.page_size;
-        return false;
+            return progress > 0 ? Meta.MotionDirection.RIGHT : Meta.MotionDirection.LEFT;
     }
 
-    _startSwipeScroll() {
-        for (let i = 0; i < this._workspacesViews.length; i++)
-            this._workspacesViews[i].startSwipeScroll();
-        this._scrolling = true;
-    }
+    _switchWorkspaceBegin(tracker, monitor) {
+        if (this._workspacesOnlyOnPrimary && monitor != this._primaryIndex)
+            return;
 
-    _endSwipeScroll() {
-        for (let i = 0; i < this._workspacesViews.length; i++)
-            this._workspacesViews[i].endSwipeScroll();
-        this._scrolling = false;
-        this._scrollToActive();
-    }
+        let adjustment = this._scrollAdjustment;
+        if (this._gestureActive)
+            adjustment.remove_transition('value');
+
+        let horiz = global.workspace_manager.layout_rows != -1;
+        tracker.orientation = horiz ? Clutter.Orientation.HORIZONTAL : Clutter.Orientation.VERTICAL;
 
-    _startTouchGesture() {
         for (let i = 0; i < this._workspacesViews.length; i++)
             this._workspacesViews[i].startTouchGesture();
-        this._gestureActive = true;
-    }
 
-    _endTouchGesture() {
-        for (let i = 0; i < this._workspacesViews.length; i++)
-            this._workspacesViews[i].endTouchGesture();
-        this._gestureActive = false;
-        this._scrollToActive();
-    }
+        let workspaceManager = global.workspace_manager;
 
-    _onSwitchWorkspaceMotion(action, xRel, yRel) {
-        // We don't have a way to hook into start of touchpad actions,
-        // luckily this is safe to call repeatedly.
-        this._startTouchGesture();
+        let monitors = Main.layoutManager.monitors;
+        let geometry = monitor == this._primaryIndex ? this._fullGeometry : monitors[monitor];
+        let distance = global.workspace_manager.layout_rows == -1 ? geometry.height : geometry.width;
 
-        let workspaceManager = global.workspace_manager;
-        let active = workspaceManager.get_active_workspace_index();
+        let progress = adjustment.value / adjustment.page_size;
+        let points = [];
+
+        for (let i = 0; i < workspaceManager.n_workspaces; i++)
+            points.push(i);
+
+        tracker.confirmSwipe(distance, points, progress, Math.round(progress));
+
+        this._gestureActive = true;
+    }
+
+    _switchWorkspaceUpdate(_tracker, progress) {
         let adjustment = this._scrollAdjustment;
-        if (workspaceManager.layout_rows == -1)
-            adjustment.value = (active - yRel / this.actor.height) * adjustment.page_size;
-        else if (this.actor.text_direction == Clutter.TextDirection.RTL)
-            adjustment.value = (active + xRel / this.actor.width) * adjustment.page_size;
-        else
-            adjustment.value = (active - xRel / this.actor.width) * adjustment.page_size;
+        adjustment.value = progress * adjustment.page_size;
     }
 
-    _onSwitchWorkspaceActivated(action, direction) {
+    _switchWorkspaceEnd(_tracker, duration, endProgress) {
+        this._clickAction.release();
+
         let workspaceManager = global.workspace_manager;
         let activeWorkspace = workspaceManager.get_active_workspace();
-        let newWs = activeWorkspace.get_neighbor(direction);
-        if (newWs != activeWorkspace)
-            newWs.activate(global.get_current_time());
+        let newWs = workspaceManager.get_workspace_by_index(endProgress);
+
+        if (duration == 0) {
+            if (newWs != activeWorkspace)
+                newWs.activate(global.get_current_time());
+
+            this._endTouchGesture();
+            return;
+        }
 
-        this._endTouchGesture();
+        this._scrollAdjustment.ease(endProgress, {
+            mode: Clutter.AnimationMode.EASE_OUT_CUBIC,
+            duration,
+            onComplete: () => {
+                if (newWs != activeWorkspace)
+                    newWs.activate(global.get_current_time());
+                this._endTouchGesture();
+            },
+        });
+    }
+
+    _endTouchGesture() {
+        for (let i = 0; i < this._workspacesViews.length; i++)
+            this._workspacesViews[i].endTouchGesture();
+        this._gestureActive = false;
     }
 
     navigateFocus(from, direction) {
@@ -704,8 +668,6 @@ var WorkspacesDisplay = class {
             else
                 view = new WorkspacesView(i, this._scrollAdjustment);
 
-            view.actor.connect('scroll-event', this._onScrollEvent.bind(this));
-
             // HACK: Avoid spurious allocation changes while updating views
             view.actor.hide();
 
@@ -805,6 +767,9 @@ var WorkspacesDisplay = class {
     }
 
     _onScrollEvent(actor, event) {
+        if (this._swipeTracker.canHandleScrollEvent(event))
+            return Clutter.EVENT_PROPAGATE;
+
         if (!this.actor.mapped)
             return Clutter.EVENT_PROPAGATE;
 
-- 
2.23.0

From 26b212418d33d7a8542ce37ba6826ac644fa326d Mon Sep 17 00:00:00 2001
From: Alexander Mikhaylenko <alexm@gnome.org>
Date: Sun, 30 Jun 2019 17:15:37 +0500
Subject: [PATCH 29/36] appDisplay: Use SwipeTracker

Replace existing panning and touchpad scrolling by SwipeTracker.

Since SwipeTracker only references one actor, redirect scroll events
from page indicators to the main scroll view.

Change programmatic scroll animation to use easeOutCubic interpolator
to match the gesture.

https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/826
---
 js/ui/appDisplay.js | 122 +++++++++++++++++++++-----------------------
 1 file changed, 58 insertions(+), 64 deletions(-)

diff --git a/js/ui/appDisplay.js b/js/ui/appDisplay.js
index 759740485..e7979440c 100644
--- a/js/ui/appDisplay.js
+++ b/js/ui/appDisplay.js
@@ -13,6 +13,7 @@ const Main = imports.ui.main;
 const PageIndicators = imports.ui.pageIndicators;
 const PopupMenu = imports.ui.popupMenu;
 const Search = imports.ui.search;
+const SwipeTracker = imports.ui.swipeTracker;
 const Params = imports.misc.params;
 const Util = imports.misc.util;
 const SystemActions = imports.misc.systemActions;
@@ -301,7 +302,9 @@ var AllView = class AllView extends BaseAppView {
             (indicators, pageIndex) => {
                 this.goToPage(pageIndex);
             });
-        this._pageIndicators.connect('scroll-event', this._onScroll.bind(this));
+        this._pageIndicators.connect('scroll-event', (actor, event) => {
+            this._scrollView.event(event, false);
+        });
         this.actor.add_actor(this._pageIndicators);
 
         this.folderIcons = [];
@@ -319,13 +322,12 @@ var AllView = class AllView extends BaseAppView {
 
         this._scrollView.connect('scroll-event', this._onScroll.bind(this));
 
-        let panAction = new Clutter.PanAction({ interpolate: false });
-        panAction.connect('pan', this._onPan.bind(this));
-        panAction.connect('gesture-cancel', this._onPanEnd.bind(this));
-        panAction.connect('gesture-end', this._onPanEnd.bind(this));
-        this._panAction = panAction;
-        this._scrollView.add_action(panAction);
-        this._panning = false;
+        let allowedModes = Shell.ActionMode.OVERVIEW;
+        this._swipeTracker = new SwipeTracker.SwipeTracker(this._scrollView, allowedModes);
+        this._swipeTracker.connect('begin', this._swipeBegin.bind(this));
+        this._swipeTracker.connect('update', this._swipeUpdate.bind(this));
+        this._swipeTracker.connect('end', this._swipeEnd.bind(this));
+
         this._clickAction = new Clutter.ClickAction();
         this._clickAction.connect('clicked', () => {
             if (!this._currentPopup)
@@ -369,6 +371,7 @@ var AllView = class AllView extends BaseAppView {
                     global.stage.disconnect(this._keyPressEventId);
                 this._keyPressEventId = 0;
             }
+            this._swipeTracker.enabled = true;
         });
 
         this._redisplayWorkId = Main.initializeDeferredWork(this.actor, this._redisplay.bind(this));
@@ -531,7 +534,7 @@ var AllView = class AllView extends BaseAppView {
         return this._grid.getPageY(this._grid.currentPage);
     }
 
-    goToPage(pageNumber) {
+    goToPage(pageNumber, animate = true) {
         pageNumber = clamp(pageNumber, 0, this._grid.nPages() - 1);
 
         if (this._grid.currentPage == pageNumber && this._displayingPopup && this._currentPopup)
@@ -546,42 +549,20 @@ var AllView = class AllView extends BaseAppView {
             return;
         }
 
-        let velocity;
-        if (!this._panning)
-            velocity = 0;
-        else
-            velocity = Math.abs(this._panAction.get_velocity(0)[2]);
-        // Tween the change between pages.
-        // If velocity is not specified (i.e. scrolling with mouse wheel),
-        // use the same speed regardless of original position
-        // if velocity is specified, it's in pixels per milliseconds
-        let diffToPage = this._diffToPage(pageNumber);
-        let childBox = this._scrollView.get_allocation_box();
-        let totalHeight = childBox.y2 - childBox.y1;
-        let time;
-        // Only take the velocity into account on page changes, otherwise
-        // return smoothly to the current page using the default velocity
-        if (this._grid.currentPage != pageNumber) {
-            let minVelocity = totalHeight / PAGE_SWITCH_TIME;
-            velocity = Math.max(minVelocity, velocity);
-            time = diffToPage / velocity;
-        } else {
-            time = PAGE_SWITCH_TIME * diffToPage / totalHeight;
-        }
-        // When changing more than one page, make sure to not take
-        // longer than PAGE_SWITCH_TIME
-        time = Math.min(time, PAGE_SWITCH_TIME);
+        if (this._grid.currentPage == pageNumber)
+            return;
 
         this._grid.currentPage = pageNumber;
-        this._adjustment.ease(this._grid.getPageY(pageNumber), {
-            mode: Clutter.AnimationMode.EASE_OUT_QUAD,
-            duration: time
-        });
-    }
-
-    _diffToPage(pageNumber) {
-        let currentScrollPosition = this._adjustment.value;
-        return Math.abs(currentScrollPosition - this._grid.getPageY(pageNumber));
+        if (animate) {
+            // Tween the change between pages.
+            this._adjustment.ease(this._grid.getPageY(this._grid.currentPage), {
+                mode: Clutter.AnimationMode.EASE_OUT_CUBIC,
+                duration: PAGE_SWITCH_TIME,
+            });
+        } else {
+            this._adjustment.remove_transition('value');
+            this._adjustment.value = this._grid.getPageY(this._grid.currentPage);
+        }
     }
 
     openSpaceForPopup(item, side, nRows) {
@@ -604,6 +585,9 @@ var AllView = class AllView extends BaseAppView {
         if (this._displayingPopup || !this._scrollView.reactive)
             return Clutter.EVENT_STOP;
 
+        if (this._swipeTracker.canHandleScrollEvent(event))
+            return Clutter.EVENT_PROPAGATE;
+
         if (!this._canScroll)
             return Clutter.EVENT_STOP;
 
@@ -625,34 +609,44 @@ var AllView = class AllView extends BaseAppView {
         return Clutter.EVENT_STOP;
     }
 
-    _onPan(action) {
-        if (this._displayingPopup)
-            return false;
-        this._panning = true;
-        this._clickAction.release();
-        let [dist_, dx_, dy] = action.get_motion_delta(0);
+    _swipeBegin(tracker, monitor) {
+        if (monitor != Main.layoutManager.primaryIndex)
+            return;
+
         let adjustment = this._adjustment;
-        adjustment.value -= (dy / this._scrollView.height) * adjustment.page_size;
-        return false;
-    }
+        if (adjustment.get_transition("value") !== null)
+            adjustment.remove_transition('value');
 
-    _onPanEnd(action) {
-        if (this._displayingPopup)
-            return;
+        let progress = adjustment.value / adjustment.page_size;
 
-        let pageHeight = this._grid.getPageHeight();
+        let points = [];
+        for (let i = 0; i < this._grid.nPages(); i++)
+            points.push(i);
 
-        // Calculate the scroll value we'd be at, which is our current
-        // scroll plus any velocity the user had when they released
-        // their finger.
+        tracker.confirmSwipe(this._scrollView.height, points, progress, Math.round(progress));
+    }
+
+    _swipeUpdate(_tracker, progress) {
+        let adjustment = this._adjustment;
+        adjustment.value = progress * adjustment.page_size;
+    }
 
-        let velocity = -action.get_velocity(0)[2];
-        let endPanValue = this._adjustment.value + velocity;
+    _swipeEnd(_tracker, duration, endProgress) {
+        let adjustment = this._adjustment;
+        let value = endProgress * adjustment.page_size;
 
-        let closestPage = Math.round(endPanValue / pageHeight);
-        this.goToPage(closestPage);
+        if (duration == 0) {
+            this.goToPage(endProgress, false);
+            return;
+        }
 
-        this._panning = false;
+        adjustment.ease(value, {
+            mode: Clutter.AnimationMode.EASE_OUT_CUBIC,
+            duration,
+            onComplete: () => {
+                this.goToPage(endProgress, false);
+            },
+        });
     }
 
     _onKeyPressEvent(actor, event) {
-- 
2.23.0

From 61f1147cb07d044f5f012b703879128f02ec7edb Mon Sep 17 00:00:00 2001
From: Alexander Mikhaylenko <alexm@gnome.org>
Date: Sun, 30 Jun 2019 17:15:44 +0500
Subject: [PATCH 30/36] windowManager: Use SwipeTracker

Replace existing four-finger gestures with SwipeTracker.

Since TouchpadWorkspaceSwitchAction and WorkspaceSwitchAction are now
unused, remove them.

Change programmatic workspace transition to use easeOutCubic interpolator
to match the gesture.

Fixes https://gitlab.gnome.org/GNOME/gnome-shell/issues/756

https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/826
---
 js/ui/windowManager.js | 376 ++++++++++++++++++-----------------------
 1 file changed, 167 insertions(+), 209 deletions(-)

diff --git a/js/ui/windowManager.js b/js/ui/windowManager.js
index 7ea2b8154..41eb18ec3 100644
--- a/js/ui/windowManager.js
+++ b/js/ui/windowManager.js
@@ -2,7 +2,6 @@
 /* exported WindowManager */
 
 const { Clutter, Gio, GLib, GObject, Meta, Shell, St } = imports.gi;
-const Signals = imports.signals;
 
 const AltTab = imports.ui.altTab;
 const AppFavorites = imports.ui.appFavorites;
@@ -15,6 +14,7 @@ const WindowMenu = imports.ui.windowMenu;
 const PadOsd = imports.ui.padOsd;
 const EdgeDragAction = imports.ui.edgeDragAction;
 const CloseDialog = imports.ui.closeDialog;
+const SwipeTracker = imports.ui.swipeTracker;
 const SwitchMonitor = imports.ui.switchMonitor;
 const IBusManager = imports.misc.ibusManager;
 
@@ -30,7 +30,6 @@ var WINDOW_ANIMATION_TIME = 250;
 var DIM_BRIGHTNESS = -0.3;
 var DIM_TIME = 500;
 var UNDIM_TIME = 250;
-var MOTION_THRESHOLD = 100;
 
 var ONE_SECOND = 1000; // in ms
 
@@ -464,147 +463,6 @@ var TilePreview = class {
     }
 };
 
-var TouchpadWorkspaceSwitchAction = class {
-    constructor(actor, allowedModes) {
-        this._allowedModes = allowedModes;
-        this._dx = 0;
-        this._dy = 0;
-        this._enabled = true;
-        actor.connect('captured-event', this._handleEvent.bind(this));
-        this._touchpadSettings = new Gio.Settings({ schema_id: 'org.gnome.desktop.peripherals.touchpad' });
-    }
-
-    get enabled() {
-        return this._enabled;
-    }
-
-    set enabled(enabled) {
-        if (this._enabled == enabled)
-            return;
-
-        this._enabled = enabled;
-        if (!enabled)
-            this.emit('cancel');
-    }
-
-    _checkActivated() {
-        let dir;
-
-        if (this._dy < -MOTION_THRESHOLD)
-            dir = Meta.MotionDirection.DOWN;
-        else if (this._dy > MOTION_THRESHOLD)
-            dir = Meta.MotionDirection.UP;
-        else if (this._dx < -MOTION_THRESHOLD)
-            dir = Meta.MotionDirection.RIGHT;
-        else if (this._dx > MOTION_THRESHOLD)
-            dir = Meta.MotionDirection.LEFT;
-        else
-            return false;
-
-        this.emit('activated', dir);
-        return true;
-    }
-
-    _handleEvent(actor, event) {
-        if (event.type() != Clutter.EventType.TOUCHPAD_SWIPE)
-            return Clutter.EVENT_PROPAGATE;
-
-        if (event.get_touchpad_gesture_finger_count() != 4)
-            return Clutter.EVENT_PROPAGATE;
-
-        if ((this._allowedModes & Main.actionMode) == 0)
-            return Clutter.EVENT_PROPAGATE;
-
-        if (!this._enabled)
-            return Clutter.EVENT_PROPAGATE;
-
-        if (event.get_gesture_phase() == Clutter.TouchpadGesturePhase.UPDATE) {
-            let [dx, dy] = event.get_gesture_motion_delta();
-
-            // Scale deltas up a bit to make it feel snappier
-            this._dx += dx * 2;
-            if (!(this._touchpadSettings.get_boolean('natural-scroll')))
-                this._dy -= dy * 2;
-            else
-                this._dy += dy * 2;
-
-            this.emit('motion', this._dx, this._dy);
-        } else {
-            if ((event.get_gesture_phase() == Clutter.TouchpadGesturePhase.END && ! this._checkActivated()) ||
-                event.get_gesture_phase() == Clutter.TouchpadGesturePhase.CANCEL)
-                this.emit('cancel');
-
-            this._dx = 0;
-            this._dy = 0;
-        }
-
-        return Clutter.EVENT_STOP;
-    }
-};
-Signals.addSignalMethods(TouchpadWorkspaceSwitchAction.prototype);
-
-var WorkspaceSwitchAction = GObject.registerClass({
-    Signals: { 'activated': { param_types: [Meta.MotionDirection.$gtype] },
-               'motion':    { param_types: [GObject.TYPE_DOUBLE, GObject.TYPE_DOUBLE] },
-               'cancel':    { param_types: [] } },
-}, class WorkspaceSwitchAction extends Clutter.SwipeAction {
-    _init(allowedModes) {
-        super._init();
-        this.set_n_touch_points(4);
-        this._swept = false;
-        this._allowedModes = allowedModes;
-
-        global.display.connect('grab-op-begin', () => {
-            this.cancel();
-        });
-    }
-
-    vfunc_gesture_prepare(actor) {
-        this._swept = false;
-
-        if (!super.vfunc_gesture_prepare(actor))
-            return false;
-
-        return (this._allowedModes & Main.actionMode);
-    }
-
-    vfunc_gesture_progress(_actor) {
-        let [x, y] = this.get_motion_coords(0);
-        let [xPress, yPress] = this.get_press_coords(0);
-        this.emit('motion', x - xPress, y - yPress);
-        return true;
-    }
-
-    vfunc_gesture_cancel(_actor) {
-        if (!this._swept)
-            this.emit('cancel');
-    }
-
-    vfunc_swipe(actor, direction) {
-        let [x, y] = this.get_motion_coords(0);
-        let [xPress, yPress] = this.get_press_coords(0);
-        if (Math.abs(x - xPress) < MOTION_THRESHOLD &&
-            Math.abs(y - yPress) < MOTION_THRESHOLD) {
-            this.emit('cancel');
-            return;
-        }
-
-        let dir;
-
-        if (direction & Clutter.SwipeDirection.UP)
-            dir = Meta.MotionDirection.DOWN;
-        else if (direction & Clutter.SwipeDirection.DOWN)
-            dir = Meta.MotionDirection.UP;
-        else if (direction & Clutter.SwipeDirection.LEFT)
-            dir = Meta.MotionDirection.RIGHT;
-        else if (direction & Clutter.SwipeDirection.RIGHT)
-            dir = Meta.MotionDirection.LEFT;
-
-        this._swept = true;
-        this.emit('activated', dir);
-    }
-});
-
 var AppSwitchAction = GObject.registerClass({
     Signals: { 'activated': {} },
 }, class AppSwitchAction extends Clutter.GestureAction {
@@ -1056,10 +914,17 @@ var WindowManager = class {
         Main.overview.connect('showing', () => {
             for (let i = 0; i < this._dimmedWindows.length; i++)
                 this._undimWindow(this._dimmedWindows[i]);
+
+            if (this._switchData) {
+                if (this._switchData.gestureActivated)
+                    this._switchWorkspaceStop();
+                this._swipeTracker.enabled = false;
+            }
         });
         Main.overview.connect('hiding', () => {
             for (let i = 0; i < this._dimmedWindows.length; i++)
                 this._dimWindow(this._dimmedWindows[i]);
+            this._swipeTracker.enabled = true;
         });
 
         this._windowMenuManager = new WindowMenu.WindowMenuManager();
@@ -1071,17 +936,11 @@ var WindowManager = class {
                                                            false, -1, 1);
 
         let allowedModes = Shell.ActionMode.NORMAL;
-        let workspaceSwitchAction = new WorkspaceSwitchAction(allowedModes);
-        workspaceSwitchAction.connect('motion', this._switchWorkspaceMotion.bind(this));
-        workspaceSwitchAction.connect('activated', this._actionSwitchWorkspace.bind(this));
-        workspaceSwitchAction.connect('cancel', this._switchWorkspaceCancel.bind(this));
-        global.stage.add_action(workspaceSwitchAction);
-
-        // This is not a normal Clutter.GestureAction, doesn't need add_action()
-        let touchpadSwitchAction = new TouchpadWorkspaceSwitchAction(global.stage, allowedModes);
-        touchpadSwitchAction.connect('motion', this._switchWorkspaceMotion.bind(this));
-        touchpadSwitchAction.connect('activated', this._actionSwitchWorkspace.bind(this));
-        touchpadSwitchAction.connect('cancel', this._switchWorkspaceCancel.bind(this));
+        let swipeTracker = new SwipeTracker.SwipeTracker(global.stage, allowedModes, false, false);
+        swipeTracker.connect('begin', this._switchWorkspaceBegin.bind(this));
+        swipeTracker.connect('update', this._switchWorkspaceUpdate.bind(this));
+        swipeTracker.connect('end', this._switchWorkspaceEnd.bind(this));
+        this._swipeTracker = swipeTracker;
 
         let appSwitchAction = new AppSwitchAction();
         appSwitchAction.connect('activated', this._switchApp.bind(this));
@@ -1123,52 +982,6 @@ var WindowManager = class {
         return this._currentPadOsd.actor;
     }
 
-    _switchWorkspaceMotion(action, xRel, yRel) {
-        let workspaceManager = global.workspace_manager;
-        let activeWorkspace = workspaceManager.get_active_workspace();
-
-        if (!this._switchData)
-            this._prepareWorkspaceSwitch(activeWorkspace.index(), -1);
-
-        if (yRel < 0 && !this._switchData.surroundings[Meta.MotionDirection.DOWN])
-            yRel = 0;
-        if (yRel > 0 && !this._switchData.surroundings[Meta.MotionDirection.UP])
-            yRel = 0;
-        if (xRel < 0 && !this._switchData.surroundings[Meta.MotionDirection.RIGHT])
-            xRel = 0;
-        if (xRel > 0 && !this._switchData.surroundings[Meta.MotionDirection.LEFT])
-            xRel = 0;
-
-        this._switchData.container.set_position(xRel, yRel);
-    }
-
-    _switchWorkspaceCancel() {
-        if (!this._switchData || this._switchData.inProgress)
-            return;
-        let switchData = this._switchData;
-        this._switchData = null;
-        switchData.container.ease({
-            x: 0,
-            y: 0,
-            duration: WINDOW_ANIMATION_TIME,
-            mode: Clutter.AnimationMode.EASE_OUT_QUAD,
-            onComplete: () => this._finishWorkspaceSwitch(switchData)
-        });
-    }
-
-    _actionSwitchWorkspace(action, direction) {
-        let workspaceManager = global.workspace_manager;
-        let activeWorkspace = workspaceManager.get_active_workspace();
-        let newWs = activeWorkspace.get_neighbor(direction);
-
-        if (newWs == activeWorkspace) {
-            this._switchWorkspaceCancel();
-        } else {
-            this._switchData.gestureActivated = true;
-            this.actionMoveWorkspace(newWs);
-        }
-    }
-
     _lookupIndex(windows, metaWindow) {
         for (let i = 0; i < windows.length; i++) {
             if (windows[i].metaWindow == metaWindow) {
@@ -1283,7 +1096,7 @@ var WindowManager = class {
     }
 
     _shouldAnimate() {
-        return !Main.overview.visible;
+        return !(Main.overview.visible || (this._switchData && this._switchData.gestureActivated));
     }
 
     _shouldAnimateActor(actor, types) {
@@ -1921,13 +1734,15 @@ var WindowManager = class {
                 continue;
             }
 
+            let [x, y] = this._getPositionForDirection(dir, curWs, ws);
             let info = { index: ws.index(),
-                         actor: new Clutter.Actor() };
+                         actor: new Clutter.Actor(),
+                         xDest: x,
+                         yDest: y };
             switchData.surroundings[dir] = info;
             switchData.container.add_actor(info.actor);
             info.actor.raise_top();
 
-            let [x, y] = this._getPositionForDirection(dir, curWs, ws);
             info.actor.set_position(x, y);
         }
 
@@ -2005,11 +1820,7 @@ var WindowManager = class {
             return;
         }
 
-        // If we come from a gesture, switchData will already be set,
-        // and we don't want to overwrite it.
-        if (!this._switchData)
-            this._prepareWorkspaceSwitch(from, to, direction);
-
+        this._prepareWorkspaceSwitch(from, to, direction);
         this._switchData.inProgress = true;
 
         let workspaceManager = global.workspace_manager;
@@ -2029,7 +1840,7 @@ var WindowManager = class {
             x: xDest,
             y: yDest,
             duration: WINDOW_ANIMATION_TIME,
-            mode: Clutter.AnimationMode.EASE_OUT_QUAD,
+            mode: Clutter.AnimationMode.EASE_OUT_CUBIC,
             onComplete: () => this._switchWorkspaceDone(shellwm)
         });
     }
@@ -2039,6 +1850,153 @@ var WindowManager = class {
         shellwm.completed_switch_workspace();
     }
 
+    _directionForProgress(progress) {
+        if (global.workspace_manager.layout_rows == -1)
+            return progress > 0 ? Meta.MotionDirection.DOWN : Meta.MotionDirection.UP;
+        else if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
+            return progress > 0 ? Meta.MotionDirection.LEFT : Meta.MotionDirection.RIGHT;
+        else
+            return progress > 0 ? Meta.MotionDirection.RIGHT : Meta.MotionDirection.LEFT;
+    }
+
+    _getProgressRange() {
+        if (!this._switchData)
+            return [0, 0];
+
+        let lower = 0;
+        let upper = 0;
+
+        let horiz = global.workspace_manager.layout_rows != -1;
+        let baseDistance;
+        if (horiz)
+            baseDistance = global.screen_width;
+        else
+            baseDistance = global.screen_height;
+
+        let direction = this._directionForProgress(-1);
+        let info = this._switchData.surroundings[direction];
+        if (info != null) {
+            let distance = horiz ? info.xDest : info.yDest;
+            lower = -Math.abs(distance) / baseDistance;
+        }
+
+        direction = this._directionForProgress(1);
+        info = this._switchData.surroundings[direction];
+        if (info != null) {
+            let distance = horiz ? info.xDest : info.yDest;
+            upper = Math.abs(distance) / baseDistance;
+        }
+
+        return [lower, upper];
+    }
+
+    _switchWorkspaceBegin(tracker, monitor) {
+        if (Meta.prefs_get_workspaces_only_on_primary() && monitor != Main.layoutManager.primaryIndex)
+            return;
+
+        let horiz = global.workspace_manager.layout_rows != -1;
+        tracker.orientation = horiz ? Clutter.Orientation.HORIZONTAL : Clutter.Orientation.VERTICAL;
+
+        let workspaceManager = global.workspace_manager;
+        let activeWorkspace = workspaceManager.get_active_workspace();
+
+        let baseDistance;
+        if (horiz)
+            baseDistance = global.screen_width;
+        else
+            baseDistance = global.screen_height;
+
+        let progress;
+        if (this._switchData && this._switchData.gestureActivated) {
+            this._switchData.container.remove_all_transitions();
+            if (!horiz)
+                progress = -this._switchData.container.y / baseDistance;
+            else if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
+                progress = this._switchData.container.x / baseDistance;
+            else
+                progress = -this._switchData.container.x / baseDistance;
+        } else {
+            this._prepareWorkspaceSwitch(activeWorkspace.index(), -1);
+            progress = 0;
+        }
+
+        let points = [];
+        let [lower, upper] = this._getProgressRange();
+
+        if (lower != 0)
+            points.push(lower);
+
+        points.push(0);
+
+        if (upper != 0)
+            points.push(upper);
+
+        tracker.confirmSwipe(baseDistance, points, progress, 0);
+    }
+
+    _switchWorkspaceUpdate(_tracker, progress) {
+        if (!this._switchData)
+            return;
+
+        let direction = this._directionForProgress(progress);
+        let info = this._switchData.surroundings[direction];
+        let xPos = 0;
+        let yPos = 0;
+        if (info) {
+            if (global.workspace_manager.layout_rows == -1)
+                yPos = Math.round(Math.abs(progress) * -info.yDest);
+            else
+                xPos = Math.round(Math.abs(progress) * -info.xDest);
+        }
+
+        this._switchData.container.set_position(xPos, yPos);
+    }
+
+    _switchWorkspaceEnd(_tracker, duration, endProgress) {
+        if (!this._switchData)
+            return;
+
+        let workspaceManager = global.workspace_manager;
+        let activeWorkspace = workspaceManager.get_active_workspace();
+        let newWs = activeWorkspace;
+        let xDest = 0;
+        let yDest = 0;
+        if (endProgress != 0) {
+            let direction = this._directionForProgress(endProgress);
+            newWs = activeWorkspace.get_neighbor(direction);
+            xDest = -this._switchData.surroundings[direction].xDest;
+            yDest = -this._switchData.surroundings[direction].yDest;
+        }
+
+        if (duration == 0) {
+            if (newWs != activeWorkspace)
+                this.actionMoveWorkspace(newWs);
+            this._switchWorkspaceStop();
+            return;
+        }
+
+        let switchData = this._switchData;
+        switchData.gestureActivated = true;
+
+        this._switchData.container.ease({
+            x: xDest,
+            y: yDest,
+            duration,
+            mode: Clutter.AnimationMode.EASE_OUT_CUBIC,
+            onComplete: () => {
+                if (newWs != activeWorkspace)
+                    this.actionMoveWorkspace(newWs);
+                this._finishWorkspaceSwitch(switchData);
+            },
+        });
+    }
+
+    _switchWorkspaceStop() {
+        this._switchData.container.x = 0;
+        this._switchData.container.y = 0;
+        this._finishWorkspaceSwitch(this._switchData);
+    }
+
     _showTilePreview(shellwm, window, tileRect, monitorIndex) {
         if (!this._tilePreview)
             this._tilePreview = new TilePreview();
-- 
2.23.0

From 9c6e126f871a3c3af701e85c37dd25139798d420 Mon Sep 17 00:00:00 2001
From: Alexander Mikhaylenko <alexm@gnome.org>
Date: Tue, 2 Jul 2019 22:28:47 +0500
Subject: [PATCH 31/36] workspaceAnimation: Split from WindowManager

It's already too complex, and will get more complex in future, split it
out.

https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/605
---
 js/js-resources.gresource.xml |   1 +
 js/ui/windowManager.js        | 389 +------------------------------
 js/ui/workspaceAnimation.js   | 419 ++++++++++++++++++++++++++++++++++
 3 files changed, 426 insertions(+), 383 deletions(-)
 create mode 100644 js/ui/workspaceAnimation.js

diff --git a/js/js-resources.gresource.xml b/js/js-resources.gresource.xml
index aec3427e0..938e2c489 100644
--- a/js/js-resources.gresource.xml
+++ b/js/js-resources.gresource.xml
@@ -109,6 +109,7 @@
     <file>ui/windowMenu.js</file>
     <file>ui/windowManager.js</file>
     <file>ui/workspace.js</file>
+    <file>ui/workspaceAnimation.js</file>
     <file>ui/workspaceSwitcherPopup.js</file>
     <file>ui/workspaceThumbnail.js</file>
     <file>ui/workspacesView.js</file>
diff --git a/js/ui/windowManager.js b/js/ui/windowManager.js
index 41eb18ec3..b523f6fe8 100644
--- a/js/ui/windowManager.js
+++ b/js/ui/windowManager.js
@@ -14,9 +14,9 @@ const WindowMenu = imports.ui.windowMenu;
 const PadOsd = imports.ui.padOsd;
 const EdgeDragAction = imports.ui.edgeDragAction;
 const CloseDialog = imports.ui.closeDialog;
-const SwipeTracker = imports.ui.swipeTracker;
 const SwitchMonitor = imports.ui.switchMonitor;
 const IBusManager = imports.misc.ibusManager;
+const WorkspaceAnimation = imports.ui.workspaceAnimation;
 
 const { loadInterfaceXML } = imports.misc.fileUtils;
 
@@ -564,7 +564,6 @@ var WindowManager = class {
         this._resizing = new Set();
         this._resizePending = new Set();
         this._destroying = new Set();
-        this._movingWindow = null;
 
         this._dimmedWindows = [];
 
@@ -574,15 +573,6 @@ var WindowManager = class {
 
         this._isWorkspacePrepended = false;
 
-        this._switchData = null;
-        this._shellwm.connect('kill-switch-workspace', shellwm => {
-            if (this._switchData) {
-                if (this._switchData.inProgress)
-                    this._switchWorkspaceDone(shellwm);
-                else if (!this._switchData.gestureActivated)
-                    this._finishWorkspaceSwitch(this._switchData);
-            }
-        });
         this._shellwm.connect('kill-window-effects', (shellwm, actor) => {
             this._minimizeWindowDone(shellwm, actor);
             this._mapWindowDone(shellwm, actor);
@@ -604,7 +594,6 @@ var WindowManager = class {
         this._shellwm.connect('confirm-display-change', this._confirmDisplayChange.bind(this));
         this._shellwm.connect('create-close-dialog', this._createCloseDialog.bind(this));
         this._shellwm.connect('create-inhibit-shortcuts-dialog', this._createInhibitShortcutsDialog.bind(this));
-        global.display.connect('restacked', this._syncStacking.bind(this));
 
         this._workspaceSwitcherPopup = null;
         this._tilePreview = null;
@@ -914,17 +903,10 @@ var WindowManager = class {
         Main.overview.connect('showing', () => {
             for (let i = 0; i < this._dimmedWindows.length; i++)
                 this._undimWindow(this._dimmedWindows[i]);
-
-            if (this._switchData) {
-                if (this._switchData.gestureActivated)
-                    this._switchWorkspaceStop();
-                this._swipeTracker.enabled = false;
-            }
         });
         Main.overview.connect('hiding', () => {
             for (let i = 0; i < this._dimmedWindows.length; i++)
                 this._dimWindow(this._dimmedWindows[i]);
-            this._swipeTracker.enabled = true;
         });
 
         this._windowMenuManager = new WindowMenu.WindowMenuManager();
@@ -935,13 +917,6 @@ var WindowManager = class {
         global.workspace_manager.override_workspace_layout(Meta.DisplayCorner.TOPLEFT,
                                                            false, -1, 1);
 
-        let allowedModes = Shell.ActionMode.NORMAL;
-        let swipeTracker = new SwipeTracker.SwipeTracker(global.stage, allowedModes, false, false);
-        swipeTracker.connect('begin', this._switchWorkspaceBegin.bind(this));
-        swipeTracker.connect('update', this._switchWorkspaceUpdate.bind(this));
-        swipeTracker.connect('end', this._switchWorkspaceEnd.bind(this));
-        this._swipeTracker = swipeTracker;
-
         let appSwitchAction = new AppSwitchAction();
         appSwitchAction.connect('activated', this._switchApp.bind(this));
         global.stage.add_action(appSwitchAction);
@@ -973,6 +948,8 @@ var WindowManager = class {
         global.display.connect('in-fullscreen-changed', updateUnfullscreenGesture);
 
         global.stage.add_action(topDragAction);
+
+        this._workspaceAnimation = new WorkspaceAnimation.WorkspaceAnimationController();
     }
 
     _showPadOsd(display, device, settings, imagePath, editionMode, monitorIndex) {
@@ -1096,7 +1073,7 @@ var WindowManager = class {
     }
 
     _shouldAnimate() {
-        return !(Main.overview.visible || (this._switchData && this._switchData.gestureActivated));
+        return !(Main.overview.visible || this._workspaceAnimation.isAnimating());
     }
 
     _shouldAnimateActor(actor, types) {
@@ -1635,366 +1612,12 @@ var WindowManager = class {
         return !(this._allowedKeybindings[binding.get_name()] & Main.actionMode);
     }
 
-    _syncStacking() {
-        if (this._switchData == null)
-            return;
-
-        let windows = global.get_window_actors();
-        let lastCurSibling = null;
-        let lastDirSibling = [];
-        for (let i = 0; i < windows.length; i++) {
-            if (windows[i].get_parent() == this._switchData.curGroup) {
-                this._switchData.curGroup.set_child_above_sibling(windows[i], lastCurSibling);
-                lastCurSibling = windows[i];
-            } else {
-                for (let dir of Object.values(Meta.MotionDirection)) {
-                    let info = this._switchData.surroundings[dir];
-                    if (!info || windows[i].get_parent() != info.actor)
-                        continue;
-
-                    let sibling = lastDirSibling[dir];
-                    if (sibling == undefined)
-                        sibling = null;
-
-                    info.actor.set_child_above_sibling(windows[i], sibling);
-                    lastDirSibling[dir] = windows[i];
-                    break;
-                }
-            }
-        }
-    }
-
-    _getPositionForDirection(direction, fromWs, toWs) {
-        let xDest = 0, yDest = 0;
-
-        let oldWsIsFullscreen = fromWs.list_windows().some(w => w.is_fullscreen());
-        let newWsIsFullscreen = toWs.list_windows().some(w => w.is_fullscreen());
-
-        // We have to shift windows up or down by the height of the panel to prevent having a
-        // visible gap between the windows while switching workspaces. Since fullscreen windows
-        // hide the panel, they don't need to be shifted up or down.
-        let shiftHeight = Main.panel.height;
-
-        if (direction == Meta.MotionDirection.UP ||
-            direction == Meta.MotionDirection.UP_LEFT ||
-            direction == Meta.MotionDirection.UP_RIGHT)
-            yDest = -global.screen_height + (oldWsIsFullscreen ? 0 : shiftHeight);
-        else if (direction == Meta.MotionDirection.DOWN ||
-            direction == Meta.MotionDirection.DOWN_LEFT ||
-            direction == Meta.MotionDirection.DOWN_RIGHT)
-            yDest = global.screen_height - (newWsIsFullscreen ? 0 : shiftHeight);
-
-        if (direction == Meta.MotionDirection.LEFT ||
-            direction == Meta.MotionDirection.UP_LEFT ||
-            direction == Meta.MotionDirection.DOWN_LEFT)
-            xDest = -global.screen_width;
-        else if (direction == Meta.MotionDirection.RIGHT ||
-                 direction == Meta.MotionDirection.UP_RIGHT ||
-                 direction == Meta.MotionDirection.DOWN_RIGHT)
-            xDest = global.screen_width;
-
-        return [xDest, yDest];
-    }
-
-    _prepareWorkspaceSwitch(from, to, direction) {
-        if (this._switchData)
-            return;
-
-        let wgroup = global.window_group;
-        let windows = global.get_window_actors();
-        let switchData = {};
-
-        this._switchData = switchData;
-        switchData.curGroup = new Clutter.Actor();
-        switchData.movingWindowBin = new Clutter.Actor();
-        switchData.windows = [];
-        switchData.surroundings = {};
-        switchData.gestureActivated = false;
-        switchData.inProgress = false;
-
-        switchData.container = new Clutter.Actor();
-        switchData.container.add_actor(switchData.curGroup);
-
-        wgroup.add_actor(switchData.movingWindowBin);
-        wgroup.add_actor(switchData.container);
-
-        let workspaceManager = global.workspace_manager;
-        let curWs = workspaceManager.get_workspace_by_index (from);
-
-        for (let dir of Object.values(Meta.MotionDirection)) {
-            let ws = null;
-
-            if (to < 0)
-                ws = curWs.get_neighbor(dir);
-            else if (dir == direction)
-                ws = workspaceManager.get_workspace_by_index(to);
-
-            if (ws == null || ws == curWs) {
-                switchData.surroundings[dir] = null;
-                continue;
-            }
-
-            let [x, y] = this._getPositionForDirection(dir, curWs, ws);
-            let info = { index: ws.index(),
-                         actor: new Clutter.Actor(),
-                         xDest: x,
-                         yDest: y };
-            switchData.surroundings[dir] = info;
-            switchData.container.add_actor(info.actor);
-            info.actor.raise_top();
-
-            info.actor.set_position(x, y);
-        }
-
-        switchData.movingWindowBin.raise_top();
-
-        for (let i = 0; i < windows.length; i++) {
-            let actor = windows[i];
-            let window = actor.get_meta_window();
-
-            if (!window.showing_on_its_workspace())
-                continue;
-
-            if (window.is_on_all_workspaces())
-                continue;
-
-            let record = { window: actor,
-                           parent: actor.get_parent() };
-
-            if (this._movingWindow && window == this._movingWindow) {
-                switchData.movingWindow = record;
-                switchData.windows.push(switchData.movingWindow);
-                actor.reparent(switchData.movingWindowBin);
-            } else if (window.get_workspace().index() == from) {
-                switchData.windows.push(record);
-                actor.reparent(switchData.curGroup);
-            } else {
-                let visible = false;
-                for (let dir of Object.values(Meta.MotionDirection)) {
-                    let info = switchData.surroundings[dir];
-
-                    if (!info || info.index != window.get_workspace().index())
-                        continue;
-
-                    switchData.windows.push(record);
-                    actor.reparent(info.actor);
-                    visible = true;
-                    break;
-                }
-
-                actor.visible = visible;
-            }
-        }
-
-        for (let i = 0; i < switchData.windows.length; i++) {
-            let w = switchData.windows[i];
-
-            w.windowDestroyId = w.window.connect('destroy', () => {
-                switchData.windows.splice(switchData.windows.indexOf(w), 1);
-            });
-        }
-    }
-
-    _finishWorkspaceSwitch(switchData) {
-        this._switchData = null;
-
-        for (let i = 0; i < switchData.windows.length; i++) {
-            let w = switchData.windows[i];
-
-            w.window.disconnect(w.windowDestroyId);
-            w.window.reparent(w.parent);
-
-            if (w.window.get_meta_window().get_workspace() !=
-                global.workspace_manager.get_active_workspace())
-                w.window.hide();
-        }
-        switchData.container.destroy();
-        switchData.movingWindowBin.destroy();
-
-        this._movingWindow = null;
-    }
-
     _switchWorkspace(shellwm, from, to, direction) {
         if (!Main.sessionMode.hasWorkspaces || !this._shouldAnimate()) {
             shellwm.completed_switch_workspace();
             return;
         }
-
-        this._prepareWorkspaceSwitch(from, to, direction);
-        this._switchData.inProgress = true;
-
-        let workspaceManager = global.workspace_manager;
-        let fromWs = workspaceManager.get_workspace_by_index(from);
-        let toWs = workspaceManager.get_workspace_by_index(to);
-
-        let [xDest, yDest] = this._getPositionForDirection(direction, fromWs, toWs);
-
-        /* @direction is the direction that the "camera" moves, so the
-         * screen contents have to move one screen's worth in the
-         * opposite direction.
-         */
-        xDest = -xDest;
-        yDest = -yDest;
-
-        this._switchData.container.ease({
-            x: xDest,
-            y: yDest,
-            duration: WINDOW_ANIMATION_TIME,
-            mode: Clutter.AnimationMode.EASE_OUT_CUBIC,
-            onComplete: () => this._switchWorkspaceDone(shellwm)
-        });
-    }
-
-    _switchWorkspaceDone(shellwm) {
-        this._finishWorkspaceSwitch(this._switchData);
-        shellwm.completed_switch_workspace();
-    }
-
-    _directionForProgress(progress) {
-        if (global.workspace_manager.layout_rows == -1)
-            return progress > 0 ? Meta.MotionDirection.DOWN : Meta.MotionDirection.UP;
-        else if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
-            return progress > 0 ? Meta.MotionDirection.LEFT : Meta.MotionDirection.RIGHT;
-        else
-            return progress > 0 ? Meta.MotionDirection.RIGHT : Meta.MotionDirection.LEFT;
-    }
-
-    _getProgressRange() {
-        if (!this._switchData)
-            return [0, 0];
-
-        let lower = 0;
-        let upper = 0;
-
-        let horiz = global.workspace_manager.layout_rows != -1;
-        let baseDistance;
-        if (horiz)
-            baseDistance = global.screen_width;
-        else
-            baseDistance = global.screen_height;
-
-        let direction = this._directionForProgress(-1);
-        let info = this._switchData.surroundings[direction];
-        if (info != null) {
-            let distance = horiz ? info.xDest : info.yDest;
-            lower = -Math.abs(distance) / baseDistance;
-        }
-
-        direction = this._directionForProgress(1);
-        info = this._switchData.surroundings[direction];
-        if (info != null) {
-            let distance = horiz ? info.xDest : info.yDest;
-            upper = Math.abs(distance) / baseDistance;
-        }
-
-        return [lower, upper];
-    }
-
-    _switchWorkspaceBegin(tracker, monitor) {
-        if (Meta.prefs_get_workspaces_only_on_primary() && monitor != Main.layoutManager.primaryIndex)
-            return;
-
-        let horiz = global.workspace_manager.layout_rows != -1;
-        tracker.orientation = horiz ? Clutter.Orientation.HORIZONTAL : Clutter.Orientation.VERTICAL;
-
-        let workspaceManager = global.workspace_manager;
-        let activeWorkspace = workspaceManager.get_active_workspace();
-
-        let baseDistance;
-        if (horiz)
-            baseDistance = global.screen_width;
-        else
-            baseDistance = global.screen_height;
-
-        let progress;
-        if (this._switchData && this._switchData.gestureActivated) {
-            this._switchData.container.remove_all_transitions();
-            if (!horiz)
-                progress = -this._switchData.container.y / baseDistance;
-            else if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
-                progress = this._switchData.container.x / baseDistance;
-            else
-                progress = -this._switchData.container.x / baseDistance;
-        } else {
-            this._prepareWorkspaceSwitch(activeWorkspace.index(), -1);
-            progress = 0;
-        }
-
-        let points = [];
-        let [lower, upper] = this._getProgressRange();
-
-        if (lower != 0)
-            points.push(lower);
-
-        points.push(0);
-
-        if (upper != 0)
-            points.push(upper);
-
-        tracker.confirmSwipe(baseDistance, points, progress, 0);
-    }
-
-    _switchWorkspaceUpdate(_tracker, progress) {
-        if (!this._switchData)
-            return;
-
-        let direction = this._directionForProgress(progress);
-        let info = this._switchData.surroundings[direction];
-        let xPos = 0;
-        let yPos = 0;
-        if (info) {
-            if (global.workspace_manager.layout_rows == -1)
-                yPos = Math.round(Math.abs(progress) * -info.yDest);
-            else
-                xPos = Math.round(Math.abs(progress) * -info.xDest);
-        }
-
-        this._switchData.container.set_position(xPos, yPos);
-    }
-
-    _switchWorkspaceEnd(_tracker, duration, endProgress) {
-        if (!this._switchData)
-            return;
-
-        let workspaceManager = global.workspace_manager;
-        let activeWorkspace = workspaceManager.get_active_workspace();
-        let newWs = activeWorkspace;
-        let xDest = 0;
-        let yDest = 0;
-        if (endProgress != 0) {
-            let direction = this._directionForProgress(endProgress);
-            newWs = activeWorkspace.get_neighbor(direction);
-            xDest = -this._switchData.surroundings[direction].xDest;
-            yDest = -this._switchData.surroundings[direction].yDest;
-        }
-
-        if (duration == 0) {
-            if (newWs != activeWorkspace)
-                this.actionMoveWorkspace(newWs);
-            this._switchWorkspaceStop();
-            return;
-        }
-
-        let switchData = this._switchData;
-        switchData.gestureActivated = true;
-
-        this._switchData.container.ease({
-            x: xDest,
-            y: yDest,
-            duration,
-            mode: Clutter.AnimationMode.EASE_OUT_CUBIC,
-            onComplete: () => {
-                if (newWs != activeWorkspace)
-                    this.actionMoveWorkspace(newWs);
-                this._finishWorkspaceSwitch(switchData);
-            },
-        });
-    }
-
-    _switchWorkspaceStop() {
-        this._switchData.container.x = 0;
-        this._switchData.container.y = 0;
-        this._finishWorkspaceSwitch(this._switchData);
+        this._workspaceAnimation.animateSwitchWorkspace(shellwm, from, to, direction);
     }
 
     _showTilePreview(shellwm, window, tileRect, monitorIndex) {
@@ -2194,7 +1817,7 @@ var WindowManager = class {
             // This won't have any effect for "always sticky" windows
             // (like desktop windows or docks)
 
-            this._movingWindow = window;
+            this._workspaceAnimation.movingWindow = window;
             window.change_workspace(workspace);
 
             global.display.clear_mouse_mode();
diff --git a/js/ui/workspaceAnimation.js b/js/ui/workspaceAnimation.js
new file mode 100644
index 000000000..6ae7038f6
--- /dev/null
+++ b/js/ui/workspaceAnimation.js
@@ -0,0 +1,419 @@
+// -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
+/* exported WorkspaceAnimationController */
+
+const { Clutter, Meta, Shell } = imports.gi;
+
+const Main = imports.ui.main;
+const SwipeTracker = imports.ui.swipeTracker;
+
+var WINDOW_ANIMATION_TIME = 250;
+
+var WorkspaceAnimationController = class {
+    constructor() {
+        this._shellwm = global.window_manager;
+        this._movingWindow = null;
+
+        this._switchData = null;
+        this._shellwm.connect('kill-switch-workspace', shellwm => {
+            if (this._switchData) {
+                if (this._switchData.inProgress)
+                    this._switchWorkspaceDone(shellwm);
+                else if (!this._switchData.gestureActivated)
+                    this._finishWorkspaceSwitch(this._switchData);
+            }
+        });
+
+        global.display.connect('restacked', this._syncStacking.bind(this));
+
+        Main.overview.connect('showing', () => {
+            if (this._switchData) {
+                if (this._switchData.gestureActivated)
+                    this._switchWorkspaceStop();
+                this._swipeTracker.enabled = false;
+            }
+        });
+        Main.overview.connect('hiding', () => {
+            this._swipeTracker.enabled = true;
+        });
+
+        let allowedModes = Shell.ActionMode.NORMAL;
+        let swipeTracker = new SwipeTracker.SwipeTracker(global.stage, allowedModes, false, false);
+        swipeTracker.connect('begin', this._switchWorkspaceBegin.bind(this));
+        swipeTracker.connect('update', this._switchWorkspaceUpdate.bind(this));
+        swipeTracker.connect('end', this._switchWorkspaceEnd.bind(this));
+        this._swipeTracker = swipeTracker;
+    }
+
+    _syncStacking() {
+        if (this._switchData == null)
+            return;
+
+        let windows = global.get_window_actors();
+        let lastCurSibling = null;
+        let lastDirSibling = [];
+        for (let i = 0; i < windows.length; i++) {
+            if (windows[i].get_parent() == this._switchData.curGroup) {
+                this._switchData.curGroup.set_child_above_sibling(windows[i], lastCurSibling);
+                lastCurSibling = windows[i];
+            } else {
+                for (let dir of Object.values(Meta.MotionDirection)) {
+                    let info = this._switchData.surroundings[dir];
+                    if (!info || windows[i].get_parent() != info.actor)
+                        continue;
+
+                    let sibling = lastDirSibling[dir];
+                    if (sibling == undefined)
+                        sibling = null;
+
+                    info.actor.set_child_above_sibling(windows[i], sibling);
+                    lastDirSibling[dir] = windows[i];
+                    break;
+                }
+            }
+        }
+    }
+
+    _getPositionForDirection(direction, fromWs, toWs) {
+        let xDest = 0, yDest = 0;
+
+        let oldWsIsFullscreen = fromWs.list_windows().some(w => w.is_fullscreen());
+        let newWsIsFullscreen = toWs.list_windows().some(w => w.is_fullscreen());
+
+        // We have to shift windows up or down by the height of the panel to prevent having a
+        // visible gap between the windows while switching workspaces. Since fullscreen windows
+        // hide the panel, they don't need to be shifted up or down.
+        let shiftHeight = Main.panel.height;
+
+        if (direction == Meta.MotionDirection.UP ||
+            direction == Meta.MotionDirection.UP_LEFT ||
+            direction == Meta.MotionDirection.UP_RIGHT)
+            yDest = -global.screen_height + (oldWsIsFullscreen ? 0 : shiftHeight);
+        else if (direction == Meta.MotionDirection.DOWN ||
+            direction == Meta.MotionDirection.DOWN_LEFT ||
+            direction == Meta.MotionDirection.DOWN_RIGHT)
+            yDest = global.screen_height - (newWsIsFullscreen ? 0 : shiftHeight);
+
+        if (direction == Meta.MotionDirection.LEFT ||
+            direction == Meta.MotionDirection.UP_LEFT ||
+            direction == Meta.MotionDirection.DOWN_LEFT)
+            xDest = -global.screen_width;
+        else if (direction == Meta.MotionDirection.RIGHT ||
+                 direction == Meta.MotionDirection.UP_RIGHT ||
+                 direction == Meta.MotionDirection.DOWN_RIGHT)
+            xDest = global.screen_width;
+
+        return [xDest, yDest];
+    }
+
+    _prepareWorkspaceSwitch(from, to, direction) {
+        if (this._switchData)
+            return;
+
+        let wgroup = global.window_group;
+        let windows = global.get_window_actors();
+        let switchData = {};
+
+        this._switchData = switchData;
+        switchData.curGroup = new Clutter.Actor();
+        switchData.movingWindowBin = new Clutter.Actor();
+        switchData.windows = [];
+        switchData.surroundings = {};
+        switchData.gestureActivated = false;
+        switchData.inProgress = false;
+
+        switchData.container = new Clutter.Actor();
+        switchData.container.add_actor(switchData.curGroup);
+
+        wgroup.add_actor(switchData.movingWindowBin);
+        wgroup.add_actor(switchData.container);
+
+        let workspaceManager = global.workspace_manager;
+        let curWs = workspaceManager.get_workspace_by_index(from);
+
+        for (let dir of Object.values(Meta.MotionDirection)) {
+            let ws = null;
+
+            if (to < 0)
+                ws = curWs.get_neighbor(dir);
+            else if (dir == direction)
+                ws = workspaceManager.get_workspace_by_index(to);
+
+            if (ws == null || ws == curWs) {
+                switchData.surroundings[dir] = null;
+                continue;
+            }
+
+            let [x, y] = this._getPositionForDirection(dir, curWs, ws);
+            let info = { index: ws.index(),
+                         actor: new Clutter.Actor(),
+                         xDest: x,
+                         yDest: y };
+            switchData.surroundings[dir] = info;
+            switchData.container.add_actor(info.actor);
+            switchData.container.set_child_above_sibling(info.actor, null);
+
+            info.actor.set_position(x, y);
+        }
+
+        wgroup.set_child_above_sibling(switchData.movingWindowBin, null);
+
+        for (let i = 0; i < windows.length; i++) {
+            let actor = windows[i];
+            let window = actor.get_meta_window();
+
+            if (!window.showing_on_its_workspace())
+                continue;
+
+            if (window.is_on_all_workspaces())
+                continue;
+
+            let record = { window: actor,
+                           parent: actor.get_parent() };
+
+            if (this.movingWindow && window == this.movingWindow) {
+                record.parent.remove_child(actor);
+                switchData.movingWindow = record;
+                switchData.windows.push(switchData.movingWindow);
+                switchData.movingWindowBin.add_child(actor);
+            } else if (window.get_workspace().index() == from) {
+                record.parent.remove_child(actor)
+                switchData.windows.push(record);
+                switchData.curGroup.add_child(actor);
+            } else {
+                let visible = false;
+                for (let dir of Object.values(Meta.MotionDirection)) {
+                    let info = switchData.surroundings[dir];
+
+                    if (!info || info.index != window.get_workspace().index())
+                        continue;
+
+                    record.parent.remove_child(actor);
+                    switchData.windows.push(record);
+                    info.actor.add_child(actor);
+                    visible = true;
+                    break;
+                }
+
+                actor.visible = visible;
+            }
+        }
+
+        for (let i = 0; i < switchData.windows.length; i++) {
+            let w = switchData.windows[i];
+
+            w.windowDestroyId = w.window.connect('destroy', () => {
+                switchData.windows.splice(switchData.windows.indexOf(w), 1);
+            });
+        }
+    }
+
+    _finishWorkspaceSwitch(switchData) {
+        this._switchData = null;
+
+        for (let i = 0; i < switchData.windows.length; i++) {
+            let w = switchData.windows[i];
+
+            w.window.disconnect(w.windowDestroyId);
+            w.window.get_parent().remove_child(w.window);
+            w.parent.add_child(w.window);
+
+            if (w.window.get_meta_window().get_workspace() !=
+                global.workspace_manager.get_active_workspace())
+                w.window.hide();
+        }
+        switchData.container.destroy();
+        switchData.movingWindowBin.destroy();
+
+        this.movingWindow = null;
+    }
+
+    animateSwitchWorkspace(shellwm, from, to, direction) {
+        this._prepareWorkspaceSwitch(from, to, direction);
+        this._switchData.inProgress = true;
+
+        let workspaceManager = global.workspace_manager;
+        let fromWs = workspaceManager.get_workspace_by_index(from);
+        let toWs = workspaceManager.get_workspace_by_index(to);
+
+        let [xDest, yDest] = this._getPositionForDirection(direction, fromWs, toWs);
+
+        /* @direction is the direction that the "camera" moves, so the
+         * screen contents have to move one screen's worth in the
+         * opposite direction.
+         */
+        xDest = -xDest;
+        yDest = -yDest;
+
+        this._switchData.container.ease({
+            x: xDest,
+            y: yDest,
+            duration: WINDOW_ANIMATION_TIME,
+            mode: Clutter.AnimationMode.EASE_OUT_CUBIC,
+            onComplete: () => this._switchWorkspaceDone(shellwm),
+        });
+    }
+
+    _switchWorkspaceDone(shellwm) {
+        this._finishWorkspaceSwitch(this._switchData);
+        shellwm.completed_switch_workspace();
+    }
+
+    _directionForProgress(progress) {
+        if (global.workspace_manager.layout_rows == -1)
+            return progress > 0 ? Meta.MotionDirection.DOWN : Meta.MotionDirection.UP;
+        else if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
+            return progress > 0 ? Meta.MotionDirection.LEFT : Meta.MotionDirection.RIGHT;
+        else
+            return progress > 0 ? Meta.MotionDirection.RIGHT : Meta.MotionDirection.LEFT;
+    }
+
+    _getProgressRange() {
+        if (!this._switchData)
+            return [0, 0];
+
+        let lower = 0;
+        let upper = 0;
+
+        let horiz = global.workspace_manager.layout_rows != -1;
+        let baseDistance;
+        if (horiz)
+            baseDistance = global.screen_width;
+        else
+            baseDistance = global.screen_height;
+
+        let direction = this._directionForProgress(-1);
+        let info = this._switchData.surroundings[direction];
+        if (info != null) {
+            let distance = horiz ? info.xDest : info.yDest;
+            lower = -Math.abs(distance) / baseDistance;
+        }
+
+        direction = this._directionForProgress(1);
+        info = this._switchData.surroundings[direction];
+        if (info != null) {
+            let distance = horiz ? info.xDest : info.yDest;
+            upper = Math.abs(distance) / baseDistance;
+        }
+
+        return [lower, upper];
+    }
+
+    _switchWorkspaceBegin(tracker, monitor) {
+        if (Meta.prefs_get_workspaces_only_on_primary() && monitor != Main.layoutManager.primaryIndex)
+            return;
+
+        let horiz = global.workspace_manager.layout_rows != -1;
+        tracker.orientation = horiz ? Clutter.Orientation.HORIZONTAL : Clutter.Orientation.VERTICAL;
+
+        let workspaceManager = global.workspace_manager;
+        let activeWorkspace = workspaceManager.get_active_workspace();
+
+        let baseDistance;
+        if (horiz)
+            baseDistance = global.screen_width;
+        else
+            baseDistance = global.screen_height;
+
+        let progress;
+        if (this._switchData && this._switchData.gestureActivated) {
+            this._switchData.container.remove_all_transitions();
+            if (!horiz)
+                progress = -this._switchData.container.y / baseDistance;
+            else if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
+                progress = this._switchData.container.x / baseDistance;
+            else
+                progress = -this._switchData.container.x / baseDistance;
+        } else {
+            this._prepareWorkspaceSwitch(activeWorkspace.index(), -1);
+            progress = 0;
+        }
+
+        let points = [];
+        let [lower, upper] = this._getProgressRange();
+
+        if (lower != 0)
+            points.push(lower);
+
+        points.push(0);
+
+        if (upper != 0)
+            points.push(upper);
+
+        tracker.confirmSwipe(baseDistance, points, progress, 0);
+    }
+
+    _switchWorkspaceUpdate(_tracker, progress) {
+        if (!this._switchData)
+            return;
+
+        let direction = this._directionForProgress(progress);
+        let info = this._switchData.surroundings[direction];
+        let xPos = 0;
+        let yPos = 0;
+        if (info) {
+            if (global.workspace_manager.layout_rows == -1)
+                yPos = Math.round(Math.abs(progress) * -info.yDest);
+            else
+                xPos = Math.round(Math.abs(progress) * -info.xDest);
+        }
+
+        this._switchData.container.set_position(xPos, yPos);
+    }
+
+    _switchWorkspaceEnd(_tracker, duration, endProgress) {
+        if (!this._switchData)
+            return;
+
+        let workspaceManager = global.workspace_manager;
+        let activeWorkspace = workspaceManager.get_active_workspace();
+        let newWs = activeWorkspace;
+        let xDest = 0;
+        let yDest = 0;
+        if (endProgress != 0) {
+            let direction = this._directionForProgress(endProgress);
+            newWs = activeWorkspace.get_neighbor(direction);
+            xDest = -this._switchData.surroundings[direction].xDest;
+            yDest = -this._switchData.surroundings[direction].yDest;
+        }
+
+        if (duration == 0) {
+            if (newWs != activeWorkspace)
+                newWs.activate(global.get_current_time());
+            this._switchWorkspaceStop();
+            return;
+        }
+
+        let switchData = this._switchData;
+        switchData.gestureActivated = true;
+
+        this._switchData.container.ease({
+            x: xDest,
+            y: yDest,
+            duration,
+            mode: Clutter.AnimationMode.EASE_OUT_CUBIC,
+            onComplete: () => {
+                if (newWs != activeWorkspace)
+                    newWs.activate(global.get_current_time());
+                this._finishWorkspaceSwitch(switchData);
+            },
+        });
+    }
+
+    _switchWorkspaceStop() {
+        this._switchData.container.x = 0;
+        this._switchData.container.y = 0;
+        this._finishWorkspaceSwitch(this._switchData);
+    }
+
+    isAnimating() {
+        return this._switchData != null;
+    }
+
+    set movingWindow(movingWindow) {
+        this._movingWindow = movingWindow;
+    }
+
+    get movingWindow() {
+        return this._movingWindow;
+    }
+};
-- 
2.23.0

From b92629207d468ef0eb40bce1237df2ab3814aa98 Mon Sep 17 00:00:00 2001
From: Alexander Mikhaylenko <alexm@gnome.org>
Date: Thu, 4 Jul 2019 20:58:05 +0500
Subject: [PATCH 32/36] workspaceAnimation: Extract WorkspaceAnimation

Simplify the logic a bit. Introduce WorkspaceAnimation class that reparents
the windows from current, surrounding and destination workspaces and manages
them. Expose 'progress' property and have WorkspaceAnimationController animate
it instead of animating everything separately.

https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/605
---
 js/ui/workspaceAnimation.js | 476 +++++++++++++++++++-----------------
 1 file changed, 255 insertions(+), 221 deletions(-)

diff --git a/js/ui/workspaceAnimation.js b/js/ui/workspaceAnimation.js
index 6ae7038f6..ded7e0966 100644
--- a/js/ui/workspaceAnimation.js
+++ b/js/ui/workspaceAnimation.js
@@ -1,131 +1,42 @@
 // -*- mode: js; js-indent-level: 4; indent-tabs-mode: nil -*-
 /* exported WorkspaceAnimationController */
 
-const { Clutter, Meta, Shell } = imports.gi;
+const { Clutter, GObject, Meta, Shell } = imports.gi;
 
 const Main = imports.ui.main;
 const SwipeTracker = imports.ui.swipeTracker;
 
 var WINDOW_ANIMATION_TIME = 250;
 
-var WorkspaceAnimationController = class {
-    constructor() {
-        this._shellwm = global.window_manager;
-        this._movingWindow = null;
-
-        this._switchData = null;
-        this._shellwm.connect('kill-switch-workspace', shellwm => {
-            if (this._switchData) {
-                if (this._switchData.inProgress)
-                    this._switchWorkspaceDone(shellwm);
-                else if (!this._switchData.gestureActivated)
-                    this._finishWorkspaceSwitch(this._switchData);
-            }
-        });
-
-        global.display.connect('restacked', this._syncStacking.bind(this));
-
-        Main.overview.connect('showing', () => {
-            if (this._switchData) {
-                if (this._switchData.gestureActivated)
-                    this._switchWorkspaceStop();
-                this._swipeTracker.enabled = false;
-            }
-        });
-        Main.overview.connect('hiding', () => {
-            this._swipeTracker.enabled = true;
-        });
-
-        let allowedModes = Shell.ActionMode.NORMAL;
-        let swipeTracker = new SwipeTracker.SwipeTracker(global.stage, allowedModes, false, false);
-        swipeTracker.connect('begin', this._switchWorkspaceBegin.bind(this));
-        swipeTracker.connect('update', this._switchWorkspaceUpdate.bind(this));
-        swipeTracker.connect('end', this._switchWorkspaceEnd.bind(this));
-        this._swipeTracker = swipeTracker;
-    }
-
-    _syncStacking() {
-        if (this._switchData == null)
-            return;
-
-        let windows = global.get_window_actors();
-        let lastCurSibling = null;
-        let lastDirSibling = [];
-        for (let i = 0; i < windows.length; i++) {
-            if (windows[i].get_parent() == this._switchData.curGroup) {
-                this._switchData.curGroup.set_child_above_sibling(windows[i], lastCurSibling);
-                lastCurSibling = windows[i];
-            } else {
-                for (let dir of Object.values(Meta.MotionDirection)) {
-                    let info = this._switchData.surroundings[dir];
-                    if (!info || windows[i].get_parent() != info.actor)
-                        continue;
-
-                    let sibling = lastDirSibling[dir];
-                    if (sibling == undefined)
-                        sibling = null;
-
-                    info.actor.set_child_above_sibling(windows[i], sibling);
-                    lastDirSibling[dir] = windows[i];
-                    break;
-                }
-            }
-        }
-    }
-
-    _getPositionForDirection(direction, fromWs, toWs) {
-        let xDest = 0, yDest = 0;
-
-        let oldWsIsFullscreen = fromWs.list_windows().some(w => w.is_fullscreen());
-        let newWsIsFullscreen = toWs.list_windows().some(w => w.is_fullscreen());
-
-        // We have to shift windows up or down by the height of the panel to prevent having a
-        // visible gap between the windows while switching workspaces. Since fullscreen windows
-        // hide the panel, they don't need to be shifted up or down.
-        let shiftHeight = Main.panel.height;
-
-        if (direction == Meta.MotionDirection.UP ||
-            direction == Meta.MotionDirection.UP_LEFT ||
-            direction == Meta.MotionDirection.UP_RIGHT)
-            yDest = -global.screen_height + (oldWsIsFullscreen ? 0 : shiftHeight);
-        else if (direction == Meta.MotionDirection.DOWN ||
-            direction == Meta.MotionDirection.DOWN_LEFT ||
-            direction == Meta.MotionDirection.DOWN_RIGHT)
-            yDest = global.screen_height - (newWsIsFullscreen ? 0 : shiftHeight);
-
-        if (direction == Meta.MotionDirection.LEFT ||
-            direction == Meta.MotionDirection.UP_LEFT ||
-            direction == Meta.MotionDirection.DOWN_LEFT)
-            xDest = -global.screen_width;
-        else if (direction == Meta.MotionDirection.RIGHT ||
-                 direction == Meta.MotionDirection.UP_RIGHT ||
-                 direction == Meta.MotionDirection.DOWN_RIGHT)
-            xDest = global.screen_width;
-
-        return [xDest, yDest];
-    }
-
-    _prepareWorkspaceSwitch(from, to, direction) {
-        if (this._switchData)
-            return;
+var WorkspaceAnimation = GObject.registerClass({
+    Properties: {
+        'progress': GObject.ParamSpec.double(
+            'progress', 'progress', 'progress',
+            GObject.ParamFlags.READWRITE,
+            -1, 1, 0),
+    },
+}, class WorkspaceAnimation extends Clutter.Actor {
+    _init(controller, from, to, direction) {
+        super._init();
+
+        this.connect('destroy', this._onDestroy.bind(this));
+
+        this._controller = controller;
+        this._curGroup = new Clutter.Actor();
+        this._movingWindowBin = new Clutter.Actor();
+        this._windows = [];
+        this._surroundings = {};
+        this._progress = 0;
 
         let wgroup = global.window_group;
         let windows = global.get_window_actors();
-        let switchData = {};
-
-        this._switchData = switchData;
-        switchData.curGroup = new Clutter.Actor();
-        switchData.movingWindowBin = new Clutter.Actor();
-        switchData.windows = [];
-        switchData.surroundings = {};
-        switchData.gestureActivated = false;
-        switchData.inProgress = false;
 
-        switchData.container = new Clutter.Actor();
-        switchData.container.add_actor(switchData.curGroup);
+        this._container = new Clutter.Actor();
+        this._container.add_actor(this._curGroup);
 
-        wgroup.add_actor(switchData.movingWindowBin);
-        wgroup.add_actor(switchData.container);
+        this.add_actor(this._container);
+        wgroup.add_actor(this);
+        wgroup.add_actor(this._movingWindowBin);
 
         let workspaceManager = global.workspace_manager;
         let curWs = workspaceManager.get_workspace_by_index(from);
@@ -139,7 +50,7 @@ var WorkspaceAnimationController = class {
                 ws = workspaceManager.get_workspace_by_index(to);
 
             if (ws == null || ws == curWs) {
-                switchData.surroundings[dir] = null;
+                this._surroundings[dir] = null;
                 continue;
             }
 
@@ -148,14 +59,14 @@ var WorkspaceAnimationController = class {
                          actor: new Clutter.Actor(),
                          xDest: x,
                          yDest: y };
-            switchData.surroundings[dir] = info;
-            switchData.container.add_actor(info.actor);
-            switchData.container.set_child_above_sibling(info.actor, null);
+            this._surroundings[dir] = info;
+            this._container.add_actor(info.actor);
+            this._container.set_child_above_sibling(info.actor, null);
 
             info.actor.set_position(x, y);
         }
 
-        wgroup.set_child_above_sibling(switchData.movingWindowBin, null);
+        wgroup.set_child_above_sibling(this._movingWindowBin, null);
 
         for (let i = 0; i < windows.length; i++) {
             let actor = windows[i];
@@ -170,25 +81,25 @@ var WorkspaceAnimationController = class {
             let record = { window: actor,
                            parent: actor.get_parent() };
 
-            if (this.movingWindow && window == this.movingWindow) {
+            if (this._controller.movingWindow && window == this._controller.movingWindow) {
                 record.parent.remove_child(actor);
-                switchData.movingWindow = record;
-                switchData.windows.push(switchData.movingWindow);
-                switchData.movingWindowBin.add_child(actor);
+                this._movingWindow = record;
+                this._windows.push(this._movingWindow);
+                this._movingWindowBin.add_child(actor);
             } else if (window.get_workspace().index() == from) {
                 record.parent.remove_child(actor)
-                switchData.windows.push(record);
-                switchData.curGroup.add_child(actor);
+                this._windows.push(record);
+                this._curGroup.add_child(actor);
             } else {
                 let visible = false;
                 for (let dir of Object.values(Meta.MotionDirection)) {
-                    let info = switchData.surroundings[dir];
+                    let info = this._surroundings[dir];
 
                     if (!info || info.index != window.get_workspace().index())
                         continue;
 
                     record.parent.remove_child(actor);
-                    switchData.windows.push(record);
+                    this._windows.push(record);
                     info.actor.add_child(actor);
                     visible = true;
                     break;
@@ -198,20 +109,22 @@ var WorkspaceAnimationController = class {
             }
         }
 
-        for (let i = 0; i < switchData.windows.length; i++) {
-            let w = switchData.windows[i];
+        for (let i = 0; i < this._windows.length; i++) {
+            let w = this._windows[i];
 
             w.windowDestroyId = w.window.connect('destroy', () => {
-                switchData.windows.splice(switchData.windows.indexOf(w), 1);
+                this._windows.splice(this._windows.indexOf(w), 1);
             });
         }
+
+        global.display.connect('restacked', this._syncStacking.bind(this));
     }
 
-    _finishWorkspaceSwitch(switchData) {
-        this._switchData = null;
+    _onDestroy() {
+        this.remove_all_transitions();
 
-        for (let i = 0; i < switchData.windows.length; i++) {
-            let w = switchData.windows[i];
+        for (let i = 0; i < this._windows.length; i++) {
+            let w = this._windows[i];
 
             w.window.disconnect(w.windowDestroyId);
             w.window.get_parent().remove_child(w.window);
@@ -221,44 +134,70 @@ var WorkspaceAnimationController = class {
                 global.workspace_manager.get_active_workspace())
                 w.window.hide();
         }
-        switchData.container.destroy();
-        switchData.movingWindowBin.destroy();
 
-        this.movingWindow = null;
+        this._container.destroy();
+        this._movingWindowBin.destroy();
     }
 
-    animateSwitchWorkspace(shellwm, from, to, direction) {
-        this._prepareWorkspaceSwitch(from, to, direction);
-        this._switchData.inProgress = true;
+    _getPositionForDirection(direction, fromWs, toWs) {
+        let xDest = 0, yDest = 0;
 
-        let workspaceManager = global.workspace_manager;
-        let fromWs = workspaceManager.get_workspace_by_index(from);
-        let toWs = workspaceManager.get_workspace_by_index(to);
+        let oldWsIsFullscreen = fromWs.list_windows().some(w => w.is_fullscreen());
+        let newWsIsFullscreen = toWs.list_windows().some(w => w.is_fullscreen());
 
-        let [xDest, yDest] = this._getPositionForDirection(direction, fromWs, toWs);
+        // We have to shift windows up or down by the height of the panel to prevent having a
+        // visible gap between the windows while switching workspaces. Since fullscreen windows
+        // hide the panel, they don't need to be shifted up or down.
+        let shiftHeight = Main.panel.height;
 
-        /* @direction is the direction that the "camera" moves, so the
-         * screen contents have to move one screen's worth in the
-         * opposite direction.
-         */
-        xDest = -xDest;
-        yDest = -yDest;
+        if (direction == Meta.MotionDirection.UP ||
+            direction == Meta.MotionDirection.UP_LEFT ||
+            direction == Meta.MotionDirection.UP_RIGHT)
+            yDest = -global.screen_height + (oldWsIsFullscreen ? 0 : shiftHeight);
+        else if (direction == Meta.MotionDirection.DOWN ||
+            direction == Meta.MotionDirection.DOWN_LEFT ||
+            direction == Meta.MotionDirection.DOWN_RIGHT)
+            yDest = global.screen_height - (newWsIsFullscreen ? 0 : shiftHeight);
 
-        this._switchData.container.ease({
-            x: xDest,
-            y: yDest,
-            duration: WINDOW_ANIMATION_TIME,
-            mode: Clutter.AnimationMode.EASE_OUT_CUBIC,
-            onComplete: () => this._switchWorkspaceDone(shellwm),
-        });
+        if (direction == Meta.MotionDirection.LEFT ||
+            direction == Meta.MotionDirection.UP_LEFT ||
+            direction == Meta.MotionDirection.DOWN_LEFT)
+            xDest = -global.screen_width;
+        else if (direction == Meta.MotionDirection.RIGHT ||
+                 direction == Meta.MotionDirection.UP_RIGHT ||
+                 direction == Meta.MotionDirection.DOWN_RIGHT)
+            xDest = global.screen_width;
+
+        return [xDest, yDest];
     }
 
-    _switchWorkspaceDone(shellwm) {
-        this._finishWorkspaceSwitch(this._switchData);
-        shellwm.completed_switch_workspace();
+    _syncStacking() {
+        let windows = global.get_window_actors();
+        let lastCurSibling = null;
+        let lastDirSibling = [];
+        for (let i = 0; i < windows.length; i++) {
+            if (windows[i].get_parent() == this._curGroup) {
+                this._curGroup.set_child_above_sibling(windows[i], lastCurSibling);
+                lastCurSibling = windows[i];
+            } else {
+                for (let dir of Object.values(Meta.MotionDirection)) {
+                    let info = this._surroundings[dir];
+                    if (!info || windows[i].get_parent() != info.actor)
+                        continue;
+
+                    let sibling = lastDirSibling[dir];
+                    if (sibling == undefined)
+                        sibling = null;
+
+                    info.actor.set_child_above_sibling(windows[i], sibling);
+                    lastDirSibling[dir] = windows[i];
+                    break;
+                }
+            }
+        }
     }
 
-    _directionForProgress(progress) {
+    directionForProgress(progress) {
         if (global.workspace_manager.layout_rows == -1)
             return progress > 0 ? Meta.MotionDirection.DOWN : Meta.MotionDirection.UP;
         else if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
@@ -267,36 +206,143 @@ var WorkspaceAnimationController = class {
             return progress > 0 ? Meta.MotionDirection.RIGHT : Meta.MotionDirection.LEFT;
     }
 
-    _getProgressRange() {
-        if (!this._switchData)
-            return [0, 0];
+    progressForDirection(dir) {
+        if (global.workspace_manager.layout_rows == -1)
+            return dir == Meta.MotionDirection.DOWN ? 1 : -1;
+        else if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
+            return dir == Meta.MotionDirection.LEFT ? 1 : -1;
+        else
+            return dir == Meta.MotionDirection.RIGHT ? 1 : -1;
+    }
+
+    get progress() {
+        return this._progress;
+    }
 
-        let lower = 0;
-        let upper = 0;
+    set progress(progress) {
+        this._progress = progress;
 
-        let horiz = global.workspace_manager.layout_rows != -1;
+        let direction = this.directionForProgress(progress);
+        let xPos = 0;
+        let yPos = 0;
+
+        if (global.workspace_manager.layout_rows == -1)
+            yPos = -Math.round(progress * this._getDistance(direction));
+        else if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
+            xPos = Math.round(progress * this._getDistance(direction));
+        else
+            xPos = -Math.round(progress * this._getDistance(direction));
+
+        this._container.set_position(xPos, yPos);
+    }
+
+    _getDistance(direction) {
+        let info = this._surroundings[direction];
+        if (!info)
+            return 0;
+
+        switch (direction) {
+        case Meta.MotionDirection.UP:
+            return -info.yDest;
+        case Meta.MotionDirection.DOWN:
+            return info.yDest;
+        case Meta.MotionDirection.LEFT:
+            return -info.xDest;
+        case Meta.MotionDirection.RIGHT:
+            return info.xDest;
+        }
+
+        return 0;
+    }
+
+    getProgressRange() {
         let baseDistance;
-        if (horiz)
+        if (global.workspace_manager.layout_rows != -1)
             baseDistance = global.screen_width;
         else
             baseDistance = global.screen_height;
 
-        let direction = this._directionForProgress(-1);
-        let info = this._switchData.surroundings[direction];
-        if (info != null) {
-            let distance = horiz ? info.xDest : info.yDest;
-            lower = -Math.abs(distance) / baseDistance;
-        }
+        let direction = this.directionForProgress(-1);
+        let distance = this._getDistance(direction);
+        let lower = -distance / baseDistance;
 
-        direction = this._directionForProgress(1);
-        info = this._switchData.surroundings[direction];
-        if (info != null) {
-            let distance = horiz ? info.xDest : info.yDest;
-            upper = Math.abs(distance) / baseDistance;
-        }
+        direction = this.directionForProgress(1);
+        distance = this._getDistance(direction);
+        let upper = distance / baseDistance;
 
         return [lower, upper];
     }
+});
+
+var WorkspaceAnimationController = class {
+    constructor() {
+        this._shellwm = global.window_manager;
+        this._blockAnimations = false;
+        this._movingWindow = null;
+        this._inProgress = false;
+        this._gestureActivated = false;
+        this._animation = null;
+
+        this._shellwm.connect('kill-switch-workspace', shellwm => {
+            if (this._animation) {
+                if (this._inProgress)
+                    this._switchWorkspaceDone(shellwm);
+                else if (!this._gestureActivated)
+                    this._finishWorkspaceSwitch();
+            }
+        });
+
+        Main.overview.connect('showing', () => {
+            if (this._gestureActivated)
+                this._switchWorkspaceStop();
+
+            this._swipeTracker.enabled = false;
+        });
+        Main.overview.connect('hiding', () => {
+            this._swipeTracker.enabled = true;
+        });
+
+        let allowedModes = Shell.ActionMode.NORMAL;
+        let swipeTracker = new SwipeTracker.SwipeTracker(global.stage, allowedModes, false, false);
+        swipeTracker.connect('begin', this._switchWorkspaceBegin.bind(this));
+        swipeTracker.connect('update', this._switchWorkspaceUpdate.bind(this));
+        swipeTracker.connect('end', this._switchWorkspaceEnd.bind(this));
+        this._swipeTracker = swipeTracker;
+    }
+
+    _prepareWorkspaceSwitch(from, to, direction) {
+        if (this._animation)
+            return;
+
+        this._animation = new WorkspaceAnimation(this, from, to, direction);
+    }
+
+    _finishWorkspaceSwitch() {
+        if (this._animation)
+            this._animation.destroy();
+        this._animation = null;
+        this._inProgress = false;
+        this._gestureActivated = false;
+        this.movingWindow = null;
+    }
+
+    animateSwitchWorkspace(shellwm, from, to, direction) {
+        this._prepareWorkspaceSwitch(from, to, direction);
+        this._inProgress = true;
+
+        let progress = this._animation.progressForDirection(direction);
+
+        this._animation.ease_property('progress', progress, {
+            duration: WINDOW_ANIMATION_TIME,
+            mode: Clutter.AnimationMode.EASE_OUT_CUBIC,
+            onComplete: () => this._switchWorkspaceDone(shellwm),
+        });
+    }
+
+    _switchWorkspaceDone(shellwm) {
+        this._finishWorkspaceSwitch();
+        shellwm.completed_switch_workspace();
+    }
 
     _switchWorkspaceBegin(tracker, monitor) {
         if (Meta.prefs_get_workspaces_only_on_primary() && monitor != Main.layoutManager.primaryIndex)
@@ -315,22 +361,21 @@ var WorkspaceAnimationController = class {
             baseDistance = global.screen_height;
 
         let progress;
-        if (this._switchData && this._switchData.gestureActivated) {
-            this._switchData.container.remove_all_transitions();
-            if (!horiz)
-                progress = -this._switchData.container.y / baseDistance;
-            else if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
-                progress = this._switchData.container.x / baseDistance;
-            else
-                progress = -this._switchData.container.x / baseDistance;
+        if (this._gestureActivated) {
+            this._animation.remove_all_transitions();
+            progress = this._animation.progress;
         } else {
             this._prepareWorkspaceSwitch(activeWorkspace.index(), -1);
             progress = 0;
         }
 
-        let points = [];
-        let [lower, upper] = this._getProgressRange();
+        let [lower, upper] = this._animation.getProgressRange();
+        if (progress < 0)
+            progress *= -lower;
+        else if (progress > 0)
+            progress *= upper;
 
+        let points = [];
         if (lower != 0)
             points.push(lower);
 
@@ -343,37 +388,30 @@ var WorkspaceAnimationController = class {
     }
 
     _switchWorkspaceUpdate(_tracker, progress) {
-        if (!this._switchData)
-            return;
-
-        let direction = this._directionForProgress(progress);
-        let info = this._switchData.surroundings[direction];
-        let xPos = 0;
-        let yPos = 0;
-        if (info) {
-            if (global.workspace_manager.layout_rows == -1)
-                yPos = Math.round(Math.abs(progress) * -info.yDest);
-            else
-                xPos = Math.round(Math.abs(progress) * -info.xDest);
-        }
-
-        this._switchData.container.set_position(xPos, yPos);
+        // Translate the progress into [-1;1] range
+        let [lower, upper] = this._animation.getProgressRange();
+        if (progress < 0)
+            progress /= -lower;
+        else if (progress > 0)
+            progress /= upper;
+
+        if (this._animation)
+            this._animation.progress = progress;
     }
 
     _switchWorkspaceEnd(_tracker, duration, endProgress) {
-        if (!this._switchData)
+        if (!this._animation)
             return;
 
+        // Translate the progress into [-1;1] range
+        endProgress = Math.sign(endProgress);
+
         let workspaceManager = global.workspace_manager;
         let activeWorkspace = workspaceManager.get_active_workspace();
         let newWs = activeWorkspace;
-        let xDest = 0;
-        let yDest = 0;
         if (endProgress != 0) {
-            let direction = this._directionForProgress(endProgress);
+            let direction = this._animation.directionForProgress(endProgress);
             newWs = activeWorkspace.get_neighbor(direction);
-            xDest = -this._switchData.surroundings[direction].xDest;
-            yDest = -this._switchData.surroundings[direction].yDest;
         }
 
         if (duration == 0) {
@@ -383,30 +421,26 @@ var WorkspaceAnimationController = class {
             return;
         }
 
-        let switchData = this._switchData;
-        switchData.gestureActivated = true;
+        this._gestureActivated = true;
 
-        this._switchData.container.ease({
-            x: xDest,
-            y: yDest,
+        this._animation.ease_property('progress', endProgress, {
             duration,
             mode: Clutter.AnimationMode.EASE_OUT_CUBIC,
             onComplete: () => {
                 if (newWs != activeWorkspace)
                     newWs.activate(global.get_current_time());
-                this._finishWorkspaceSwitch(switchData);
+                this._finishWorkspaceSwitch();
             },
         });
     }
 
     _switchWorkspaceStop() {
-        this._switchData.container.x = 0;
-        this._switchData.container.y = 0;
-        this._finishWorkspaceSwitch(this._switchData);
+        this._animation.progress = 0;
+        this._finishWorkspaceSwitch();
     }
 
     isAnimating() {
-        return this._switchData != null;
+        return this._animation != null;
     }
 
     set movingWindow(movingWindow) {
-- 
2.23.0

From 2cc86e726627c015c471df8ec20b108fc4580b55 Mon Sep 17 00:00:00 2001
From: Alexander Mikhaylenko <alexm@gnome.org>
Date: Thu, 4 Jul 2019 22:44:15 +0500
Subject: [PATCH 33/36] workspaceAnimation: Extract WorkspaceGroup

Reimplement _syncStacking().

https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/605
---
 js/ui/workspaceAnimation.js | 188 +++++++++++++++++++-----------------
 1 file changed, 97 insertions(+), 91 deletions(-)

diff --git a/js/ui/workspaceAnimation.js b/js/ui/workspaceAnimation.js
index ded7e0966..27eb1dc12 100644
--- a/js/ui/workspaceAnimation.js
+++ b/js/ui/workspaceAnimation.js
@@ -8,6 +8,81 @@ const SwipeTracker = imports.ui.swipeTracker;
 
 var WINDOW_ANIMATION_TIME = 250;
 
+var WorkspaceGroup = GObject.registerClass(
+class WorkspaceGroup extends Clutter.Actor {
+    _init(controller, workspace) {
+        super._init();
+
+        this._controller = controller;
+        this._workspace = workspace;
+        this._windows = [];
+
+        this.refreshWindows();
+
+        this.connect('destroy', this._onDestroy.bind(this));
+        this._restackedId = global.display.connect('restacked', this.refreshWindows.bind(this));
+    }
+
+    _shouldShowWindow(window) {
+        if (window.get_workspace() != this._workspace)
+            return false;
+
+        if (!window.showing_on_its_workspace())
+            return false;
+
+        if (window.is_on_all_workspaces())
+            return false;
+
+        if (this._controller.movingWindow && window == this._controller.movingWindow)
+            return false;
+
+        return true;
+    }
+
+    refreshWindows() {
+        if (this._windows.length > 0)
+            this.removeWindows();
+
+        let windows = global.get_window_actors();
+        windows = windows.filter(w => this._shouldShowWindow(w.meta_window));
+
+        for (let window of windows) {
+            let record = { window,
+                           parent: window.get_parent() };
+
+            record.parent.remove_child(window)
+            this.add_child(window);
+
+            record.windowDestroyId = window.connect('destroy', () => {
+                this._windows.splice(this._windows.indexOf(record), 1);
+            });
+
+            this._windows.push(record);
+        }
+    }
+
+    removeWindows() {
+        for (let i = 0; i < this._windows.length; i++) {
+            let w = this._windows[i];
+
+            w.window.disconnect(w.windowDestroyId);
+            this.remove_child(w.window);
+            w.parent.add_child(w.window)
+
+            if (w.window.get_meta_window().get_workspace() !=
+                global.workspace_manager.get_active_workspace())
+                w.window.hide();
+        }
+
+        this._windows = [];
+    }
+
+    _onDestroy() {
+        global.display.disconnect(this._restackedId);
+        this.removeWindows();
+    }
+});
+
 var WorkspaceAnimation = GObject.registerClass({
     Properties: {
         'progress': GObject.ParamSpec.double(
@@ -22,25 +97,23 @@ var WorkspaceAnimation = GObject.registerClass({
         this.connect('destroy', this._onDestroy.bind(this));
 
         this._controller = controller;
-        this._curGroup = new Clutter.Actor();
         this._movingWindowBin = new Clutter.Actor();
-        this._windows = [];
+        this._movingWindow = null;
         this._surroundings = {};
         this._progress = 0;
 
-        let wgroup = global.window_group;
-        let windows = global.get_window_actors();
-
         this._container = new Clutter.Actor();
-        this._container.add_actor(this._curGroup);
 
         this.add_actor(this._container);
-        wgroup.add_actor(this);
-        wgroup.add_actor(this._movingWindowBin);
+        global.window_group.add_actor(this);
+        global.window_group.add_actor(this._movingWindowBin);
 
         let workspaceManager = global.workspace_manager;
         let curWs = workspaceManager.get_workspace_by_index(from);
 
+        this._curGroup = new WorkspaceGroup(controller, curWs);
+        this._container.add_actor(this._curGroup);
+
         for (let dir of Object.values(Meta.MotionDirection)) {
             let ws = null;
 
@@ -56,7 +129,7 @@ var WorkspaceAnimation = GObject.registerClass({
 
             let [x, y] = this._getPositionForDirection(dir, curWs, ws);
             let info = { index: ws.index(),
-                         actor: new Clutter.Actor(),
+                         actor: new WorkspaceGroup(controller, ws),
                          xDest: x,
                          yDest: y };
             this._surroundings[dir] = info;
@@ -66,73 +139,32 @@ var WorkspaceAnimation = GObject.registerClass({
             info.actor.set_position(x, y);
         }
 
-        wgroup.set_child_above_sibling(this._movingWindowBin, null);
+        global.window_group.set_child_above_sibling(this._movingWindowBin, null);
 
-        for (let i = 0; i < windows.length; i++) {
-            let actor = windows[i];
-            let window = actor.get_meta_window();
+        if (this._controller.movingWindow) {
+            let actor = this._controller.movingWindow.get_compositor_private();
 
-            if (!window.showing_on_its_workspace())
-                continue;
+            this._movingWindow = { window: actor,
+                                   parent: actor.get_parent() };
 
-            if (window.is_on_all_workspaces())
-                continue;
-
-            let record = { window: actor,
-                           parent: actor.get_parent() };
-
-            if (this._controller.movingWindow && window == this._controller.movingWindow) {
-                record.parent.remove_child(actor);
-                this._movingWindow = record;
-                this._windows.push(this._movingWindow);
-                this._movingWindowBin.add_child(actor);
-            } else if (window.get_workspace().index() == from) {
-                record.parent.remove_child(actor)
-                this._windows.push(record);
-                this._curGroup.add_child(actor);
-            } else {
-                let visible = false;
-                for (let dir of Object.values(Meta.MotionDirection)) {
-                    let info = this._surroundings[dir];
-
-                    if (!info || info.index != window.get_workspace().index())
-                        continue;
-
-                    record.parent.remove_child(actor);
-                    this._windows.push(record);
-                    info.actor.add_child(actor);
-                    visible = true;
-                    break;
-                }
-
-                actor.visible = visible;
-            }
-        }
-
-        for (let i = 0; i < this._windows.length; i++) {
-            let w = this._windows[i];
-
-            w.windowDestroyId = w.window.connect('destroy', () => {
-                this._windows.splice(this._windows.indexOf(w), 1);
+            this._movingWindow.parent.remove_child(actor);
+            this._movingWindowBin.add_child(actor);
+            this._movingWindow.windowDestroyId = actor.connect('destroy', () => {
+                this._movingWindow = null;
             });
         }
-
-        global.display.connect('restacked', this._syncStacking.bind(this));
     }
 
     _onDestroy() {
         this.remove_all_transitions();
 
-        for (let i = 0; i < this._windows.length; i++) {
-            let w = this._windows[i];
-
-            w.window.disconnect(w.windowDestroyId);
-            w.window.get_parent().remove_child(w.window);
-            w.parent.add_child(w.window);
+        if (this._movingWindow) {
+            let record = this._movingWindow;
+            record.window.disconnect(record.windowDestroyId);
+            record.window.get_parent().remove_child(record.window);
+            record.parent.add_child(record.window);
 
-            if (w.window.get_meta_window().get_workspace() !=
-                global.workspace_manager.get_active_workspace())
-                w.window.hide();
+            this._movingWindow = null;
         }
 
         this._container.destroy();
@@ -171,32 +203,6 @@ var WorkspaceAnimation = GObject.registerClass({
         return [xDest, yDest];
     }
 
-    _syncStacking() {
-        let windows = global.get_window_actors();
-        let lastCurSibling = null;
-        let lastDirSibling = [];
-        for (let i = 0; i < windows.length; i++) {
-            if (windows[i].get_parent() == this._curGroup) {
-                this._curGroup.set_child_above_sibling(windows[i], lastCurSibling);
-                lastCurSibling = windows[i];
-            } else {
-                for (let dir of Object.values(Meta.MotionDirection)) {
-                    let info = this._surroundings[dir];
-                    if (!info || windows[i].get_parent() != info.actor)
-                        continue;
-
-                    let sibling = lastDirSibling[dir];
-                    if (sibling == undefined)
-                        sibling = null;
-
-                    info.actor.set_child_above_sibling(windows[i], sibling);
-                    lastDirSibling[dir] = windows[i];
-                    break;
-                }
-            }
-        }
-    }
-
     directionForProgress(progress) {
         if (global.workspace_manager.layout_rows == -1)
             return progress > 0 ? Meta.MotionDirection.DOWN : Meta.MotionDirection.UP;
-- 
2.23.0

From 1af1564afcba38f95b8af311e90bc55defbc569c Mon Sep 17 00:00:00 2001
From: Alexander Mikhaylenko <alexm@gnome.org>
Date: Fri, 5 Jul 2019 15:48:38 +0500
Subject: [PATCH 34/36] workspaceAnimation: Only create moving window bin when
 needed

https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/605
---
 js/ui/workspaceAnimation.js | 15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)

diff --git a/js/ui/workspaceAnimation.js b/js/ui/workspaceAnimation.js
index 27eb1dc12..d9732b47b 100644
--- a/js/ui/workspaceAnimation.js
+++ b/js/ui/workspaceAnimation.js
@@ -97,7 +97,6 @@ var WorkspaceAnimation = GObject.registerClass({
         this.connect('destroy', this._onDestroy.bind(this));
 
         this._controller = controller;
-        this._movingWindowBin = new Clutter.Actor();
         this._movingWindow = null;
         this._surroundings = {};
         this._progress = 0;
@@ -106,7 +105,6 @@ var WorkspaceAnimation = GObject.registerClass({
 
         this.add_actor(this._container);
         global.window_group.add_actor(this);
-        global.window_group.add_actor(this._movingWindowBin);
 
         let workspaceManager = global.workspace_manager;
         let curWs = workspaceManager.get_workspace_by_index(from);
@@ -139,19 +137,22 @@ var WorkspaceAnimation = GObject.registerClass({
             info.actor.set_position(x, y);
         }
 
-        global.window_group.set_child_above_sibling(this._movingWindowBin, null);
-
         if (this._controller.movingWindow) {
             let actor = this._controller.movingWindow.get_compositor_private();
+            let container = new Clutter.Actor();
 
-            this._movingWindow = { window: actor,
+            this._movingWindow = { container,
+                                   window: actor,
                                    parent: actor.get_parent() };
 
             this._movingWindow.parent.remove_child(actor);
-            this._movingWindowBin.add_child(actor);
+            this._movingWindow.container.add_child(actor);
             this._movingWindow.windowDestroyId = actor.connect('destroy', () => {
                 this._movingWindow = null;
             });
+
+            global.window_group.add_actor(container);
+            global.window_group.set_child_above_sibling(container, null);
         }
     }
 
@@ -163,12 +164,12 @@ var WorkspaceAnimation = GObject.registerClass({
             record.window.disconnect(record.windowDestroyId);
             record.window.get_parent().remove_child(record.window);
             record.parent.add_child(record.window);
+            record.container.destroy();
 
             this._movingWindow = null;
         }
 
         this._container.destroy();
-        this._movingWindowBin.destroy();
     }
 
     _getPositionForDirection(direction, fromWs, toWs) {
-- 
2.23.0

From 340cb6f94c7c2955337a8d3a5e87b006a03348eb Mon Sep 17 00:00:00 2001
From: Alexander Mikhaylenko <alexm@gnome.org>
Date: Thu, 4 Jul 2019 23:15:15 +0500
Subject: [PATCH 35/36] workspaceAnimation: Use window clones

Instead of reparenting windows, clone them. This will allow to properly
support multi-monitor setups in subsequent commits.

Block window mapping animation while the animation is running to prevent
new windows appearing during the animation from being visible at the same
time as their clones.

https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/605
---
 js/ui/workspaceAnimation.js | 19 +++++++++++--------
 1 file changed, 11 insertions(+), 8 deletions(-)

diff --git a/js/ui/workspaceAnimation.js b/js/ui/workspaceAnimation.js
index d9732b47b..cc3f01d1b 100644
--- a/js/ui/workspaceAnimation.js
+++ b/js/ui/workspaceAnimation.js
@@ -47,13 +47,17 @@ class WorkspaceGroup extends Clutter.Actor {
         windows = windows.filter(w => this._shouldShowWindow(w.meta_window));
 
         for (let window of windows) {
-            let record = { window,
-                           parent: window.get_parent() };
+            let clone = new Clutter.Clone({ source: window,
+                                            x: window.x,
+                                            y: window.y });
 
-            record.parent.remove_child(window)
-            this.add_child(window);
+            this.add_actor(clone);
+            window.hide();
+
+            let record = { window, clone };
 
             record.windowDestroyId = window.connect('destroy', () => {
+                clone.destroy();
                 this._windows.splice(this._windows.indexOf(record), 1);
             });
 
@@ -66,12 +70,11 @@ class WorkspaceGroup extends Clutter.Actor {
             let w = this._windows[i];
 
             w.window.disconnect(w.windowDestroyId);
-            this.remove_child(w.window);
-            w.parent.add_child(w.window)
+            w.clone.destroy();
 
-            if (w.window.get_meta_window().get_workspace() !=
+            if (w.window.get_meta_window().get_workspace() ==
                 global.workspace_manager.get_active_workspace())
-                w.window.hide();
+                w.window.show();
         }
 
         this._windows = [];
-- 
2.23.0

From 9132849447429bad9e3c36ed4fbaf9656ff3e3c9 Mon Sep 17 00:00:00 2001
From: Alexander Mikhaylenko <alexm@gnome.org>
Date: Thu, 4 Jul 2019 23:43:23 +0500
Subject: [PATCH 36/36] workspaceAnimation: Support multiple screens

Have a separate animating container on each screen, and sync their
progress. Put each container into another actor, and clip it to that
screen. Since WorkspaceGroup uses window clones now, windows that are
visible on multiple screens at once would look and animate correctly.

Fixes https://gitlab.gnome.org/GNOME/gnome-shell/issues/1213

https://gitlab.gnome.org/GNOME/gnome-shell/merge_requests/605
---
 js/ui/workspaceAnimation.js | 149 ++++++++++++++++++++++--------------
 1 file changed, 93 insertions(+), 56 deletions(-)

diff --git a/js/ui/workspaceAnimation.js b/js/ui/workspaceAnimation.js
index cc3f01d1b..30437855c 100644
--- a/js/ui/workspaceAnimation.js
+++ b/js/ui/workspaceAnimation.js
@@ -10,11 +10,12 @@ var WINDOW_ANIMATION_TIME = 250;
 
 var WorkspaceGroup = GObject.registerClass(
 class WorkspaceGroup extends Clutter.Actor {
-    _init(controller, workspace) {
+    _init(controller, workspace, monitor) {
         super._init();
 
         this._controller = controller;
         this._workspace = workspace;
+        this._monitor = monitor;
         this._windows = [];
 
         this.refreshWindows();
@@ -27,6 +28,9 @@ class WorkspaceGroup extends Clutter.Actor {
         if (window.get_workspace() != this._workspace)
             return false;
 
+        if (!window.get_frame_rect().intersect(global.display.get_monitor_geometry(this._monitor.index))[0])
+            return false;
+
         if (!window.showing_on_its_workspace())
             return false;
 
@@ -101,43 +105,54 @@ var WorkspaceAnimation = GObject.registerClass({
 
         this._controller = controller;
         this._movingWindow = null;
-        this._surroundings = {};
+        this._monitors = [];
         this._progress = 0;
 
-        this._container = new Clutter.Actor();
-
-        this.add_actor(this._container);
         global.window_group.add_actor(this);
 
         let workspaceManager = global.workspace_manager;
         let curWs = workspaceManager.get_workspace_by_index(from);
 
-        this._curGroup = new WorkspaceGroup(controller, curWs);
-        this._container.add_actor(this._curGroup);
+        for (let monitor of Main.layoutManager.monitors) {
+            let record = { index: monitor.index,
+                           clipBin: new Clutter.Actor(),
+                           container: new Clutter.Actor(),
+                           surroundings: {} };
 
-        for (let dir of Object.values(Meta.MotionDirection)) {
-            let ws = null;
+            record.clipBin.add_actor(record.container);
+            record.clipBin.set_clip(monitor.x, monitor.y, monitor.width, monitor.height);
 
-            if (to < 0)
-                ws = curWs.get_neighbor(dir);
-            else if (dir == direction)
-                ws = workspaceManager.get_workspace_by_index(to);
+            this.add_actor(record.clipBin);
 
-            if (ws == null || ws == curWs) {
-                this._surroundings[dir] = null;
-                continue;
-            }
+            record.curGroup = new WorkspaceGroup(controller, curWs, monitor);
+            record.container.add_actor(record.curGroup);
+
+            for (let dir of Object.values(Meta.MotionDirection)) {
+                let ws = null;
+
+                if (to < 0)
+                    ws = curWs.get_neighbor(dir);
+                else if (dir == direction)
+                    ws = workspaceManager.get_workspace_by_index(to);
 
-            let [x, y] = this._getPositionForDirection(dir, curWs, ws);
-            let info = { index: ws.index(),
-                         actor: new WorkspaceGroup(controller, ws),
-                         xDest: x,
-                         yDest: y };
-            this._surroundings[dir] = info;
-            this._container.add_actor(info.actor);
-            this._container.set_child_above_sibling(info.actor, null);
+                if (ws == null || ws == curWs) {
+                    record.surroundings[dir] = null;
+                    continue;
+                }
 
-            info.actor.set_position(x, y);
+                let [x, y] = this._getPositionForDirection(dir, curWs, ws, monitor.index);
+                let info = { index: ws.index(),
+                             actor: new WorkspaceGroup(controller, ws, monitor),
+                             xDest: x,
+                             yDest: y };
+                record.surroundings[dir] = info;
+                record.container.add_actor(info.actor);
+                record.container.set_child_above_sibling(info.actor, null);
+
+                info.actor.set_position(x, y);
+            }
+
+            this._monitors.push(record);
         }
 
         if (this._controller.movingWindow) {
@@ -162,6 +177,10 @@ var WorkspaceAnimation = GObject.registerClass({
     _onDestroy() {
         this.remove_all_transitions();
 
+        for (let monitorData of this._monitors)
+            monitorData.clipBin.destroy();
+        this._monitors = [];
+
         if (this._movingWindow) {
             let record = this._movingWindow;
             record.window.disconnect(record.windowDestroyId);
@@ -171,38 +190,40 @@ var WorkspaceAnimation = GObject.registerClass({
 
             this._movingWindow = null;
         }
-
-        this._container.destroy();
     }
 
-    _getPositionForDirection(direction, fromWs, toWs) {
+    _getPositionForDirection(direction, fromWs, toWs, monitor) {
         let xDest = 0, yDest = 0;
 
-        let oldWsIsFullscreen = fromWs.list_windows().some(w => w.is_fullscreen());
-        let newWsIsFullscreen = toWs.list_windows().some(w => w.is_fullscreen());
+        let condition = w => w.get_monitor() == monitor && w.is_fullscreen();
+
+        let oldWsIsFullscreen = fromWs.list_windows().some(condition);
+        let newWsIsFullscreen = toWs.list_windows().some(condition);
+
+        let geometry = Main.layoutManager.monitors[monitor];
 
         // We have to shift windows up or down by the height of the panel to prevent having a
         // visible gap between the windows while switching workspaces. Since fullscreen windows
         // hide the panel, they don't need to be shifted up or down.
-        let shiftHeight = Main.panel.height;
+        let shiftHeight = monitor == Main.layoutManager.primaryIndex ? Main.panel.height : 0;
 
         if (direction == Meta.MotionDirection.UP ||
             direction == Meta.MotionDirection.UP_LEFT ||
             direction == Meta.MotionDirection.UP_RIGHT)
-            yDest = -global.screen_height + (oldWsIsFullscreen ? 0 : shiftHeight);
+            yDest = -geometry.height + (oldWsIsFullscreen ? 0 : shiftHeight);
         else if (direction == Meta.MotionDirection.DOWN ||
             direction == Meta.MotionDirection.DOWN_LEFT ||
             direction == Meta.MotionDirection.DOWN_RIGHT)
-            yDest = global.screen_height - (newWsIsFullscreen ? 0 : shiftHeight);
+            yDest = geometry.height - (newWsIsFullscreen ? 0 : shiftHeight);
 
         if (direction == Meta.MotionDirection.LEFT ||
             direction == Meta.MotionDirection.UP_LEFT ||
             direction == Meta.MotionDirection.DOWN_LEFT)
-            xDest = -global.screen_width;
+            xDest = -geometry.width;
         else if (direction == Meta.MotionDirection.RIGHT ||
                  direction == Meta.MotionDirection.UP_RIGHT ||
                  direction == Meta.MotionDirection.DOWN_RIGHT)
-            xDest = global.screen_width;
+            xDest = geometry.width;
 
         return [xDest, yDest];
     }
@@ -233,21 +254,24 @@ var WorkspaceAnimation = GObject.registerClass({
         this._progress = progress;
 
         let direction = this.directionForProgress(progress);
-        let xPos = 0;
-        let yPos = 0;
 
-        if (global.workspace_manager.layout_rows == -1)
-            yPos = -Math.round(progress * this._getDistance(direction));
-        else if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
-            xPos = Math.round(progress * this._getDistance(direction));
-        else
-            xPos = -Math.round(progress * this._getDistance(direction));
+        for (let monitorData of this._monitors) {
+            let xPos = 0;
+            let yPos = 0;
+
+            if (global.workspace_manager.layout_rows == -1)
+                yPos = -Math.round(progress * this._getDistance(monitorData, direction));
+            else if (Clutter.get_default_text_direction() == Clutter.TextDirection.RTL)
+                xPos = Math.round(progress * this._getDistance(monitorData, direction));
+            else
+                xPos = -Math.round(progress * this._getDistance(monitorData, direction));
 
-        this._container.set_position(xPos, yPos);
+            monitorData.container.set_position(xPos, yPos);
+        }
     }
 
-    _getDistance(direction) {
-        let info = this._surroundings[direction];
+    _getDistance(monitorData, direction) {
+        let info = monitorData.surroundings[direction];
         if (!info)
             return 0;
 
@@ -265,19 +289,30 @@ var WorkspaceAnimation = GObject.registerClass({
         return 0;
     }
 
-    getProgressRange() {
+    getProgressRange(monitor) {
+        let monitorData = null;
+        for (let data of this._monitors) {
+            if (data.index == monitor) {
+                monitorData = data;
+                break;
+            }
+        }
+
+        if (!monitorData)
+            return 0;
+
         let baseDistance;
         if (global.workspace_manager.layout_rows != -1)
-            baseDistance = global.screen_width;
+            baseDistance = Main.layoutManager.monitors[monitor].width;
         else
-            baseDistance = global.screen_height;
+            baseDistance = Main.layoutManager.monitors[monitor].height;
 
         let direction = this.directionForProgress(-1);
-        let distance = this._getDistance(direction);
+        let distance = this._getDistance(monitorData, direction);
         let lower = -distance / baseDistance;
 
         direction = this.directionForProgress(1);
-        distance = this._getDistance(direction);
+        distance = this._getDistance(monitorData, direction);
         let upper = distance / baseDistance;
 
         return [lower, upper];
@@ -334,6 +369,7 @@ var WorkspaceAnimationController = class {
         this._inProgress = false;
         this._gestureActivated = false;
         this.movingWindow = null;
+        this._monitor = null;
     }
 
     animateSwitchWorkspace(shellwm, from, to, direction) {
@@ -366,9 +402,9 @@ var WorkspaceAnimationController = class {
 
         let baseDistance;
         if (horiz)
-            baseDistance = global.screen_width;
+            baseDistance = Main.layoutManager.monitors[monitor].width;
         else
-            baseDistance = global.screen_height;
+            baseDistance = Main.layoutManager.monitors[monitor].height;
 
         let progress;
         if (this._gestureActivated) {
@@ -379,7 +415,8 @@ var WorkspaceAnimationController = class {
             progress = 0;
         }
 
-        let [lower, upper] = this._animation.getProgressRange();
+        this._monitor = monitor;
+        let [lower, upper] = this._animation.getProgressRange(monitor);
         if (progress < 0)
             progress *= -lower;
         else if (progress > 0)
@@ -399,7 +436,7 @@ var WorkspaceAnimationController = class {
 
     _switchWorkspaceUpdate(_tracker, progress) {
         // Translate the progress into [-1;1] range
-        let [lower, upper] = this._animation.getProgressRange();
+        let [lower, upper] = this._animation.getProgressRange(this._monitor);
         if (progress < 0)
             progress /= -lower;
         else if (progress > 0)
-- 
2.23.0

