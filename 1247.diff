diff --git a/clutter/clutter/clutter-actor-private.h b/clutter/clutter/clutter-actor-private.h
index 9ff4b2d4bd831d309dd1e41c29b75a6bf8d9d461..009eb425e9e9c8ae72c54932f9f88007a09a1bd4 100644
--- a/clutter/clutter/clutter-actor-private.h
+++ b/clutter/clutter/clutter-actor-private.h
@@ -321,6 +321,9 @@ gboolean                        _clutter_actor_get_real_resource_scale
 ClutterPaintNode *              clutter_actor_create_texture_paint_node                 (ClutterActor *self,
                                                                                          CoglTexture  *texture);
 
+void clutter_actor_get_allocation (ClutterActor    *self,
+                                   ClutterActorBox *box);
+
 G_END_DECLS
 
 #endif /* __CLUTTER_ACTOR_PRIVATE_H__ */
diff --git a/clutter/clutter/clutter-actor.c b/clutter/clutter/clutter-actor.c
index 0aa696042d1e2ac9d47ee85f7aac90efe5a1277d..766b63f5a00ef0ad0e3a8618d64dabda21c10f6d 100644
--- a/clutter/clutter/clutter-actor.c
+++ b/clutter/clutter/clutter-actor.c
@@ -2560,6 +2560,22 @@ clutter_actor_notify_if_geometry_changed (ClutterActor          *self,
   g_object_thaw_notify (obj);
 }
 
+static void
+absolute_allocation_changed (ClutterActor *actor)
+{
+  actor->priv->needs_compute_resource_scale = TRUE;
+}
+
+static ClutterActorTraverseVisitFlags
+absolute_allocation_changed_cb (ClutterActor *actor,
+                                int           depth,
+                                gpointer      user_data)
+{
+  absolute_allocation_changed (actor);
+
+  return CLUTTER_ACTOR_TRAVERSE_VISIT_CONTINUE;
+}
+
 /*< private >
  * clutter_actor_set_allocation_internal:
  * @self: a #ClutterActor
@@ -2603,6 +2619,11 @@ clutter_actor_set_allocation_internal (ClutterActor           *self,
   priv->needs_height_request = FALSE;
   priv->needs_allocation = FALSE;
 
+  priv->absolute_origin_changed |= x1_changed || y1_changed;
+
+  if (priv->absolute_origin_changed || x2_changed || y2_changed)
+    absolute_allocation_changed (self);
+
   if (x1_changed ||
       y1_changed ||
       x2_changed ||
@@ -9897,6 +9918,28 @@ clutter_actor_get_allocation_box (ClutterActor    *self,
   *box = self->priv->allocation;
 }
 
+/**
+ * clutter_actor_get_allocation: (skip)
+ * @self: A #ClutterActor
+ * @box: (out): A #ClutterActorBox the function sets to the actor's allocation
+ *
+ * Gets the layout box an actor has been assigned. The allocation can
+ * only be assumed valid during the paint cycle; anywhere else, it may
+ * be out-of-date. To check whether the current allocation is valid,
+ * clutter_actor_has_allocation() can be used.
+ *
+ * An allocation does not incorporate the actor's scale or anchor point;
+ * those transformations do not affect layout, only rendering.
+ */
+void
+clutter_actor_get_allocation (ClutterActor    *self,
+                              ClutterActorBox *box)
+{
+  g_return_if_fail (CLUTTER_IS_ACTOR (self));
+
+  *box = self->priv->allocation;
+}
+
 static void
 clutter_actor_update_constraints (ClutterActor    *self,
                                   ClutterActorBox *allocation)
@@ -10109,7 +10152,6 @@ clutter_actor_allocate (ClutterActor          *self,
 {
   ClutterActorBox old_allocation, real_allocation;
   gboolean origin_changed, size_changed;
-  gboolean stage_allocation_changed;
   ClutterActorPrivate *priv;
 
   g_return_if_fail (CLUTTER_IS_ACTOR (self));
@@ -10121,11 +10163,26 @@ clutter_actor_allocate (ClutterActor          *self,
       return;
     }
 
-  if (!clutter_actor_is_visible (self))
-    return;
-
   priv = self->priv;
 
+  priv->absolute_origin_changed = priv->parent
+                                ? priv->parent->priv->absolute_origin_changed
+                                : FALSE;
+
+  if (!CLUTTER_ACTOR_IS_VISIBLE (self))
+    {
+      if (priv->absolute_origin_changed)
+        {
+          _clutter_actor_traverse (self,
+                                   CLUTTER_ACTOR_TRAVERSE_DEPTH_FIRST,
+                                   absolute_allocation_changed_cb,
+                                   NULL,
+                                   NULL);
+        }
+
+      goto out;
+    }
+
   old_allocation = priv->allocation;
   real_allocation = *box;
 
@@ -10157,49 +10214,46 @@ clutter_actor_allocate (ClutterActor          *self,
   size_changed = (real_allocation.x2 != old_allocation.x2 ||
                   real_allocation.y2 != old_allocation.y2);
 
-  priv->absolute_origin_changed = priv->parent
-                                ? priv->parent->priv->absolute_origin_changed
-                                : FALSE;
-
-  priv->absolute_origin_changed |= origin_changed;
-
-  stage_allocation_changed = priv->absolute_origin_changed || size_changed;
-
-  /* If we get an allocation "out of the blue"
-   * (we did not queue relayout), then we want to
-   * ignore it. But if we have needs_allocation set,
-   * we want to guarantee that allocate() virtual
-   * method is always called, i.e. that queue_relayout()
-   * always results in an allocate() invocation on
-   * an actor.
+  /* When needs_allocation is set but we didn't move nor resize, we still
+   * want to call the allocate() vfunc because a child probably called
+   * queue_relayout() and needs a new allocation.
    *
-   * The optimization here is to avoid re-allocating
-   * actors that did not queue relayout and were
-   * not moved.
+   * In case needs_allocation isn't set and we didn't move nor resize, we
+   * can safely stop allocating, but we need to notify the sub-tree in case
+   * our absolute origin changed.
    */
-  if (!priv->needs_allocation && !stage_allocation_changed)
+  if (!priv->needs_allocation && !origin_changed && !size_changed)
     {
+      if (priv->absolute_origin_changed)
+        {
+          _clutter_actor_traverse (self,
+                                   CLUTTER_ACTOR_TRAVERSE_DEPTH_FIRST,
+                                   absolute_allocation_changed_cb,
+                                   NULL,
+                                   NULL);
+        }
+
       CLUTTER_NOTE (LAYOUT, "No allocation needed");
-      return;
+      goto out;
     }
 
   if (CLUTTER_ACTOR_IS_MAPPED (self))
     self->priv->needs_paint_volume_update = TRUE;
 
-  if (stage_allocation_changed)
-    priv->needs_compute_resource_scale = TRUE;
-
-  if (!stage_allocation_changed)
+  if (!origin_changed && !size_changed)
     {
       /* If the actor didn't move but needs_allocation is set, we just
-       * need to allocate the children */
+       * need to allocate the children (see comment above) */
       clutter_actor_allocate_internal (self, &real_allocation);
-      return;
+      goto out;
     }
 
   _clutter_actor_create_transition (self, obj_props[PROP_ALLOCATION],
                                     &priv->allocation,
                                     &real_allocation);
+
+out:
+  priv->absolute_origin_changed = FALSE;
 }
 
 /**
diff --git a/clutter/clutter/clutter-stage.c b/clutter/clutter/clutter-stage.c
index 9657dc8b5958436b1cc104ec828380491e350bda..0a8bca0466f2e113867303cec80f7e5607fc0880 100644
--- a/clutter/clutter/clutter-stage.c
+++ b/clutter/clutter/clutter-stage.c
@@ -627,7 +627,7 @@ clutter_stage_allocate (ClutterActor           *self,
     return;
 
   /* our old allocation */
-  clutter_actor_get_allocation_box (self, &alloc);
+  clutter_actor_get_allocation (self, &alloc);
   clutter_actor_box_get_size (&alloc, &old_width, &old_height);
 
   /* the current allocation */
